name: Deploy to Production

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose.yml'
      - '.github/workflows/deploy-production.yml'
  workflow_dispatch:
    inputs:
      clean_build:
        description: 'Force clean build without cache (use only if build issues occur)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write  # Required for pushing git tags (latest-stable)

env:
  GCP_ZONE: us-central1-a
  VM_NAME: charhub-vm
  APP_DIR: /mnt/stateful_partition/charhub

jobs:
  pre-deploy-checks:
    name: Pre-Deploy Checks
    runs-on: ubuntu-latest
    # Skip if commit message contains [skip ci] or [ci skip]
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify main branch
        if: github.event_name == 'push'
        run: |
          if [ "${{ github.ref }}" != "refs/heads/main" ]; then
            echo "‚ùå Only main branch can trigger automatic deploy"
            exit 1
          fi
          echo "‚úÖ On main branch - deploy will proceed"

      - name: List commits to deploy
        run: |
          echo "üìã Commits being deployed:"
          git log --oneline -5

  ci-gate:
    name: Wait for CI Pipelines (Backend + Frontend)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Skip if commit message contains [skip ci] or [ci skip]
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for Backend CI to complete
        run: |
          echo "üîÑ Waiting for Backend CI workflow to complete..."

          # Get the current workflow run ID
          CURRENT_RUN_ID="${{ github.run_id }}"

          # Get the commit SHA
          COMMIT_SHA="${{ github.sha }}"

          # Poll for Backend CI completion (max 30 retries = 30 minutes)
          for i in {1..30}; do
            echo "Attempt $i/30..."

            # Get the latest Backend CI run for this commit
            BACKEND_CI_RUN=$(gh run list \
              --workflow=backend-ci.yml \
              --branch=main \
              --json status,conclusion,databaseId \
              --limit=1 \
              --jq '.[] | {status, conclusion, id: .databaseId}' \
              2>/dev/null)

            if [ -z "$BACKEND_CI_RUN" ]; then
              echo "  ‚ÑπÔ∏è  Backend CI not yet started, waiting..."
              sleep 60
              continue
            fi

            STATUS=$(echo "$BACKEND_CI_RUN" | jq -r '.status')
            CONCLUSION=$(echo "$BACKEND_CI_RUN" | jq -r '.conclusion')

            if [ "$STATUS" = "completed" ]; then
              if [ "$CONCLUSION" = "success" ]; then
                echo "‚úÖ Backend CI passed!"
                exit 0
              else
                echo "‚ùå Backend CI failed (conclusion: $CONCLUSION)"
                exit 1
              fi
            else
              echo "  ‚è≥ Backend CI still running (status: $STATUS)"
              sleep 60
            fi
          done

          echo "‚ùå Timeout waiting for Backend CI to complete (30 minutes)"
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for Frontend CI to complete
        run: |
          echo "üîÑ Waiting for Frontend CI workflow to complete..."

          # Get the current workflow run ID
          CURRENT_RUN_ID="${{ github.run_id }}"

          # Get the commit SHA
          COMMIT_SHA="${{ github.sha }}"

          # Poll for Frontend CI completion (max 30 retries = 30 minutes)
          for i in {1..30}; do
            echo "Attempt $i/30..."

            # Get the latest Frontend CI run for this commit
            FRONTEND_CI_RUN=$(gh run list \
              --workflow=frontend-ci.yml \
              --branch=main \
              --json status,conclusion,databaseId \
              --limit=1 \
              --jq '.[] | {status, conclusion, id: .databaseId}' \
              2>/dev/null)

            if [ -z "$FRONTEND_CI_RUN" ]; then
              echo "  ‚ÑπÔ∏è  Frontend CI not yet started, waiting..."
              sleep 60
              continue
            fi

            STATUS=$(echo "$FRONTEND_CI_RUN" | jq -r '.status')
            CONCLUSION=$(echo "$FRONTEND_CI_RUN" | jq -r '.conclusion')

            if [ "$STATUS" = "completed" ]; then
              if [ "$CONCLUSION" = "success" ]; then
                echo "‚úÖ Frontend CI passed!"
                exit 0
              else
                echo "‚ùå Frontend CI failed (conclusion: $CONCLUSION)"
                exit 1
              fi
            else
              echo "  ‚è≥ Frontend CI still running (status: $STATUS)"
              sleep 60
            fi
          done

          echo "‚ùå Timeout waiting for Frontend CI to complete (30 minutes)"
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, ci-gate]
    # Skip if commit message contains [skip ci] or [ci skip]
    if: "success() && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    environment:
      name: production
      url: https://charhub.app

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY_PROD }}

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v3

      - name: Setup SSH Key
        run: |
          echo "üîë Setting up SSH key..."
          mkdir -p $HOME/.ssh
          echo "${{ secrets.GH_DEPLOY_SSH_PRIVATE_KEY }}" > $HOME/.ssh/deploy_key
          chmod 600 $HOME/.ssh/deploy_key

          # Add host key to known_hosts to avoid warning
          ssh-keyscan -H 34.66.66.202 >> $HOME/.ssh/known_hosts 2>/dev/null || true

          echo "‚úÖ SSH key configured"

      - name: Test SSH Connection
        run: |
          echo "üîå Testing SSH connection..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'echo "‚úÖ SSH connection successful"'

      - name: Pull Latest Code
        run: |
          echo "üì• Pulling latest code from GitHub..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'PULL'
          APP_DIR="/mnt/stateful_partition/charhub"
          cd "$APP_DIR"

          # Fix all file permissions (from previous sudo operations)
          sudo chown -R leandro_br_dev_gmail_com:leandro_br_dev_gmail_com "$APP_DIR" 2>/dev/null || true
          sudo chmod -R u+w "$APP_DIR" 2>/dev/null || true

          # Configure git to allow access to repo (BEFORE any git commands)
          git config --global --add safe.directory "$APP_DIR" 2>/dev/null || true
          git config --local --add safe.directory "$APP_DIR" 2>/dev/null || true

          # Verify safe.directory was set
          echo "‚úì Git safe.directory configured"

          git fetch origin
          BEFORE=$(git rev-parse HEAD)
          git reset --hard origin/main
          AFTER=$(git rev-parse HEAD)

          if [ "$BEFORE" = "$AFTER" ]; then
            echo "‚ö†Ô∏è  No new commits"
            exit 0
          fi

          echo "üìù New commits:"
          git log --oneline $BEFORE..$AFTER
          PULL

      - name: Sync Cloudflare Credentials
        run: |
          echo "üîê Syncing Cloudflare credentials..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'CREDS'
          APP_DIR="/mnt/stateful_partition/charhub"
          # Verify cloudflared config directory exists
          sudo mkdir -p "$APP_DIR/cloudflared/config/prod"
          sudo chmod 755 "$APP_DIR/cloudflared/config/prod"
          CREDS

      - name: Create Pre-Deploy Database Backup
        id: backup
        run: |
          echo "üíæ Creating database backup before deploy..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'BACKUP'
          cd /mnt/stateful_partition/charhub

          # Make backup script executable
          chmod +x scripts/ops/backup-database.sh

          # Run backup
          export GITHUB_SHA="${{ github.sha }}"
          export APP_DIR="/mnt/stateful_partition/charhub"
          export COMPOSE="/var/lib/toolbox/bin/docker-compose"
          export POSTGRES_USER="charhub"
          export POSTGRES_DB="charhub_db"
          ./scripts/ops/backup-database.sh

          echo "‚úÖ Pre-deploy backup completed"
          BACKUP

      - name: Rebuild Containers
        run: |
          echo "üî® Rebuilding containers..."
          CLEAN_BUILD="${{ github.event.inputs.clean_build || 'false' }}"

          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              "bash -s" << BUILD
          cd /mnt/stateful_partition/charhub
          COMPOSE="/var/lib/toolbox/bin/docker-compose"
          CLEAN_BUILD="$CLEAN_BUILD"

          # Set HOME to user's home directory (Container-Optimized OS best practice)
          # This allows Docker to create config files in /home/user/.docker/
          export HOME="/home/leandro_br_dev_gmail_com"

          echo "Stopping containers..."
          sudo -E HOME="\$HOME" \$COMPOSE down --remove-orphans 2>/dev/null || true

          echo "Waiting for containers to fully stop..."
          sleep 5

          # Enable BuildKit for cache mount support (saves 8-12 min on rebuilds)
          export DOCKER_BUILDKIT=1

          if [ "\$CLEAN_BUILD" = "true" ]; then
            echo "üî® Clean build requested - rebuilding without cache..."
            sudo -E HOME="\$HOME" DOCKER_BUILDKIT=1 \$COMPOSE build --no-cache --pull
          else
            echo "üî® Building with cache (Docker BuildKit enabled)..."
            echo "   Use 'Run workflow' with clean_build=true for clean build"
            sudo -E HOME="\$HOME" DOCKER_BUILDKIT=1 \$COMPOSE build
          fi

          echo "Starting containers..."
          sudo -E HOME="\$HOME" \$COMPOSE up -d

          sleep 15
          echo "‚úÖ Containers started"
          BUILD

      - name: Health Check
        run: |
          echo "üè• Running health check..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'HEALTH'
          cd /mnt/stateful_partition/charhub
          COMPOSE="/var/lib/toolbox/bin/docker-compose"

          # Optimized health check: 20 attempts √ó 3s = 1min max (was 30 √ó 5s = 2.5min)
          # Backend typically becomes healthy in 30-40s, so this is still safe
          for i in {1..20}; do
            echo "Attempt $i/20..."

            # Check if backend container is healthy
            STATUS=$(sudo $COMPOSE ps backend --format='{{.Status}}' 2>/dev/null)

            if [[ "$STATUS" =~ "healthy" ]]; then
              echo "‚úÖ Backend healthy: $STATUS"
              exit 0
            elif [[ "$STATUS" =~ "Up" ]]; then
              echo "‚ÑπÔ∏è  Backend running (health check may still be initializing): $STATUS"
              # Give a few more attempts for health check to complete
              if [ $i -gt 5 ]; then
                exit 0
              fi
            fi

            sleep 3
          done

          echo "‚ùå Health check failed - backend not healthy after 20 attempts (60s)"
          echo "Final status:"
          sudo $COMPOSE ps backend
          exit 1
          HEALTH

      - name: Mark Deployment as Stable
        if: success()
        run: |
          echo "‚úÖ Health check passed - marking as stable version"

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Create tag with timestamp (for history)
          STABLE_TAG="stable-$(date +%Y%m%d-%H%M%S)"
          git tag -a "$STABLE_TAG" -m "Stable deployment - commit ${{ github.sha }}"

          # Move tag 'latest-stable' to this commit
          git tag -f latest-stable -m "Latest stable version - deployed at $(date)"

          # Push tags to origin
          git push origin "$STABLE_TAG"
          git push origin latest-stable --force

          echo "üìå Tagged as: $STABLE_TAG"
          echo "üìå Moved 'latest-stable' to current commit"

      - name: Rollback to Last Stable Version
        if: failure()
        run: |
          echo "‚ùå Health check failed - rolling back to last stable version..."

          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'ROLLBACK'

          APP_DIR="/mnt/stateful_partition/charhub"
          COMPOSE="/var/lib/toolbox/bin/docker-compose"
          cd "$APP_DIR"

          # Fix permissions
          sudo chown -R leandro_br_dev_gmail_com:leandro_br_dev_gmail_com "$APP_DIR" 2>/dev/null || true
          sudo chmod -R u+w "$APP_DIR" 2>/dev/null || true
          git config --global --add safe.directory "$APP_DIR" 2>/dev/null || true

          # Fetch latest tags
          git fetch --tags

          # Verificar se tag latest-stable existe
          if ! git rev-parse latest-stable >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag 'latest-stable' not found!"
            echo "This is likely the first deployment with this feature."
            echo "Falling back to HEAD~1 (legacy behavior)"
            ROLLBACK_TARGET="HEAD~1"
          else
            ROLLBACK_TARGET="latest-stable"
            echo "üìå Found latest-stable tag"
          fi

          # Get commit info
          CURRENT=$(git rev-parse HEAD)
          STABLE=$(git rev-parse $ROLLBACK_TARGET)

          echo "Current commit (failed): $CURRENT"
          echo "Rolling back to: $STABLE ($ROLLBACK_TARGET)"

          # Verificar se j√° estamos na vers√£o est√°vel
          if [ "$CURRENT" = "$STABLE" ]; then
            echo "‚ö†Ô∏è  Already at stable version but health check failed!"
            echo "This indicates the stable version is broken - CRITICAL!"
            echo "Manual intervention required - do not rollback further"
            exit 1
          fi

          # Mostrar log de commits que ser√£o revertidos
          echo ""
          echo "üìù Commits being reverted:"
          git log --oneline $STABLE..$CURRENT
          echo ""

          # Rollback para vers√£o est√°vel
          git reset --hard $ROLLBACK_TARGET
          echo "‚úÖ Code rolled back to stable version"

          # Restore database backup
          echo "üîÑ Restoring database from backup..."
          BACKUP_FILE=$(ls -t backups/database/backup_*.sql.gz | head -1)
          if [ -f "$BACKUP_FILE" ]; then
            echo "Restoring from: $BACKUP_FILE"
            chmod +x scripts/ops/restore-database-backup.sh
            export SKIP_CONFIRMATION="true"
            ./scripts/ops/restore-database-backup.sh "$BACKUP_FILE" || echo "‚ö†Ô∏è  Database restore failed"
          else
            echo "‚ö†Ô∏è  No backup found, skipping database restore"
          fi

          # Rebuild containers
          export HOME="/home/leandro_br_dev_gmail_com"
          echo "üî® Rebuilding containers with stable version..."
          sudo -E HOME="$HOME" $COMPOSE down --remove-orphans
          sleep 5
          sudo -E HOME="$HOME" $COMPOSE build --pull
          sudo -E HOME="$HOME" $COMPOSE up -d
          sleep 15

          # Verify rollback
          STATUS=$(sudo $COMPOSE ps backend --format='{{.Status}}' 2>/dev/null)
          echo "Backend status after rollback: $STATUS"

          if [[ "$STATUS" =~ "Up" ]] || [[ "$STATUS" =~ "healthy" ]]; then
            echo "‚úÖ Rollback successful - stable version restored"
            exit 0
          else
            echo "‚ùå Rollback failed - manual intervention required"
            exit 1
          fi
          ROLLBACK

      - name: Notify Rollback Details
        if: failure()
        run: |
          echo "üö® AUTOMATIC ROLLBACK EXECUTED"
          echo ""
          echo "Failed commit: ${{ github.sha }}"
          echo "Rolled back to: latest-stable tag"
          echo ""
          echo "Action required:"
          echo "1. Check GitHub Actions logs for reverted commits"
          echo "2. Fix the issue locally"
          echo "3. Test thoroughly before pushing again"
          echo ""
          echo "View stable versions: git tag -l 'stable-*'"
          echo "View latest stable: git show latest-stable"

      - name: Verify Deployment
        run: |
          echo "üìä Verifying deployment..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'VERIFY'
          cd /mnt/stateful_partition/charhub

          # Fix all file permissions
          sudo chown -R leandro_br_dev_gmail_com:leandro_br_dev_gmail_com . 2>/dev/null || true
          sudo chmod -R u+w . 2>/dev/null || true

          # Configure git BEFORE using git commands
          git config --global --add safe.directory "$(pwd)" 2>/dev/null || true
          git config --local --add safe.directory "$(pwd)" 2>/dev/null || true

          COMPOSE="/var/lib/toolbox/bin/docker-compose"

          echo "Container status:"
          sudo $COMPOSE ps

          echo ""
          echo "Git status:"
          git log -1 --oneline

          echo ""
          echo "‚úÖ Deployment verified"
          VERIFY

      - name: Monitor Disk Space
        run: |
          echo "üíæ Monitoring disk space..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'MONITOR'
          cd /mnt/stateful_partition/charhub

          # Run disk space monitoring script
          if [ -f scripts/ops/monitor-disk-space.sh ]; then
            chmod +x scripts/ops/monitor-disk-space.sh
            ./scripts/ops/monitor-disk-space.sh || true
          else
            echo "‚ö†Ô∏è  Monitoring script not found, showing basic stats..."
            df -h /mnt/stateful_partition
            sudo docker system df
          fi
          MONITOR

      - name: Cleanup Docker Resources
        run: |
          echo "üßπ Cleaning up Docker resources..."
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -i $HOME/.ssh/deploy_key \
              leandro_br_dev_gmail_com@34.66.66.202 \
              'bash -s' << 'CLEANUP'
          cd /mnt/stateful_partition/charhub

          # Get current disk usage
          DISK_USAGE=$(df /mnt/stateful_partition | awk 'NR==2 {print $5}' | sed 's/%//')

          echo "Current disk usage: ${DISK_USAGE}%"

          # Run cleanup if disk usage > 70% or if cleanup script exists
          if [ "$DISK_USAGE" -gt 70 ] || [ -f scripts/ops/cleanup-docker.sh ]; then
            echo "Running Docker cleanup (disk usage: ${DISK_USAGE}%)..."

            if [ -f scripts/ops/cleanup-docker.sh ]; then
              # Execute script with sudo and explicit bash (fixes "Permission denied" error)
              sudo bash scripts/ops/cleanup-docker.sh
            else
              echo "‚ö†Ô∏è  Cleanup script not found, running manual cleanup..."
              # Remove dangling images and build cache
              sudo docker image prune -af
              # Remove dangling volumes only
              sudo docker volume prune -f
              echo "‚úÖ Manual cleanup completed"
            fi
          else
            echo "‚úÖ Disk usage healthy (${DISK_USAGE}%), skipping cleanup"
          fi
          CLEANUP

      - name: Notify Success
        if: success()
        run: |
          echo "‚úÖ Deployment successful!"
          echo "URL: https://charhub.app"
          echo "Commit: ${{ github.sha }}"

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f $HOME/.ssh/deploy_key
          echo "‚úÖ SSH key cleaned up"
