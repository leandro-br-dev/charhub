
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ContentClassification
 * 
 */
export type ContentClassification = $Result.DefaultSelection<Prisma.$ContentClassificationPayload>
/**
 * Model Lora
 * 
 */
export type Lora = $Result.DefaultSelection<Prisma.$LoraPayload>
/**
 * Model Attire
 * 
 */
export type Attire = $Result.DefaultSelection<Prisma.$AttirePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CharacterSticker
 * 
 */
export type CharacterSticker = $Result.DefaultSelection<Prisma.$CharacterStickerPayload>
/**
 * Model CharacterImage
 * 
 */
export type CharacterImage = $Result.DefaultSelection<Prisma.$CharacterImagePayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model Assistant
 * 
 */
export type Assistant = $Result.DefaultSelection<Prisma.$AssistantPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model UserConversationMembership
 * 
 */
export type UserConversationMembership = $Result.DefaultSelection<Prisma.$UserConversationMembershipPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model FavoriteCharacter
 * 
 */
export type FavoriteCharacter = $Result.DefaultSelection<Prisma.$FavoriteCharacterPayload>
/**
 * Model ContentTranslation
 * 
 */
export type ContentTranslation = $Result.DefaultSelection<Prisma.$ContentTranslationPayload>
/**
 * Model ConversationMemory
 * 
 */
export type ConversationMemory = $Result.DefaultSelection<Prisma.$ConversationMemoryPayload>
/**
 * Model CreditTransaction
 * 
 */
export type CreditTransaction = $Result.DefaultSelection<Prisma.$CreditTransactionPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model ServiceCreditCost
 * 
 */
export type ServiceCreditCost = $Result.DefaultSelection<Prisma.$ServiceCreditCostPayload>
/**
 * Model UsageLog
 * 
 */
export type UsageLog = $Result.DefaultSelection<Prisma.$UsageLogPayload>
/**
 * Model UserMonthlyBalance
 * 
 */
export type UserMonthlyBalance = $Result.DefaultSelection<Prisma.$UserMonthlyBalancePayload>
/**
 * Model UserPlan
 * 
 */
export type UserPlan = $Result.DefaultSelection<Prisma.$UserPlanPayload>
/**
 * Model UserPlusAccess
 * 
 */
export type UserPlusAccess = $Result.DefaultSelection<Prisma.$UserPlusAccessPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  GOOGLE: 'GOOGLE',
  FACEBOOK: 'FACEBOOK'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const UserRole: {
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AgeRating: {
  L: 'L',
  TEN: 'TEN',
  TWELVE: 'TWELVE',
  FOURTEEN: 'FOURTEEN',
  SIXTEEN: 'SIXTEEN',
  EIGHTEEN: 'EIGHTEEN'
};

export type AgeRating = (typeof AgeRating)[keyof typeof AgeRating]


export const ContentTag: {
  VIOLENCE: 'VIOLENCE',
  GORE: 'GORE',
  SEXUAL: 'SEXUAL',
  NUDITY: 'NUDITY',
  LANGUAGE: 'LANGUAGE',
  DRUGS: 'DRUGS',
  ALCOHOL: 'ALCOHOL',
  HORROR: 'HORROR',
  PSYCHOLOGICAL: 'PSYCHOLOGICAL',
  DISCRIMINATION: 'DISCRIMINATION',
  CRIME: 'CRIME',
  GAMBLING: 'GAMBLING'
};

export type ContentTag = (typeof ContentTag)[keyof typeof ContentTag]


export const Visibility: {
  PRIVATE: 'PRIVATE',
  UNLISTED: 'UNLISTED',
  PUBLIC: 'PUBLIC'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const VisualStyle: {
  ANIME: 'ANIME',
  REALISTIC: 'REALISTIC',
  SEMI_REALISTIC: 'SEMI_REALISTIC',
  CARTOON: 'CARTOON',
  MANGA: 'MANGA',
  MANHWA: 'MANHWA',
  COMIC: 'COMIC',
  CHIBI: 'CHIBI',
  PIXEL_ART: 'PIXEL_ART',
  THREE_D: 'THREE_D'
};

export type VisualStyle = (typeof VisualStyle)[keyof typeof VisualStyle]


export const AvatarSource: {
  PROVIDER: 'PROVIDER',
  UPLOADED: 'UPLOADED'
};

export type AvatarSource = (typeof AvatarSource)[keyof typeof AvatarSource]


export const StickerStatus: {
  PENDING: 'PENDING',
  GENERATING: 'GENERATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type StickerStatus = (typeof StickerStatus)[keyof typeof StickerStatus]


export const ImageType: {
  AVATAR: 'AVATAR',
  COVER: 'COVER',
  SAMPLE: 'SAMPLE',
  STICKER: 'STICKER',
  OTHER: 'OTHER'
};

export type ImageType = (typeof ImageType)[keyof typeof ImageType]


export const TagType: {
  CHARACTER: 'CHARACTER',
  STORY: 'STORY',
  ASSET: 'ASSET',
  GAME: 'GAME',
  MEDIA: 'MEDIA',
  GENERAL: 'GENERAL'
};

export type TagType = (typeof TagType)[keyof typeof TagType]


export const SenderType: {
  USER: 'USER',
  CHARACTER: 'CHARACTER',
  ASSISTANT: 'ASSISTANT',
  SYSTEM: 'SYSTEM'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const MembershipRole: {
  OWNER: 'OWNER',
  MODERATOR: 'MODERATOR',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type MembershipRole = (typeof MembershipRole)[keyof typeof MembershipRole]


export const TranslationStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  OUTDATED: 'OUTDATED',
  FAILED: 'FAILED',
  REVIEWED: 'REVIEWED'
};

export type TranslationStatus = (typeof TranslationStatus)[keyof typeof TranslationStatus]


export const CreditTransactionType: {
  GRANT_INITIAL: 'GRANT_INITIAL',
  GRANT_PLAN: 'GRANT_PLAN',
  PURCHASE: 'PURCHASE',
  CONSUMPTION: 'CONSUMPTION',
  SYSTEM_REWARD: 'SYSTEM_REWARD',
  REFUND: 'REFUND',
  ADJUSTMENT: 'ADJUSTMENT',
  REFERRAL_BONUS: 'REFERRAL_BONUS',
  PROMOTIONAL: 'PROMOTIONAL'
};

export type CreditTransactionType = (typeof CreditTransactionType)[keyof typeof CreditTransactionType]


export const PlanTier: {
  FREE: 'FREE',
  PLUS: 'PLUS',
  PREMIUM: 'PREMIUM'
};

export type PlanTier = (typeof PlanTier)[keyof typeof PlanTier]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  PAYMENT_FAILED: 'PAYMENT_FAILED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AgeRating = $Enums.AgeRating

export const AgeRating: typeof $Enums.AgeRating

export type ContentTag = $Enums.ContentTag

export const ContentTag: typeof $Enums.ContentTag

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type VisualStyle = $Enums.VisualStyle

export const VisualStyle: typeof $Enums.VisualStyle

export type AvatarSource = $Enums.AvatarSource

export const AvatarSource: typeof $Enums.AvatarSource

export type StickerStatus = $Enums.StickerStatus

export const StickerStatus: typeof $Enums.StickerStatus

export type ImageType = $Enums.ImageType

export const ImageType: typeof $Enums.ImageType

export type TagType = $Enums.TagType

export const TagType: typeof $Enums.TagType

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type MembershipRole = $Enums.MembershipRole

export const MembershipRole: typeof $Enums.MembershipRole

export type TranslationStatus = $Enums.TranslationStatus

export const TranslationStatus: typeof $Enums.TranslationStatus

export type CreditTransactionType = $Enums.CreditTransactionType

export const CreditTransactionType: typeof $Enums.CreditTransactionType

export type PlanTier = $Enums.PlanTier

export const PlanTier: typeof $Enums.PlanTier

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentClassification`: Exposes CRUD operations for the **ContentClassification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentClassifications
    * const contentClassifications = await prisma.contentClassification.findMany()
    * ```
    */
  get contentClassification(): Prisma.ContentClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lora`: Exposes CRUD operations for the **Lora** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loras
    * const loras = await prisma.lora.findMany()
    * ```
    */
  get lora(): Prisma.LoraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attire`: Exposes CRUD operations for the **Attire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attires
    * const attires = await prisma.attire.findMany()
    * ```
    */
  get attire(): Prisma.AttireDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterSticker`: Exposes CRUD operations for the **CharacterSticker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterStickers
    * const characterStickers = await prisma.characterSticker.findMany()
    * ```
    */
  get characterSticker(): Prisma.CharacterStickerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterImage`: Exposes CRUD operations for the **CharacterImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterImages
    * const characterImages = await prisma.characterImage.findMany()
    * ```
    */
  get characterImage(): Prisma.CharacterImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assistant`: Exposes CRUD operations for the **Assistant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assistants
    * const assistants = await prisma.assistant.findMany()
    * ```
    */
  get assistant(): Prisma.AssistantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userConversationMembership`: Exposes CRUD operations for the **UserConversationMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConversationMemberships
    * const userConversationMemberships = await prisma.userConversationMembership.findMany()
    * ```
    */
  get userConversationMembership(): Prisma.UserConversationMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteCharacter`: Exposes CRUD operations for the **FavoriteCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteCharacters
    * const favoriteCharacters = await prisma.favoriteCharacter.findMany()
    * ```
    */
  get favoriteCharacter(): Prisma.FavoriteCharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentTranslation`: Exposes CRUD operations for the **ContentTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentTranslations
    * const contentTranslations = await prisma.contentTranslation.findMany()
    * ```
    */
  get contentTranslation(): Prisma.ContentTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationMemory`: Exposes CRUD operations for the **ConversationMemory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMemories
    * const conversationMemories = await prisma.conversationMemory.findMany()
    * ```
    */
  get conversationMemory(): Prisma.ConversationMemoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTransaction`: Exposes CRUD operations for the **CreditTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTransactions
    * const creditTransactions = await prisma.creditTransaction.findMany()
    * ```
    */
  get creditTransaction(): Prisma.CreditTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCreditCost`: Exposes CRUD operations for the **ServiceCreditCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCreditCosts
    * const serviceCreditCosts = await prisma.serviceCreditCost.findMany()
    * ```
    */
  get serviceCreditCost(): Prisma.ServiceCreditCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageLog`: Exposes CRUD operations for the **UsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageLogs
    * const usageLogs = await prisma.usageLog.findMany()
    * ```
    */
  get usageLog(): Prisma.UsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMonthlyBalance`: Exposes CRUD operations for the **UserMonthlyBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMonthlyBalances
    * const userMonthlyBalances = await prisma.userMonthlyBalance.findMany()
    * ```
    */
  get userMonthlyBalance(): Prisma.UserMonthlyBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPlan`: Exposes CRUD operations for the **UserPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPlans
    * const userPlans = await prisma.userPlan.findMany()
    * ```
    */
  get userPlan(): Prisma.UserPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPlusAccess`: Exposes CRUD operations for the **UserPlusAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPlusAccesses
    * const userPlusAccesses = await prisma.userPlusAccess.findMany()
    * ```
    */
  get userPlusAccess(): Prisma.UserPlusAccessDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ContentClassification: 'ContentClassification',
    Lora: 'Lora',
    Attire: 'Attire',
    Tag: 'Tag',
    Character: 'Character',
    CharacterSticker: 'CharacterSticker',
    CharacterImage: 'CharacterImage',
    Story: 'Story',
    Assistant: 'Assistant',
    Conversation: 'Conversation',
    UserConversationMembership: 'UserConversationMembership',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    FavoriteCharacter: 'FavoriteCharacter',
    ContentTranslation: 'ContentTranslation',
    ConversationMemory: 'ConversationMemory',
    CreditTransaction: 'CreditTransaction',
    Plan: 'Plan',
    ServiceCreditCost: 'ServiceCreditCost',
    UsageLog: 'UsageLog',
    UserMonthlyBalance: 'UserMonthlyBalance',
    UserPlan: 'UserPlan',
    UserPlusAccess: 'UserPlusAccess'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "contentClassification" | "lora" | "attire" | "tag" | "character" | "characterSticker" | "characterImage" | "story" | "assistant" | "conversation" | "userConversationMembership" | "conversationParticipant" | "message" | "favoriteCharacter" | "contentTranslation" | "conversationMemory" | "creditTransaction" | "plan" | "serviceCreditCost" | "usageLog" | "userMonthlyBalance" | "userPlan" | "userPlusAccess"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ContentClassification: {
        payload: Prisma.$ContentClassificationPayload<ExtArgs>
        fields: Prisma.ContentClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          findFirst: {
            args: Prisma.ContentClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          findMany: {
            args: Prisma.ContentClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>[]
          }
          create: {
            args: Prisma.ContentClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          createMany: {
            args: Prisma.ContentClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>[]
          }
          delete: {
            args: Prisma.ContentClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          update: {
            args: Prisma.ContentClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          deleteMany: {
            args: Prisma.ContentClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>[]
          }
          upsert: {
            args: Prisma.ContentClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentClassificationPayload>
          }
          aggregate: {
            args: Prisma.ContentClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentClassification>
          }
          groupBy: {
            args: Prisma.ContentClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<ContentClassificationCountAggregateOutputType> | number
          }
        }
      }
      Lora: {
        payload: Prisma.$LoraPayload<ExtArgs>
        fields: Prisma.LoraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          findFirst: {
            args: Prisma.LoraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          findMany: {
            args: Prisma.LoraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>[]
          }
          create: {
            args: Prisma.LoraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          createMany: {
            args: Prisma.LoraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>[]
          }
          delete: {
            args: Prisma.LoraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          update: {
            args: Prisma.LoraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          deleteMany: {
            args: Prisma.LoraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>[]
          }
          upsert: {
            args: Prisma.LoraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoraPayload>
          }
          aggregate: {
            args: Prisma.LoraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLora>
          }
          groupBy: {
            args: Prisma.LoraGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoraGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoraCountArgs<ExtArgs>
            result: $Utils.Optional<LoraCountAggregateOutputType> | number
          }
        }
      }
      Attire: {
        payload: Prisma.$AttirePayload<ExtArgs>
        fields: Prisma.AttireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          findFirst: {
            args: Prisma.AttireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          findMany: {
            args: Prisma.AttireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>[]
          }
          create: {
            args: Prisma.AttireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          createMany: {
            args: Prisma.AttireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>[]
          }
          delete: {
            args: Prisma.AttireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          update: {
            args: Prisma.AttireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          deleteMany: {
            args: Prisma.AttireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttireUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>[]
          }
          upsert: {
            args: Prisma.AttireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttirePayload>
          }
          aggregate: {
            args: Prisma.AttireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttire>
          }
          groupBy: {
            args: Prisma.AttireGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttireGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttireCountArgs<ExtArgs>
            result: $Utils.Optional<AttireCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CharacterSticker: {
        payload: Prisma.$CharacterStickerPayload<ExtArgs>
        fields: Prisma.CharacterStickerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterStickerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterStickerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          findFirst: {
            args: Prisma.CharacterStickerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterStickerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          findMany: {
            args: Prisma.CharacterStickerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>[]
          }
          create: {
            args: Prisma.CharacterStickerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          createMany: {
            args: Prisma.CharacterStickerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterStickerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>[]
          }
          delete: {
            args: Prisma.CharacterStickerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          update: {
            args: Prisma.CharacterStickerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          deleteMany: {
            args: Prisma.CharacterStickerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterStickerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterStickerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>[]
          }
          upsert: {
            args: Prisma.CharacterStickerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterStickerPayload>
          }
          aggregate: {
            args: Prisma.CharacterStickerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterSticker>
          }
          groupBy: {
            args: Prisma.CharacterStickerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterStickerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterStickerCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterStickerCountAggregateOutputType> | number
          }
        }
      }
      CharacterImage: {
        payload: Prisma.$CharacterImagePayload<ExtArgs>
        fields: Prisma.CharacterImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          findFirst: {
            args: Prisma.CharacterImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          findMany: {
            args: Prisma.CharacterImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>[]
          }
          create: {
            args: Prisma.CharacterImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          createMany: {
            args: Prisma.CharacterImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>[]
          }
          delete: {
            args: Prisma.CharacterImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          update: {
            args: Prisma.CharacterImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          deleteMany: {
            args: Prisma.CharacterImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>[]
          }
          upsert: {
            args: Prisma.CharacterImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterImagePayload>
          }
          aggregate: {
            args: Prisma.CharacterImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterImage>
          }
          groupBy: {
            args: Prisma.CharacterImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterImageCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterImageCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      Assistant: {
        payload: Prisma.$AssistantPayload<ExtArgs>
        fields: Prisma.AssistantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssistantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssistantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          findFirst: {
            args: Prisma.AssistantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssistantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          findMany: {
            args: Prisma.AssistantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>[]
          }
          create: {
            args: Prisma.AssistantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          createMany: {
            args: Prisma.AssistantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssistantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>[]
          }
          delete: {
            args: Prisma.AssistantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          update: {
            args: Prisma.AssistantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          deleteMany: {
            args: Prisma.AssistantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssistantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssistantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>[]
          }
          upsert: {
            args: Prisma.AssistantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssistantPayload>
          }
          aggregate: {
            args: Prisma.AssistantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssistant>
          }
          groupBy: {
            args: Prisma.AssistantGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssistantGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssistantCountArgs<ExtArgs>
            result: $Utils.Optional<AssistantCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      UserConversationMembership: {
        payload: Prisma.$UserConversationMembershipPayload<ExtArgs>
        fields: Prisma.UserConversationMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConversationMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConversationMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          findFirst: {
            args: Prisma.UserConversationMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConversationMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          findMany: {
            args: Prisma.UserConversationMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>[]
          }
          create: {
            args: Prisma.UserConversationMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          createMany: {
            args: Prisma.UserConversationMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConversationMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>[]
          }
          delete: {
            args: Prisma.UserConversationMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          update: {
            args: Prisma.UserConversationMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          deleteMany: {
            args: Prisma.UserConversationMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConversationMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserConversationMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>[]
          }
          upsert: {
            args: Prisma.UserConversationMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConversationMembershipPayload>
          }
          aggregate: {
            args: Prisma.UserConversationMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConversationMembership>
          }
          groupBy: {
            args: Prisma.UserConversationMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConversationMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConversationMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<UserConversationMembershipCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      FavoriteCharacter: {
        payload: Prisma.$FavoriteCharacterPayload<ExtArgs>
        fields: Prisma.FavoriteCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteCharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteCharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          findFirst: {
            args: Prisma.FavoriteCharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteCharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          findMany: {
            args: Prisma.FavoriteCharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>[]
          }
          create: {
            args: Prisma.FavoriteCharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          createMany: {
            args: Prisma.FavoriteCharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>[]
          }
          delete: {
            args: Prisma.FavoriteCharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          update: {
            args: Prisma.FavoriteCharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          deleteMany: {
            args: Prisma.FavoriteCharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteCharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteCharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>[]
          }
          upsert: {
            args: Prisma.FavoriteCharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteCharacterPayload>
          }
          aggregate: {
            args: Prisma.FavoriteCharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteCharacter>
          }
          groupBy: {
            args: Prisma.FavoriteCharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCharacterCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCharacterCountAggregateOutputType> | number
          }
        }
      }
      ContentTranslation: {
        payload: Prisma.$ContentTranslationPayload<ExtArgs>
        fields: Prisma.ContentTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          findFirst: {
            args: Prisma.ContentTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          findMany: {
            args: Prisma.ContentTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>[]
          }
          create: {
            args: Prisma.ContentTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          createMany: {
            args: Prisma.ContentTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>[]
          }
          delete: {
            args: Prisma.ContentTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          update: {
            args: Prisma.ContentTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ContentTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ContentTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTranslationPayload>
          }
          aggregate: {
            args: Prisma.ContentTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentTranslation>
          }
          groupBy: {
            args: Prisma.ContentTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ContentTranslationCountAggregateOutputType> | number
          }
        }
      }
      ConversationMemory: {
        payload: Prisma.$ConversationMemoryPayload<ExtArgs>
        fields: Prisma.ConversationMemoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationMemoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationMemoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          findFirst: {
            args: Prisma.ConversationMemoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationMemoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          findMany: {
            args: Prisma.ConversationMemoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>[]
          }
          create: {
            args: Prisma.ConversationMemoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          createMany: {
            args: Prisma.ConversationMemoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationMemoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>[]
          }
          delete: {
            args: Prisma.ConversationMemoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          update: {
            args: Prisma.ConversationMemoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          deleteMany: {
            args: Prisma.ConversationMemoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationMemoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationMemoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>[]
          }
          upsert: {
            args: Prisma.ConversationMemoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemoryPayload>
          }
          aggregate: {
            args: Prisma.ConversationMemoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationMemory>
          }
          groupBy: {
            args: Prisma.ConversationMemoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationMemoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationMemoryCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationMemoryCountAggregateOutputType> | number
          }
        }
      }
      CreditTransaction: {
        payload: Prisma.$CreditTransactionPayload<ExtArgs>
        fields: Prisma.CreditTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          findFirst: {
            args: Prisma.CreditTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          findMany: {
            args: Prisma.CreditTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          create: {
            args: Prisma.CreditTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          createMany: {
            args: Prisma.CreditTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          delete: {
            args: Prisma.CreditTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          update: {
            args: Prisma.CreditTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CreditTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CreditTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          aggregate: {
            args: Prisma.CreditTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTransaction>
          }
          groupBy: {
            args: Prisma.CreditTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTransactionCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      ServiceCreditCost: {
        payload: Prisma.$ServiceCreditCostPayload<ExtArgs>
        fields: Prisma.ServiceCreditCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCreditCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCreditCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          findFirst: {
            args: Prisma.ServiceCreditCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCreditCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          findMany: {
            args: Prisma.ServiceCreditCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>[]
          }
          create: {
            args: Prisma.ServiceCreditCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          createMany: {
            args: Prisma.ServiceCreditCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreditCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>[]
          }
          delete: {
            args: Prisma.ServiceCreditCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          update: {
            args: Prisma.ServiceCreditCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCreditCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCreditCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCreditCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCreditCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCreditCostPayload>
          }
          aggregate: {
            args: Prisma.ServiceCreditCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCreditCost>
          }
          groupBy: {
            args: Prisma.ServiceCreditCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCreditCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCreditCostCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCreditCostCountAggregateOutputType> | number
          }
        }
      }
      UsageLog: {
        payload: Prisma.$UsageLogPayload<ExtArgs>
        fields: Prisma.UsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findFirst: {
            args: Prisma.UsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findMany: {
            args: Prisma.UsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          create: {
            args: Prisma.UsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          createMany: {
            args: Prisma.UsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          delete: {
            args: Prisma.UsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          update: {
            args: Prisma.UsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          deleteMany: {
            args: Prisma.UsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          upsert: {
            args: Prisma.UsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          aggregate: {
            args: Prisma.UsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageLog>
          }
          groupBy: {
            args: Prisma.UsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<UsageLogCountAggregateOutputType> | number
          }
        }
      }
      UserMonthlyBalance: {
        payload: Prisma.$UserMonthlyBalancePayload<ExtArgs>
        fields: Prisma.UserMonthlyBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMonthlyBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMonthlyBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          findFirst: {
            args: Prisma.UserMonthlyBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMonthlyBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          findMany: {
            args: Prisma.UserMonthlyBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>[]
          }
          create: {
            args: Prisma.UserMonthlyBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          createMany: {
            args: Prisma.UserMonthlyBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMonthlyBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>[]
          }
          delete: {
            args: Prisma.UserMonthlyBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          update: {
            args: Prisma.UserMonthlyBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          deleteMany: {
            args: Prisma.UserMonthlyBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMonthlyBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMonthlyBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>[]
          }
          upsert: {
            args: Prisma.UserMonthlyBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyBalancePayload>
          }
          aggregate: {
            args: Prisma.UserMonthlyBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMonthlyBalance>
          }
          groupBy: {
            args: Prisma.UserMonthlyBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMonthlyBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyBalanceCountAggregateOutputType> | number
          }
        }
      }
      UserPlan: {
        payload: Prisma.$UserPlanPayload<ExtArgs>
        fields: Prisma.UserPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          findFirst: {
            args: Prisma.UserPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          findMany: {
            args: Prisma.UserPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>[]
          }
          create: {
            args: Prisma.UserPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          createMany: {
            args: Prisma.UserPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>[]
          }
          delete: {
            args: Prisma.UserPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          update: {
            args: Prisma.UserPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          deleteMany: {
            args: Prisma.UserPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>[]
          }
          upsert: {
            args: Prisma.UserPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlanPayload>
          }
          aggregate: {
            args: Prisma.UserPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPlan>
          }
          groupBy: {
            args: Prisma.UserPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPlanCountArgs<ExtArgs>
            result: $Utils.Optional<UserPlanCountAggregateOutputType> | number
          }
        }
      }
      UserPlusAccess: {
        payload: Prisma.$UserPlusAccessPayload<ExtArgs>
        fields: Prisma.UserPlusAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPlusAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPlusAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          findFirst: {
            args: Prisma.UserPlusAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPlusAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          findMany: {
            args: Prisma.UserPlusAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>[]
          }
          create: {
            args: Prisma.UserPlusAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          createMany: {
            args: Prisma.UserPlusAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPlusAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>[]
          }
          delete: {
            args: Prisma.UserPlusAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          update: {
            args: Prisma.UserPlusAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          deleteMany: {
            args: Prisma.UserPlusAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPlusAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPlusAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>[]
          }
          upsert: {
            args: Prisma.UserPlusAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPlusAccessPayload>
          }
          aggregate: {
            args: Prisma.UserPlusAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPlusAccess>
          }
          groupBy: {
            args: Prisma.UserPlusAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPlusAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPlusAccessCountArgs<ExtArgs>
            result: $Utils.Optional<UserPlusAccessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    contentClassification?: ContentClassificationOmit
    lora?: LoraOmit
    attire?: AttireOmit
    tag?: TagOmit
    character?: CharacterOmit
    characterSticker?: CharacterStickerOmit
    characterImage?: CharacterImageOmit
    story?: StoryOmit
    assistant?: AssistantOmit
    conversation?: ConversationOmit
    userConversationMembership?: UserConversationMembershipOmit
    conversationParticipant?: ConversationParticipantOmit
    message?: MessageOmit
    favoriteCharacter?: FavoriteCharacterOmit
    contentTranslation?: ContentTranslationOmit
    conversationMemory?: ConversationMemoryOmit
    creditTransaction?: CreditTransactionOmit
    plan?: PlanOmit
    serviceCreditCost?: ServiceCreditCostOmit
    usageLog?: UsageLogOmit
    userMonthlyBalance?: UserMonthlyBalanceOmit
    userPlan?: UserPlanOmit
    userPlusAccess?: UserPlusAccessOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdCharacters: number
    stories: number
    createdAttires: number
    assistants: number
    conversations: number
    conversationParticipations: number
    ownedConversations: number
    memberships: number
    sentInvites: number
    favoriteCharacters: number
    creditTransactions: number
    usageLogs: number
    monthlyBalances: number
    userPlans: number
    plusAccessGrants: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCharacters?: boolean | UserCountOutputTypeCountCreatedCharactersArgs
    stories?: boolean | UserCountOutputTypeCountStoriesArgs
    createdAttires?: boolean | UserCountOutputTypeCountCreatedAttiresArgs
    assistants?: boolean | UserCountOutputTypeCountAssistantsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    conversationParticipations?: boolean | UserCountOutputTypeCountConversationParticipationsArgs
    ownedConversations?: boolean | UserCountOutputTypeCountOwnedConversationsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    sentInvites?: boolean | UserCountOutputTypeCountSentInvitesArgs
    favoriteCharacters?: boolean | UserCountOutputTypeCountFavoriteCharactersArgs
    creditTransactions?: boolean | UserCountOutputTypeCountCreditTransactionsArgs
    usageLogs?: boolean | UserCountOutputTypeCountUsageLogsArgs
    monthlyBalances?: boolean | UserCountOutputTypeCountMonthlyBalancesArgs
    userPlans?: boolean | UserCountOutputTypeCountUserPlansArgs
    plusAccessGrants?: boolean | UserCountOutputTypeCountPlusAccessGrantsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAttiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttireWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssistantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteCharacterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMonthlyBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyBalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlusAccessGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPlusAccessWhereInput
  }


  /**
   * Count Type LoraCountOutputType
   */

  export type LoraCountOutputType = {
    characters: number
  }

  export type LoraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | LoraCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * LoraCountOutputType without action
   */
  export type LoraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoraCountOutputType
     */
    select?: LoraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoraCountOutputType without action
   */
  export type LoraCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type AttireCountOutputType
   */

  export type AttireCountOutputType = {
    charactersUsingAsMain: number
    characters: number
  }

  export type AttireCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    charactersUsingAsMain?: boolean | AttireCountOutputTypeCountCharactersUsingAsMainArgs
    characters?: boolean | AttireCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * AttireCountOutputType without action
   */
  export type AttireCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttireCountOutputType
     */
    select?: AttireCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttireCountOutputType without action
   */
  export type AttireCountOutputTypeCountCharactersUsingAsMainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * AttireCountOutputType without action
   */
  export type AttireCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    characters: number
    stories: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | TagCountOutputTypeCountCharactersArgs
    stories?: boolean | TagCountOutputTypeCountStoriesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    stories: number
    attires: number
    tags: number
    stickers: number
    images: number
    assistantsUsingAsDefault: number
    actingParticipations: number
    representingParticipations: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stories?: boolean | CharacterCountOutputTypeCountStoriesArgs
    attires?: boolean | CharacterCountOutputTypeCountAttiresArgs
    tags?: boolean | CharacterCountOutputTypeCountTagsArgs
    stickers?: boolean | CharacterCountOutputTypeCountStickersArgs
    images?: boolean | CharacterCountOutputTypeCountImagesArgs
    assistantsUsingAsDefault?: boolean | CharacterCountOutputTypeCountAssistantsUsingAsDefaultArgs
    actingParticipations?: boolean | CharacterCountOutputTypeCountActingParticipationsArgs
    representingParticipations?: boolean | CharacterCountOutputTypeCountRepresentingParticipationsArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountAttiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttireWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountStickersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterStickerWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterImageWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountAssistantsUsingAsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssistantWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountActingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountRepresentingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    characters: number
    tags: number
    conversations: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | StoryCountOutputTypeCountCharactersArgs
    tags?: boolean | StoryCountOutputTypeCountTagsArgs
    conversations?: boolean | StoryCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type AssistantCountOutputType
   */

  export type AssistantCountOutputType = {
    participations: number
  }

  export type AssistantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participations?: boolean | AssistantCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssistantCountOutputType
     */
    select?: AssistantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssistantCountOutputType without action
   */
  export type AssistantCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
    memories: number
    members: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    memories?: boolean | ConversationCountOutputTypeCountMemoriesArgs
    members?: boolean | ConversationCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMemoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMemoryWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationMembershipWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    userPlans: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPlans?: boolean | PlanCountOutputTypeCountUserPlansArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountUserPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPlanWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    username: string | null
    email: string | null
    displayName: string | null
    fullName: string | null
    avatarUrl: string | null
    avatarSource: $Enums.AvatarSource | null
    avatarUpdatedAt: Date | null
    birthDate: Date | null
    gender: string | null
    preferredLanguage: string | null
    role: $Enums.UserRole | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    maxAgeRating: $Enums.AgeRating | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.AuthProvider | null
    providerAccountId: string | null
    username: string | null
    email: string | null
    displayName: string | null
    fullName: string | null
    avatarUrl: string | null
    avatarSource: $Enums.AvatarSource | null
    avatarUpdatedAt: Date | null
    birthDate: Date | null
    gender: string | null
    preferredLanguage: string | null
    role: $Enums.UserRole | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    maxAgeRating: $Enums.AgeRating | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    provider: number
    providerAccountId: number
    username: number
    email: number
    displayName: number
    fullName: number
    avatarUrl: number
    avatarSource: number
    avatarUpdatedAt: number
    birthDate: number
    gender: number
    preferredLanguage: number
    role: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    maxAgeRating: number
    blockedTags: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    username?: true
    email?: true
    displayName?: true
    fullName?: true
    avatarUrl?: true
    avatarSource?: true
    avatarUpdatedAt?: true
    birthDate?: true
    gender?: true
    preferredLanguage?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    maxAgeRating?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    username?: true
    email?: true
    displayName?: true
    fullName?: true
    avatarUrl?: true
    avatarSource?: true
    avatarUpdatedAt?: true
    birthDate?: true
    gender?: true
    preferredLanguage?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    maxAgeRating?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    username?: true
    email?: true
    displayName?: true
    fullName?: true
    avatarUrl?: true
    avatarSource?: true
    avatarUpdatedAt?: true
    birthDate?: true
    gender?: true
    preferredLanguage?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    maxAgeRating?: true
    blockedTags?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username: string | null
    email: string | null
    displayName: string | null
    fullName: string | null
    avatarUrl: string | null
    avatarSource: $Enums.AvatarSource
    avatarUpdatedAt: Date | null
    birthDate: Date | null
    gender: string | null
    preferredLanguage: string | null
    role: $Enums.UserRole
    lastLoginAt: Date
    createdAt: Date
    updatedAt: Date
    maxAgeRating: $Enums.AgeRating
    blockedTags: $Enums.ContentTag[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    username?: boolean
    email?: boolean
    displayName?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    avatarSource?: boolean
    avatarUpdatedAt?: boolean
    birthDate?: boolean
    gender?: boolean
    preferredLanguage?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxAgeRating?: boolean
    blockedTags?: boolean
    createdCharacters?: boolean | User$createdCharactersArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    createdAttires?: boolean | User$createdAttiresArgs<ExtArgs>
    assistants?: boolean | User$assistantsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    conversationParticipations?: boolean | User$conversationParticipationsArgs<ExtArgs>
    ownedConversations?: boolean | User$ownedConversationsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    favoriteCharacters?: boolean | User$favoriteCharactersArgs<ExtArgs>
    creditTransactions?: boolean | User$creditTransactionsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    monthlyBalances?: boolean | User$monthlyBalancesArgs<ExtArgs>
    userPlans?: boolean | User$userPlansArgs<ExtArgs>
    plusAccessGrants?: boolean | User$plusAccessGrantsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    username?: boolean
    email?: boolean
    displayName?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    avatarSource?: boolean
    avatarUpdatedAt?: boolean
    birthDate?: boolean
    gender?: boolean
    preferredLanguage?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxAgeRating?: boolean
    blockedTags?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    username?: boolean
    email?: boolean
    displayName?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    avatarSource?: boolean
    avatarUpdatedAt?: boolean
    birthDate?: boolean
    gender?: boolean
    preferredLanguage?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxAgeRating?: boolean
    blockedTags?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    username?: boolean
    email?: boolean
    displayName?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    avatarSource?: boolean
    avatarUpdatedAt?: boolean
    birthDate?: boolean
    gender?: boolean
    preferredLanguage?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maxAgeRating?: boolean
    blockedTags?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "providerAccountId" | "username" | "email" | "displayName" | "fullName" | "avatarUrl" | "avatarSource" | "avatarUpdatedAt" | "birthDate" | "gender" | "preferredLanguage" | "role" | "lastLoginAt" | "createdAt" | "updatedAt" | "maxAgeRating" | "blockedTags", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCharacters?: boolean | User$createdCharactersArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    createdAttires?: boolean | User$createdAttiresArgs<ExtArgs>
    assistants?: boolean | User$assistantsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    conversationParticipations?: boolean | User$conversationParticipationsArgs<ExtArgs>
    ownedConversations?: boolean | User$ownedConversationsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    favoriteCharacters?: boolean | User$favoriteCharactersArgs<ExtArgs>
    creditTransactions?: boolean | User$creditTransactionsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    monthlyBalances?: boolean | User$monthlyBalancesArgs<ExtArgs>
    userPlans?: boolean | User$userPlansArgs<ExtArgs>
    plusAccessGrants?: boolean | User$plusAccessGrantsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdCharacters: Prisma.$CharacterPayload<ExtArgs>[]
      stories: Prisma.$StoryPayload<ExtArgs>[]
      createdAttires: Prisma.$AttirePayload<ExtArgs>[]
      assistants: Prisma.$AssistantPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      conversationParticipations: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      ownedConversations: Prisma.$ConversationPayload<ExtArgs>[]
      memberships: Prisma.$UserConversationMembershipPayload<ExtArgs>[]
      sentInvites: Prisma.$UserConversationMembershipPayload<ExtArgs>[]
      favoriteCharacters: Prisma.$FavoriteCharacterPayload<ExtArgs>[]
      creditTransactions: Prisma.$CreditTransactionPayload<ExtArgs>[]
      usageLogs: Prisma.$UsageLogPayload<ExtArgs>[]
      monthlyBalances: Prisma.$UserMonthlyBalancePayload<ExtArgs>[]
      userPlans: Prisma.$UserPlanPayload<ExtArgs>[]
      plusAccessGrants: Prisma.$UserPlusAccessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.AuthProvider
      providerAccountId: string
      username: string | null
      email: string | null
      displayName: string | null
      fullName: string | null
      avatarUrl: string | null
      avatarSource: $Enums.AvatarSource
      avatarUpdatedAt: Date | null
      birthDate: Date | null
      gender: string | null
      preferredLanguage: string | null
      role: $Enums.UserRole
      lastLoginAt: Date
      createdAt: Date
      updatedAt: Date
      maxAgeRating: $Enums.AgeRating
      blockedTags: $Enums.ContentTag[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdCharacters<T extends User$createdCharactersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends User$storiesArgs<ExtArgs> = {}>(args?: Subset<T, User$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAttires<T extends User$createdAttiresArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAttiresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assistants<T extends User$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, User$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationParticipations<T extends User$conversationParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedConversations<T extends User$ownedConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvites<T extends User$sentInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteCharacters<T extends User$favoriteCharactersArgs<ExtArgs> = {}>(args?: Subset<T, User$favoriteCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditTransactions<T extends User$creditTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$creditTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends User$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthlyBalances<T extends User$monthlyBalancesArgs<ExtArgs> = {}>(args?: Subset<T, User$monthlyBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPlans<T extends User$userPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$userPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plusAccessGrants<T extends User$plusAccessGrantsArgs<ExtArgs> = {}>(args?: Subset<T, User$plusAccessGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly provider: FieldRef<"User", 'AuthProvider'>
    readonly providerAccountId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly avatarSource: FieldRef<"User", 'AvatarSource'>
    readonly avatarUpdatedAt: FieldRef<"User", 'DateTime'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly maxAgeRating: FieldRef<"User", 'AgeRating'>
    readonly blockedTags: FieldRef<"User", 'ContentTag[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdCharacters
   */
  export type User$createdCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * User.stories
   */
  export type User$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * User.createdAttires
   */
  export type User$createdAttiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    where?: AttireWhereInput
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    cursor?: AttireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttireScalarFieldEnum | AttireScalarFieldEnum[]
  }

  /**
   * User.assistants
   */
  export type User$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    where?: AssistantWhereInput
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    cursor?: AssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.conversationParticipations
   */
  export type User$conversationParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * User.ownedConversations
   */
  export type User$ownedConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    where?: UserConversationMembershipWhereInput
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    cursor?: UserConversationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * User.sentInvites
   */
  export type User$sentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    where?: UserConversationMembershipWhereInput
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    cursor?: UserConversationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * User.favoriteCharacters
   */
  export type User$favoriteCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    where?: FavoriteCharacterWhereInput
    orderBy?: FavoriteCharacterOrderByWithRelationInput | FavoriteCharacterOrderByWithRelationInput[]
    cursor?: FavoriteCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteCharacterScalarFieldEnum | FavoriteCharacterScalarFieldEnum[]
  }

  /**
   * User.creditTransactions
   */
  export type User$creditTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    where?: CreditTransactionWhereInput
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    cursor?: CreditTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * User.usageLogs
   */
  export type User$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    cursor?: UsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * User.monthlyBalances
   */
  export type User$monthlyBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    where?: UserMonthlyBalanceWhereInput
    orderBy?: UserMonthlyBalanceOrderByWithRelationInput | UserMonthlyBalanceOrderByWithRelationInput[]
    cursor?: UserMonthlyBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMonthlyBalanceScalarFieldEnum | UserMonthlyBalanceScalarFieldEnum[]
  }

  /**
   * User.userPlans
   */
  export type User$userPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    where?: UserPlanWhereInput
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    cursor?: UserPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPlanScalarFieldEnum | UserPlanScalarFieldEnum[]
  }

  /**
   * User.plusAccessGrants
   */
  export type User$plusAccessGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    where?: UserPlusAccessWhereInput
    orderBy?: UserPlusAccessOrderByWithRelationInput | UserPlusAccessOrderByWithRelationInput[]
    cursor?: UserPlusAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPlusAccessScalarFieldEnum | UserPlusAccessScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ContentClassification
   */

  export type AggregateContentClassification = {
    _count: ContentClassificationCountAggregateOutputType | null
    _min: ContentClassificationMinAggregateOutputType | null
    _max: ContentClassificationMaxAggregateOutputType | null
  }

  export type ContentClassificationMinAggregateOutputType = {
    id: string | null
    ageRating: $Enums.AgeRating | null
    reason: string | null
    contentType: string | null
    contentId: string | null
    autoClassified: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentClassificationMaxAggregateOutputType = {
    id: string | null
    ageRating: $Enums.AgeRating | null
    reason: string | null
    contentType: string | null
    contentId: string | null
    autoClassified: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentClassificationCountAggregateOutputType = {
    id: number
    ageRating: number
    contentTags: number
    reason: number
    contentType: number
    contentId: number
    autoClassified: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentClassificationMinAggregateInputType = {
    id?: true
    ageRating?: true
    reason?: true
    contentType?: true
    contentId?: true
    autoClassified?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentClassificationMaxAggregateInputType = {
    id?: true
    ageRating?: true
    reason?: true
    contentType?: true
    contentId?: true
    autoClassified?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentClassificationCountAggregateInputType = {
    id?: true
    ageRating?: true
    contentTags?: true
    reason?: true
    contentType?: true
    contentId?: true
    autoClassified?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentClassification to aggregate.
     */
    where?: ContentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentClassifications to fetch.
     */
    orderBy?: ContentClassificationOrderByWithRelationInput | ContentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentClassifications
    **/
    _count?: true | ContentClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentClassificationMaxAggregateInputType
  }

  export type GetContentClassificationAggregateType<T extends ContentClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateContentClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentClassification[P]>
      : GetScalarType<T[P], AggregateContentClassification[P]>
  }




  export type ContentClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentClassificationWhereInput
    orderBy?: ContentClassificationOrderByWithAggregationInput | ContentClassificationOrderByWithAggregationInput[]
    by: ContentClassificationScalarFieldEnum[] | ContentClassificationScalarFieldEnum
    having?: ContentClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentClassificationCountAggregateInputType | true
    _min?: ContentClassificationMinAggregateInputType
    _max?: ContentClassificationMaxAggregateInputType
  }

  export type ContentClassificationGroupByOutputType = {
    id: string
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    reason: string | null
    contentType: string
    contentId: string
    autoClassified: boolean
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContentClassificationCountAggregateOutputType | null
    _min: ContentClassificationMinAggregateOutputType | null
    _max: ContentClassificationMaxAggregateOutputType | null
  }

  type GetContentClassificationGroupByPayload<T extends ContentClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], ContentClassificationGroupByOutputType[P]>
        }
      >
    >


  export type ContentClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ageRating?: boolean
    contentTags?: boolean
    reason?: boolean
    contentType?: boolean
    contentId?: boolean
    autoClassified?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentClassification"]>

  export type ContentClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ageRating?: boolean
    contentTags?: boolean
    reason?: boolean
    contentType?: boolean
    contentId?: boolean
    autoClassified?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentClassification"]>

  export type ContentClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ageRating?: boolean
    contentTags?: boolean
    reason?: boolean
    contentType?: boolean
    contentId?: boolean
    autoClassified?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentClassification"]>

  export type ContentClassificationSelectScalar = {
    id?: boolean
    ageRating?: boolean
    contentTags?: boolean
    reason?: boolean
    contentType?: boolean
    contentId?: boolean
    autoClassified?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ageRating" | "contentTags" | "reason" | "contentType" | "contentId" | "autoClassified" | "reviewedBy" | "reviewedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["contentClassification"]>

  export type $ContentClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentClassification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      reason: string | null
      contentType: string
      contentId: string
      autoClassified: boolean
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentClassification"]>
    composites: {}
  }

  type ContentClassificationGetPayload<S extends boolean | null | undefined | ContentClassificationDefaultArgs> = $Result.GetResult<Prisma.$ContentClassificationPayload, S>

  type ContentClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentClassificationCountAggregateInputType | true
    }

  export interface ContentClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentClassification'], meta: { name: 'ContentClassification' } }
    /**
     * Find zero or one ContentClassification that matches the filter.
     * @param {ContentClassificationFindUniqueArgs} args - Arguments to find a ContentClassification
     * @example
     * // Get one ContentClassification
     * const contentClassification = await prisma.contentClassification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentClassificationFindUniqueArgs>(args: SelectSubset<T, ContentClassificationFindUniqueArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentClassification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentClassificationFindUniqueOrThrowArgs} args - Arguments to find a ContentClassification
     * @example
     * // Get one ContentClassification
     * const contentClassification = await prisma.contentClassification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentClassification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationFindFirstArgs} args - Arguments to find a ContentClassification
     * @example
     * // Get one ContentClassification
     * const contentClassification = await prisma.contentClassification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentClassificationFindFirstArgs>(args?: SelectSubset<T, ContentClassificationFindFirstArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentClassification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationFindFirstOrThrowArgs} args - Arguments to find a ContentClassification
     * @example
     * // Get one ContentClassification
     * const contentClassification = await prisma.contentClassification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentClassifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentClassifications
     * const contentClassifications = await prisma.contentClassification.findMany()
     * 
     * // Get first 10 ContentClassifications
     * const contentClassifications = await prisma.contentClassification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentClassificationWithIdOnly = await prisma.contentClassification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentClassificationFindManyArgs>(args?: SelectSubset<T, ContentClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentClassification.
     * @param {ContentClassificationCreateArgs} args - Arguments to create a ContentClassification.
     * @example
     * // Create one ContentClassification
     * const ContentClassification = await prisma.contentClassification.create({
     *   data: {
     *     // ... data to create a ContentClassification
     *   }
     * })
     * 
     */
    create<T extends ContentClassificationCreateArgs>(args: SelectSubset<T, ContentClassificationCreateArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentClassifications.
     * @param {ContentClassificationCreateManyArgs} args - Arguments to create many ContentClassifications.
     * @example
     * // Create many ContentClassifications
     * const contentClassification = await prisma.contentClassification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentClassificationCreateManyArgs>(args?: SelectSubset<T, ContentClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentClassifications and returns the data saved in the database.
     * @param {ContentClassificationCreateManyAndReturnArgs} args - Arguments to create many ContentClassifications.
     * @example
     * // Create many ContentClassifications
     * const contentClassification = await prisma.contentClassification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentClassifications and only return the `id`
     * const contentClassificationWithIdOnly = await prisma.contentClassification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentClassification.
     * @param {ContentClassificationDeleteArgs} args - Arguments to delete one ContentClassification.
     * @example
     * // Delete one ContentClassification
     * const ContentClassification = await prisma.contentClassification.delete({
     *   where: {
     *     // ... filter to delete one ContentClassification
     *   }
     * })
     * 
     */
    delete<T extends ContentClassificationDeleteArgs>(args: SelectSubset<T, ContentClassificationDeleteArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentClassification.
     * @param {ContentClassificationUpdateArgs} args - Arguments to update one ContentClassification.
     * @example
     * // Update one ContentClassification
     * const contentClassification = await prisma.contentClassification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentClassificationUpdateArgs>(args: SelectSubset<T, ContentClassificationUpdateArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentClassifications.
     * @param {ContentClassificationDeleteManyArgs} args - Arguments to filter ContentClassifications to delete.
     * @example
     * // Delete a few ContentClassifications
     * const { count } = await prisma.contentClassification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentClassificationDeleteManyArgs>(args?: SelectSubset<T, ContentClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentClassifications
     * const contentClassification = await prisma.contentClassification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentClassificationUpdateManyArgs>(args: SelectSubset<T, ContentClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentClassifications and returns the data updated in the database.
     * @param {ContentClassificationUpdateManyAndReturnArgs} args - Arguments to update many ContentClassifications.
     * @example
     * // Update many ContentClassifications
     * const contentClassification = await prisma.contentClassification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentClassifications and only return the `id`
     * const contentClassificationWithIdOnly = await prisma.contentClassification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentClassification.
     * @param {ContentClassificationUpsertArgs} args - Arguments to update or create a ContentClassification.
     * @example
     * // Update or create a ContentClassification
     * const contentClassification = await prisma.contentClassification.upsert({
     *   create: {
     *     // ... data to create a ContentClassification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentClassification we want to update
     *   }
     * })
     */
    upsert<T extends ContentClassificationUpsertArgs>(args: SelectSubset<T, ContentClassificationUpsertArgs<ExtArgs>>): Prisma__ContentClassificationClient<$Result.GetResult<Prisma.$ContentClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentClassifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationCountArgs} args - Arguments to filter ContentClassifications to count.
     * @example
     * // Count the number of ContentClassifications
     * const count = await prisma.contentClassification.count({
     *   where: {
     *     // ... the filter for the ContentClassifications we want to count
     *   }
     * })
    **/
    count<T extends ContentClassificationCountArgs>(
      args?: Subset<T, ContentClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentClassificationAggregateArgs>(args: Subset<T, ContentClassificationAggregateArgs>): Prisma.PrismaPromise<GetContentClassificationAggregateType<T>>

    /**
     * Group by ContentClassification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentClassificationGroupByArgs['orderBy'] }
        : { orderBy?: ContentClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentClassification model
   */
  readonly fields: ContentClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentClassification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentClassification model
   */
  interface ContentClassificationFieldRefs {
    readonly id: FieldRef<"ContentClassification", 'String'>
    readonly ageRating: FieldRef<"ContentClassification", 'AgeRating'>
    readonly contentTags: FieldRef<"ContentClassification", 'ContentTag[]'>
    readonly reason: FieldRef<"ContentClassification", 'String'>
    readonly contentType: FieldRef<"ContentClassification", 'String'>
    readonly contentId: FieldRef<"ContentClassification", 'String'>
    readonly autoClassified: FieldRef<"ContentClassification", 'Boolean'>
    readonly reviewedBy: FieldRef<"ContentClassification", 'String'>
    readonly reviewedAt: FieldRef<"ContentClassification", 'DateTime'>
    readonly createdAt: FieldRef<"ContentClassification", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentClassification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentClassification findUnique
   */
  export type ContentClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter, which ContentClassification to fetch.
     */
    where: ContentClassificationWhereUniqueInput
  }

  /**
   * ContentClassification findUniqueOrThrow
   */
  export type ContentClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter, which ContentClassification to fetch.
     */
    where: ContentClassificationWhereUniqueInput
  }

  /**
   * ContentClassification findFirst
   */
  export type ContentClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter, which ContentClassification to fetch.
     */
    where?: ContentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentClassifications to fetch.
     */
    orderBy?: ContentClassificationOrderByWithRelationInput | ContentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentClassifications.
     */
    cursor?: ContentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentClassifications.
     */
    distinct?: ContentClassificationScalarFieldEnum | ContentClassificationScalarFieldEnum[]
  }

  /**
   * ContentClassification findFirstOrThrow
   */
  export type ContentClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter, which ContentClassification to fetch.
     */
    where?: ContentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentClassifications to fetch.
     */
    orderBy?: ContentClassificationOrderByWithRelationInput | ContentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentClassifications.
     */
    cursor?: ContentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentClassifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentClassifications.
     */
    distinct?: ContentClassificationScalarFieldEnum | ContentClassificationScalarFieldEnum[]
  }

  /**
   * ContentClassification findMany
   */
  export type ContentClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter, which ContentClassifications to fetch.
     */
    where?: ContentClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentClassifications to fetch.
     */
    orderBy?: ContentClassificationOrderByWithRelationInput | ContentClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentClassifications.
     */
    cursor?: ContentClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentClassifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentClassifications.
     */
    skip?: number
    distinct?: ContentClassificationScalarFieldEnum | ContentClassificationScalarFieldEnum[]
  }

  /**
   * ContentClassification create
   */
  export type ContentClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * The data needed to create a ContentClassification.
     */
    data: XOR<ContentClassificationCreateInput, ContentClassificationUncheckedCreateInput>
  }

  /**
   * ContentClassification createMany
   */
  export type ContentClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentClassifications.
     */
    data: ContentClassificationCreateManyInput | ContentClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentClassification createManyAndReturn
   */
  export type ContentClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many ContentClassifications.
     */
    data: ContentClassificationCreateManyInput | ContentClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentClassification update
   */
  export type ContentClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * The data needed to update a ContentClassification.
     */
    data: XOR<ContentClassificationUpdateInput, ContentClassificationUncheckedUpdateInput>
    /**
     * Choose, which ContentClassification to update.
     */
    where: ContentClassificationWhereUniqueInput
  }

  /**
   * ContentClassification updateMany
   */
  export type ContentClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentClassifications.
     */
    data: XOR<ContentClassificationUpdateManyMutationInput, ContentClassificationUncheckedUpdateManyInput>
    /**
     * Filter which ContentClassifications to update
     */
    where?: ContentClassificationWhereInput
    /**
     * Limit how many ContentClassifications to update.
     */
    limit?: number
  }

  /**
   * ContentClassification updateManyAndReturn
   */
  export type ContentClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * The data used to update ContentClassifications.
     */
    data: XOR<ContentClassificationUpdateManyMutationInput, ContentClassificationUncheckedUpdateManyInput>
    /**
     * Filter which ContentClassifications to update
     */
    where?: ContentClassificationWhereInput
    /**
     * Limit how many ContentClassifications to update.
     */
    limit?: number
  }

  /**
   * ContentClassification upsert
   */
  export type ContentClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * The filter to search for the ContentClassification to update in case it exists.
     */
    where: ContentClassificationWhereUniqueInput
    /**
     * In case the ContentClassification found by the `where` argument doesn't exist, create a new ContentClassification with this data.
     */
    create: XOR<ContentClassificationCreateInput, ContentClassificationUncheckedCreateInput>
    /**
     * In case the ContentClassification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentClassificationUpdateInput, ContentClassificationUncheckedUpdateInput>
  }

  /**
   * ContentClassification delete
   */
  export type ContentClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
    /**
     * Filter which ContentClassification to delete.
     */
    where: ContentClassificationWhereUniqueInput
  }

  /**
   * ContentClassification deleteMany
   */
  export type ContentClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentClassifications to delete
     */
    where?: ContentClassificationWhereInput
    /**
     * Limit how many ContentClassifications to delete.
     */
    limit?: number
  }

  /**
   * ContentClassification without action
   */
  export type ContentClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentClassification
     */
    select?: ContentClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentClassification
     */
    omit?: ContentClassificationOmit<ExtArgs> | null
  }


  /**
   * Model Lora
   */

  export type AggregateLora = {
    _count: LoraCountAggregateOutputType | null
    _avg: LoraAvgAggregateOutputType | null
    _sum: LoraSumAggregateOutputType | null
    _min: LoraMinAggregateOutputType | null
    _max: LoraMaxAggregateOutputType | null
  }

  export type LoraAvgAggregateOutputType = {
    downloadCount: number | null
  }

  export type LoraSumAggregateOutputType = {
    downloadCount: number | null
  }

  export type LoraMinAggregateOutputType = {
    id: string | null
    civitaiModelId: string | null
    civitaiVersionId: string | null
    name: string | null
    modelType: string | null
    baseModel: string | null
    downloadCount: number | null
    modelUrl: string | null
    nsfw: boolean | null
    filename: string | null
    filepathRelative: string | null
    firstImageUrl: string | null
    category: string | null
    term: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoraMaxAggregateOutputType = {
    id: string | null
    civitaiModelId: string | null
    civitaiVersionId: string | null
    name: string | null
    modelType: string | null
    baseModel: string | null
    downloadCount: number | null
    modelUrl: string | null
    nsfw: boolean | null
    filename: string | null
    filepathRelative: string | null
    firstImageUrl: string | null
    category: string | null
    term: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoraCountAggregateOutputType = {
    id: number
    civitaiModelId: number
    civitaiVersionId: number
    name: number
    modelType: number
    baseModel: number
    downloadCount: number
    modelUrl: number
    tags: number
    trainedWords: number
    nsfw: number
    filename: number
    filepathRelative: number
    firstImageUrl: number
    imageUrls: number
    category: number
    term: number
    deleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoraAvgAggregateInputType = {
    downloadCount?: true
  }

  export type LoraSumAggregateInputType = {
    downloadCount?: true
  }

  export type LoraMinAggregateInputType = {
    id?: true
    civitaiModelId?: true
    civitaiVersionId?: true
    name?: true
    modelType?: true
    baseModel?: true
    downloadCount?: true
    modelUrl?: true
    nsfw?: true
    filename?: true
    filepathRelative?: true
    firstImageUrl?: true
    category?: true
    term?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoraMaxAggregateInputType = {
    id?: true
    civitaiModelId?: true
    civitaiVersionId?: true
    name?: true
    modelType?: true
    baseModel?: true
    downloadCount?: true
    modelUrl?: true
    nsfw?: true
    filename?: true
    filepathRelative?: true
    firstImageUrl?: true
    category?: true
    term?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoraCountAggregateInputType = {
    id?: true
    civitaiModelId?: true
    civitaiVersionId?: true
    name?: true
    modelType?: true
    baseModel?: true
    downloadCount?: true
    modelUrl?: true
    tags?: true
    trainedWords?: true
    nsfw?: true
    filename?: true
    filepathRelative?: true
    firstImageUrl?: true
    imageUrls?: true
    category?: true
    term?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lora to aggregate.
     */
    where?: LoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loras to fetch.
     */
    orderBy?: LoraOrderByWithRelationInput | LoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loras
    **/
    _count?: true | LoraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoraMaxAggregateInputType
  }

  export type GetLoraAggregateType<T extends LoraAggregateArgs> = {
        [P in keyof T & keyof AggregateLora]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLora[P]>
      : GetScalarType<T[P], AggregateLora[P]>
  }




  export type LoraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoraWhereInput
    orderBy?: LoraOrderByWithAggregationInput | LoraOrderByWithAggregationInput[]
    by: LoraScalarFieldEnum[] | LoraScalarFieldEnum
    having?: LoraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoraCountAggregateInputType | true
    _avg?: LoraAvgAggregateInputType
    _sum?: LoraSumAggregateInputType
    _min?: LoraMinAggregateInputType
    _max?: LoraMaxAggregateInputType
  }

  export type LoraGroupByOutputType = {
    id: string
    civitaiModelId: string | null
    civitaiVersionId: string | null
    name: string
    modelType: string | null
    baseModel: string | null
    downloadCount: number | null
    modelUrl: string | null
    tags: string[]
    trainedWords: string[]
    nsfw: boolean
    filename: string | null
    filepathRelative: string | null
    firstImageUrl: string | null
    imageUrls: string[]
    category: string | null
    term: string | null
    deleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: LoraCountAggregateOutputType | null
    _avg: LoraAvgAggregateOutputType | null
    _sum: LoraSumAggregateOutputType | null
    _min: LoraMinAggregateOutputType | null
    _max: LoraMaxAggregateOutputType | null
  }

  type GetLoraGroupByPayload<T extends LoraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoraGroupByOutputType[P]>
            : GetScalarType<T[P], LoraGroupByOutputType[P]>
        }
      >
    >


  export type LoraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    civitaiModelId?: boolean
    civitaiVersionId?: boolean
    name?: boolean
    modelType?: boolean
    baseModel?: boolean
    downloadCount?: boolean
    modelUrl?: boolean
    tags?: boolean
    trainedWords?: boolean
    nsfw?: boolean
    filename?: boolean
    filepathRelative?: boolean
    firstImageUrl?: boolean
    imageUrls?: boolean
    category?: boolean
    term?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characters?: boolean | Lora$charactersArgs<ExtArgs>
    _count?: boolean | LoraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lora"]>

  export type LoraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    civitaiModelId?: boolean
    civitaiVersionId?: boolean
    name?: boolean
    modelType?: boolean
    baseModel?: boolean
    downloadCount?: boolean
    modelUrl?: boolean
    tags?: boolean
    trainedWords?: boolean
    nsfw?: boolean
    filename?: boolean
    filepathRelative?: boolean
    firstImageUrl?: boolean
    imageUrls?: boolean
    category?: boolean
    term?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lora"]>

  export type LoraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    civitaiModelId?: boolean
    civitaiVersionId?: boolean
    name?: boolean
    modelType?: boolean
    baseModel?: boolean
    downloadCount?: boolean
    modelUrl?: boolean
    tags?: boolean
    trainedWords?: boolean
    nsfw?: boolean
    filename?: boolean
    filepathRelative?: boolean
    firstImageUrl?: boolean
    imageUrls?: boolean
    category?: boolean
    term?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lora"]>

  export type LoraSelectScalar = {
    id?: boolean
    civitaiModelId?: boolean
    civitaiVersionId?: boolean
    name?: boolean
    modelType?: boolean
    baseModel?: boolean
    downloadCount?: boolean
    modelUrl?: boolean
    tags?: boolean
    trainedWords?: boolean
    nsfw?: boolean
    filename?: boolean
    filepathRelative?: boolean
    firstImageUrl?: boolean
    imageUrls?: boolean
    category?: boolean
    term?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "civitaiModelId" | "civitaiVersionId" | "name" | "modelType" | "baseModel" | "downloadCount" | "modelUrl" | "tags" | "trainedWords" | "nsfw" | "filename" | "filepathRelative" | "firstImageUrl" | "imageUrls" | "category" | "term" | "deleted" | "createdAt" | "updatedAt", ExtArgs["result"]["lora"]>
  export type LoraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | Lora$charactersArgs<ExtArgs>
    _count?: boolean | LoraCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LoraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LoraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lora"
    objects: {
      characters: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      civitaiModelId: string | null
      civitaiVersionId: string | null
      name: string
      modelType: string | null
      baseModel: string | null
      downloadCount: number | null
      modelUrl: string | null
      tags: string[]
      trainedWords: string[]
      nsfw: boolean
      filename: string | null
      filepathRelative: string | null
      firstImageUrl: string | null
      imageUrls: string[]
      category: string | null
      term: string | null
      deleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lora"]>
    composites: {}
  }

  type LoraGetPayload<S extends boolean | null | undefined | LoraDefaultArgs> = $Result.GetResult<Prisma.$LoraPayload, S>

  type LoraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoraCountAggregateInputType | true
    }

  export interface LoraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lora'], meta: { name: 'Lora' } }
    /**
     * Find zero or one Lora that matches the filter.
     * @param {LoraFindUniqueArgs} args - Arguments to find a Lora
     * @example
     * // Get one Lora
     * const lora = await prisma.lora.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoraFindUniqueArgs>(args: SelectSubset<T, LoraFindUniqueArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lora that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoraFindUniqueOrThrowArgs} args - Arguments to find a Lora
     * @example
     * // Get one Lora
     * const lora = await prisma.lora.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoraFindUniqueOrThrowArgs>(args: SelectSubset<T, LoraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lora that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraFindFirstArgs} args - Arguments to find a Lora
     * @example
     * // Get one Lora
     * const lora = await prisma.lora.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoraFindFirstArgs>(args?: SelectSubset<T, LoraFindFirstArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lora that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraFindFirstOrThrowArgs} args - Arguments to find a Lora
     * @example
     * // Get one Lora
     * const lora = await prisma.lora.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoraFindFirstOrThrowArgs>(args?: SelectSubset<T, LoraFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loras
     * const loras = await prisma.lora.findMany()
     * 
     * // Get first 10 Loras
     * const loras = await prisma.lora.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loraWithIdOnly = await prisma.lora.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoraFindManyArgs>(args?: SelectSubset<T, LoraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lora.
     * @param {LoraCreateArgs} args - Arguments to create a Lora.
     * @example
     * // Create one Lora
     * const Lora = await prisma.lora.create({
     *   data: {
     *     // ... data to create a Lora
     *   }
     * })
     * 
     */
    create<T extends LoraCreateArgs>(args: SelectSubset<T, LoraCreateArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loras.
     * @param {LoraCreateManyArgs} args - Arguments to create many Loras.
     * @example
     * // Create many Loras
     * const lora = await prisma.lora.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoraCreateManyArgs>(args?: SelectSubset<T, LoraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loras and returns the data saved in the database.
     * @param {LoraCreateManyAndReturnArgs} args - Arguments to create many Loras.
     * @example
     * // Create many Loras
     * const lora = await prisma.lora.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loras and only return the `id`
     * const loraWithIdOnly = await prisma.lora.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoraCreateManyAndReturnArgs>(args?: SelectSubset<T, LoraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lora.
     * @param {LoraDeleteArgs} args - Arguments to delete one Lora.
     * @example
     * // Delete one Lora
     * const Lora = await prisma.lora.delete({
     *   where: {
     *     // ... filter to delete one Lora
     *   }
     * })
     * 
     */
    delete<T extends LoraDeleteArgs>(args: SelectSubset<T, LoraDeleteArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lora.
     * @param {LoraUpdateArgs} args - Arguments to update one Lora.
     * @example
     * // Update one Lora
     * const lora = await prisma.lora.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoraUpdateArgs>(args: SelectSubset<T, LoraUpdateArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loras.
     * @param {LoraDeleteManyArgs} args - Arguments to filter Loras to delete.
     * @example
     * // Delete a few Loras
     * const { count } = await prisma.lora.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoraDeleteManyArgs>(args?: SelectSubset<T, LoraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loras
     * const lora = await prisma.lora.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoraUpdateManyArgs>(args: SelectSubset<T, LoraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loras and returns the data updated in the database.
     * @param {LoraUpdateManyAndReturnArgs} args - Arguments to update many Loras.
     * @example
     * // Update many Loras
     * const lora = await prisma.lora.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loras and only return the `id`
     * const loraWithIdOnly = await prisma.lora.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoraUpdateManyAndReturnArgs>(args: SelectSubset<T, LoraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lora.
     * @param {LoraUpsertArgs} args - Arguments to update or create a Lora.
     * @example
     * // Update or create a Lora
     * const lora = await prisma.lora.upsert({
     *   create: {
     *     // ... data to create a Lora
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lora we want to update
     *   }
     * })
     */
    upsert<T extends LoraUpsertArgs>(args: SelectSubset<T, LoraUpsertArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraCountArgs} args - Arguments to filter Loras to count.
     * @example
     * // Count the number of Loras
     * const count = await prisma.lora.count({
     *   where: {
     *     // ... the filter for the Loras we want to count
     *   }
     * })
    **/
    count<T extends LoraCountArgs>(
      args?: Subset<T, LoraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoraAggregateArgs>(args: Subset<T, LoraAggregateArgs>): Prisma.PrismaPromise<GetLoraAggregateType<T>>

    /**
     * Group by Lora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoraGroupByArgs['orderBy'] }
        : { orderBy?: LoraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lora model
   */
  readonly fields: LoraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lora.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends Lora$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Lora$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lora model
   */
  interface LoraFieldRefs {
    readonly id: FieldRef<"Lora", 'String'>
    readonly civitaiModelId: FieldRef<"Lora", 'String'>
    readonly civitaiVersionId: FieldRef<"Lora", 'String'>
    readonly name: FieldRef<"Lora", 'String'>
    readonly modelType: FieldRef<"Lora", 'String'>
    readonly baseModel: FieldRef<"Lora", 'String'>
    readonly downloadCount: FieldRef<"Lora", 'Int'>
    readonly modelUrl: FieldRef<"Lora", 'String'>
    readonly tags: FieldRef<"Lora", 'String[]'>
    readonly trainedWords: FieldRef<"Lora", 'String[]'>
    readonly nsfw: FieldRef<"Lora", 'Boolean'>
    readonly filename: FieldRef<"Lora", 'String'>
    readonly filepathRelative: FieldRef<"Lora", 'String'>
    readonly firstImageUrl: FieldRef<"Lora", 'String'>
    readonly imageUrls: FieldRef<"Lora", 'String[]'>
    readonly category: FieldRef<"Lora", 'String'>
    readonly term: FieldRef<"Lora", 'String'>
    readonly deleted: FieldRef<"Lora", 'Boolean'>
    readonly createdAt: FieldRef<"Lora", 'DateTime'>
    readonly updatedAt: FieldRef<"Lora", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lora findUnique
   */
  export type LoraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter, which Lora to fetch.
     */
    where: LoraWhereUniqueInput
  }

  /**
   * Lora findUniqueOrThrow
   */
  export type LoraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter, which Lora to fetch.
     */
    where: LoraWhereUniqueInput
  }

  /**
   * Lora findFirst
   */
  export type LoraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter, which Lora to fetch.
     */
    where?: LoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loras to fetch.
     */
    orderBy?: LoraOrderByWithRelationInput | LoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loras.
     */
    cursor?: LoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loras.
     */
    distinct?: LoraScalarFieldEnum | LoraScalarFieldEnum[]
  }

  /**
   * Lora findFirstOrThrow
   */
  export type LoraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter, which Lora to fetch.
     */
    where?: LoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loras to fetch.
     */
    orderBy?: LoraOrderByWithRelationInput | LoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loras.
     */
    cursor?: LoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loras.
     */
    distinct?: LoraScalarFieldEnum | LoraScalarFieldEnum[]
  }

  /**
   * Lora findMany
   */
  export type LoraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter, which Loras to fetch.
     */
    where?: LoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loras to fetch.
     */
    orderBy?: LoraOrderByWithRelationInput | LoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loras.
     */
    cursor?: LoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loras.
     */
    skip?: number
    distinct?: LoraScalarFieldEnum | LoraScalarFieldEnum[]
  }

  /**
   * Lora create
   */
  export type LoraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * The data needed to create a Lora.
     */
    data: XOR<LoraCreateInput, LoraUncheckedCreateInput>
  }

  /**
   * Lora createMany
   */
  export type LoraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loras.
     */
    data: LoraCreateManyInput | LoraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lora createManyAndReturn
   */
  export type LoraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * The data used to create many Loras.
     */
    data: LoraCreateManyInput | LoraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lora update
   */
  export type LoraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * The data needed to update a Lora.
     */
    data: XOR<LoraUpdateInput, LoraUncheckedUpdateInput>
    /**
     * Choose, which Lora to update.
     */
    where: LoraWhereUniqueInput
  }

  /**
   * Lora updateMany
   */
  export type LoraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loras.
     */
    data: XOR<LoraUpdateManyMutationInput, LoraUncheckedUpdateManyInput>
    /**
     * Filter which Loras to update
     */
    where?: LoraWhereInput
    /**
     * Limit how many Loras to update.
     */
    limit?: number
  }

  /**
   * Lora updateManyAndReturn
   */
  export type LoraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * The data used to update Loras.
     */
    data: XOR<LoraUpdateManyMutationInput, LoraUncheckedUpdateManyInput>
    /**
     * Filter which Loras to update
     */
    where?: LoraWhereInput
    /**
     * Limit how many Loras to update.
     */
    limit?: number
  }

  /**
   * Lora upsert
   */
  export type LoraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * The filter to search for the Lora to update in case it exists.
     */
    where: LoraWhereUniqueInput
    /**
     * In case the Lora found by the `where` argument doesn't exist, create a new Lora with this data.
     */
    create: XOR<LoraCreateInput, LoraUncheckedCreateInput>
    /**
     * In case the Lora was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoraUpdateInput, LoraUncheckedUpdateInput>
  }

  /**
   * Lora delete
   */
  export type LoraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    /**
     * Filter which Lora to delete.
     */
    where: LoraWhereUniqueInput
  }

  /**
   * Lora deleteMany
   */
  export type LoraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loras to delete
     */
    where?: LoraWhereInput
    /**
     * Limit how many Loras to delete.
     */
    limit?: number
  }

  /**
   * Lora.characters
   */
  export type Lora$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Lora without action
   */
  export type LoraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
  }


  /**
   * Model Attire
   */

  export type AggregateAttire = {
    _count: AttireCountAggregateOutputType | null
    _avg: AttireAvgAggregateOutputType | null
    _sum: AttireSumAggregateOutputType | null
    _min: AttireMinAggregateOutputType | null
    _max: AttireMaxAggregateOutputType | null
  }

  export type AttireAvgAggregateOutputType = {
    contentVersion: number | null
  }

  export type AttireSumAggregateOutputType = {
    contentVersion: number | null
  }

  export type AttireMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    gender: string | null
    promptHead: string | null
    promptBody: string | null
    promptFull: string | null
    previewImageUrl: string | null
    originalLanguageCode: string | null
    visibility: $Enums.Visibility | null
    userId: string | null
    ageRating: $Enums.AgeRating | null
    contentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttireMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    gender: string | null
    promptHead: string | null
    promptBody: string | null
    promptFull: string | null
    previewImageUrl: string | null
    originalLanguageCode: string | null
    visibility: $Enums.Visibility | null
    userId: string | null
    ageRating: $Enums.AgeRating | null
    contentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttireCountAggregateOutputType = {
    id: number
    name: number
    description: number
    gender: number
    promptHead: number
    promptBody: number
    promptFull: number
    previewImageUrl: number
    originalLanguageCode: number
    visibility: number
    userId: number
    ageRating: number
    contentTags: number
    contentVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttireAvgAggregateInputType = {
    contentVersion?: true
  }

  export type AttireSumAggregateInputType = {
    contentVersion?: true
  }

  export type AttireMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    gender?: true
    promptHead?: true
    promptBody?: true
    promptFull?: true
    previewImageUrl?: true
    originalLanguageCode?: true
    visibility?: true
    userId?: true
    ageRating?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttireMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    gender?: true
    promptHead?: true
    promptBody?: true
    promptFull?: true
    previewImageUrl?: true
    originalLanguageCode?: true
    visibility?: true
    userId?: true
    ageRating?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttireCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    gender?: true
    promptHead?: true
    promptBody?: true
    promptFull?: true
    previewImageUrl?: true
    originalLanguageCode?: true
    visibility?: true
    userId?: true
    ageRating?: true
    contentTags?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attire to aggregate.
     */
    where?: AttireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attires to fetch.
     */
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attires
    **/
    _count?: true | AttireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttireMaxAggregateInputType
  }

  export type GetAttireAggregateType<T extends AttireAggregateArgs> = {
        [P in keyof T & keyof AggregateAttire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttire[P]>
      : GetScalarType<T[P], AggregateAttire[P]>
  }




  export type AttireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttireWhereInput
    orderBy?: AttireOrderByWithAggregationInput | AttireOrderByWithAggregationInput[]
    by: AttireScalarFieldEnum[] | AttireScalarFieldEnum
    having?: AttireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttireCountAggregateInputType | true
    _avg?: AttireAvgAggregateInputType
    _sum?: AttireSumAggregateInputType
    _min?: AttireMinAggregateInputType
    _max?: AttireMaxAggregateInputType
  }

  export type AttireGroupByOutputType = {
    id: string
    name: string
    description: string | null
    gender: string | null
    promptHead: string | null
    promptBody: string | null
    promptFull: string | null
    previewImageUrl: string | null
    originalLanguageCode: string | null
    visibility: $Enums.Visibility
    userId: string
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    contentVersion: number
    createdAt: Date
    updatedAt: Date
    _count: AttireCountAggregateOutputType | null
    _avg: AttireAvgAggregateOutputType | null
    _sum: AttireSumAggregateOutputType | null
    _min: AttireMinAggregateOutputType | null
    _max: AttireMaxAggregateOutputType | null
  }

  type GetAttireGroupByPayload<T extends AttireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttireGroupByOutputType[P]>
            : GetScalarType<T[P], AttireGroupByOutputType[P]>
        }
      >
    >


  export type AttireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    promptHead?: boolean
    promptBody?: boolean
    promptFull?: boolean
    previewImageUrl?: boolean
    originalLanguageCode?: boolean
    visibility?: boolean
    userId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    charactersUsingAsMain?: boolean | Attire$charactersUsingAsMainArgs<ExtArgs>
    characters?: boolean | Attire$charactersArgs<ExtArgs>
    _count?: boolean | AttireCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attire"]>

  export type AttireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    promptHead?: boolean
    promptBody?: boolean
    promptFull?: boolean
    previewImageUrl?: boolean
    originalLanguageCode?: boolean
    visibility?: boolean
    userId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attire"]>

  export type AttireSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    promptHead?: boolean
    promptBody?: boolean
    promptFull?: boolean
    previewImageUrl?: boolean
    originalLanguageCode?: boolean
    visibility?: boolean
    userId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attire"]>

  export type AttireSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    promptHead?: boolean
    promptBody?: boolean
    promptFull?: boolean
    previewImageUrl?: boolean
    originalLanguageCode?: boolean
    visibility?: boolean
    userId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttireOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "gender" | "promptHead" | "promptBody" | "promptFull" | "previewImageUrl" | "originalLanguageCode" | "visibility" | "userId" | "ageRating" | "contentTags" | "contentVersion" | "createdAt" | "updatedAt", ExtArgs["result"]["attire"]>
  export type AttireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    charactersUsingAsMain?: boolean | Attire$charactersUsingAsMainArgs<ExtArgs>
    characters?: boolean | Attire$charactersArgs<ExtArgs>
    _count?: boolean | AttireCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttireIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttirePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attire"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      charactersUsingAsMain: Prisma.$CharacterPayload<ExtArgs>[]
      characters: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      gender: string | null
      promptHead: string | null
      promptBody: string | null
      promptFull: string | null
      previewImageUrl: string | null
      originalLanguageCode: string | null
      visibility: $Enums.Visibility
      userId: string
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      contentVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attire"]>
    composites: {}
  }

  type AttireGetPayload<S extends boolean | null | undefined | AttireDefaultArgs> = $Result.GetResult<Prisma.$AttirePayload, S>

  type AttireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttireFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttireCountAggregateInputType | true
    }

  export interface AttireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attire'], meta: { name: 'Attire' } }
    /**
     * Find zero or one Attire that matches the filter.
     * @param {AttireFindUniqueArgs} args - Arguments to find a Attire
     * @example
     * // Get one Attire
     * const attire = await prisma.attire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttireFindUniqueArgs>(args: SelectSubset<T, AttireFindUniqueArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attire that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttireFindUniqueOrThrowArgs} args - Arguments to find a Attire
     * @example
     * // Get one Attire
     * const attire = await prisma.attire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttireFindUniqueOrThrowArgs>(args: SelectSubset<T, AttireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireFindFirstArgs} args - Arguments to find a Attire
     * @example
     * // Get one Attire
     * const attire = await prisma.attire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttireFindFirstArgs>(args?: SelectSubset<T, AttireFindFirstArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireFindFirstOrThrowArgs} args - Arguments to find a Attire
     * @example
     * // Get one Attire
     * const attire = await prisma.attire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttireFindFirstOrThrowArgs>(args?: SelectSubset<T, AttireFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attires
     * const attires = await prisma.attire.findMany()
     * 
     * // Get first 10 Attires
     * const attires = await prisma.attire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attireWithIdOnly = await prisma.attire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttireFindManyArgs>(args?: SelectSubset<T, AttireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attire.
     * @param {AttireCreateArgs} args - Arguments to create a Attire.
     * @example
     * // Create one Attire
     * const Attire = await prisma.attire.create({
     *   data: {
     *     // ... data to create a Attire
     *   }
     * })
     * 
     */
    create<T extends AttireCreateArgs>(args: SelectSubset<T, AttireCreateArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attires.
     * @param {AttireCreateManyArgs} args - Arguments to create many Attires.
     * @example
     * // Create many Attires
     * const attire = await prisma.attire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttireCreateManyArgs>(args?: SelectSubset<T, AttireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attires and returns the data saved in the database.
     * @param {AttireCreateManyAndReturnArgs} args - Arguments to create many Attires.
     * @example
     * // Create many Attires
     * const attire = await prisma.attire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attires and only return the `id`
     * const attireWithIdOnly = await prisma.attire.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttireCreateManyAndReturnArgs>(args?: SelectSubset<T, AttireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attire.
     * @param {AttireDeleteArgs} args - Arguments to delete one Attire.
     * @example
     * // Delete one Attire
     * const Attire = await prisma.attire.delete({
     *   where: {
     *     // ... filter to delete one Attire
     *   }
     * })
     * 
     */
    delete<T extends AttireDeleteArgs>(args: SelectSubset<T, AttireDeleteArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attire.
     * @param {AttireUpdateArgs} args - Arguments to update one Attire.
     * @example
     * // Update one Attire
     * const attire = await prisma.attire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttireUpdateArgs>(args: SelectSubset<T, AttireUpdateArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attires.
     * @param {AttireDeleteManyArgs} args - Arguments to filter Attires to delete.
     * @example
     * // Delete a few Attires
     * const { count } = await prisma.attire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttireDeleteManyArgs>(args?: SelectSubset<T, AttireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attires
     * const attire = await prisma.attire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttireUpdateManyArgs>(args: SelectSubset<T, AttireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attires and returns the data updated in the database.
     * @param {AttireUpdateManyAndReturnArgs} args - Arguments to update many Attires.
     * @example
     * // Update many Attires
     * const attire = await prisma.attire.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attires and only return the `id`
     * const attireWithIdOnly = await prisma.attire.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttireUpdateManyAndReturnArgs>(args: SelectSubset<T, AttireUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attire.
     * @param {AttireUpsertArgs} args - Arguments to update or create a Attire.
     * @example
     * // Update or create a Attire
     * const attire = await prisma.attire.upsert({
     *   create: {
     *     // ... data to create a Attire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attire we want to update
     *   }
     * })
     */
    upsert<T extends AttireUpsertArgs>(args: SelectSubset<T, AttireUpsertArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireCountArgs} args - Arguments to filter Attires to count.
     * @example
     * // Count the number of Attires
     * const count = await prisma.attire.count({
     *   where: {
     *     // ... the filter for the Attires we want to count
     *   }
     * })
    **/
    count<T extends AttireCountArgs>(
      args?: Subset<T, AttireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttireAggregateArgs>(args: Subset<T, AttireAggregateArgs>): Prisma.PrismaPromise<GetAttireAggregateType<T>>

    /**
     * Group by Attire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttireGroupByArgs['orderBy'] }
        : { orderBy?: AttireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attire model
   */
  readonly fields: AttireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    charactersUsingAsMain<T extends Attire$charactersUsingAsMainArgs<ExtArgs> = {}>(args?: Subset<T, Attire$charactersUsingAsMainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends Attire$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Attire$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attire model
   */
  interface AttireFieldRefs {
    readonly id: FieldRef<"Attire", 'String'>
    readonly name: FieldRef<"Attire", 'String'>
    readonly description: FieldRef<"Attire", 'String'>
    readonly gender: FieldRef<"Attire", 'String'>
    readonly promptHead: FieldRef<"Attire", 'String'>
    readonly promptBody: FieldRef<"Attire", 'String'>
    readonly promptFull: FieldRef<"Attire", 'String'>
    readonly previewImageUrl: FieldRef<"Attire", 'String'>
    readonly originalLanguageCode: FieldRef<"Attire", 'String'>
    readonly visibility: FieldRef<"Attire", 'Visibility'>
    readonly userId: FieldRef<"Attire", 'String'>
    readonly ageRating: FieldRef<"Attire", 'AgeRating'>
    readonly contentTags: FieldRef<"Attire", 'ContentTag[]'>
    readonly contentVersion: FieldRef<"Attire", 'Int'>
    readonly createdAt: FieldRef<"Attire", 'DateTime'>
    readonly updatedAt: FieldRef<"Attire", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attire findUnique
   */
  export type AttireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter, which Attire to fetch.
     */
    where: AttireWhereUniqueInput
  }

  /**
   * Attire findUniqueOrThrow
   */
  export type AttireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter, which Attire to fetch.
     */
    where: AttireWhereUniqueInput
  }

  /**
   * Attire findFirst
   */
  export type AttireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter, which Attire to fetch.
     */
    where?: AttireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attires to fetch.
     */
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attires.
     */
    cursor?: AttireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attires.
     */
    distinct?: AttireScalarFieldEnum | AttireScalarFieldEnum[]
  }

  /**
   * Attire findFirstOrThrow
   */
  export type AttireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter, which Attire to fetch.
     */
    where?: AttireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attires to fetch.
     */
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attires.
     */
    cursor?: AttireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attires.
     */
    distinct?: AttireScalarFieldEnum | AttireScalarFieldEnum[]
  }

  /**
   * Attire findMany
   */
  export type AttireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter, which Attires to fetch.
     */
    where?: AttireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attires to fetch.
     */
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attires.
     */
    cursor?: AttireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attires.
     */
    skip?: number
    distinct?: AttireScalarFieldEnum | AttireScalarFieldEnum[]
  }

  /**
   * Attire create
   */
  export type AttireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * The data needed to create a Attire.
     */
    data: XOR<AttireCreateInput, AttireUncheckedCreateInput>
  }

  /**
   * Attire createMany
   */
  export type AttireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attires.
     */
    data: AttireCreateManyInput | AttireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attire createManyAndReturn
   */
  export type AttireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * The data used to create many Attires.
     */
    data: AttireCreateManyInput | AttireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attire update
   */
  export type AttireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * The data needed to update a Attire.
     */
    data: XOR<AttireUpdateInput, AttireUncheckedUpdateInput>
    /**
     * Choose, which Attire to update.
     */
    where: AttireWhereUniqueInput
  }

  /**
   * Attire updateMany
   */
  export type AttireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attires.
     */
    data: XOR<AttireUpdateManyMutationInput, AttireUncheckedUpdateManyInput>
    /**
     * Filter which Attires to update
     */
    where?: AttireWhereInput
    /**
     * Limit how many Attires to update.
     */
    limit?: number
  }

  /**
   * Attire updateManyAndReturn
   */
  export type AttireUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * The data used to update Attires.
     */
    data: XOR<AttireUpdateManyMutationInput, AttireUncheckedUpdateManyInput>
    /**
     * Filter which Attires to update
     */
    where?: AttireWhereInput
    /**
     * Limit how many Attires to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attire upsert
   */
  export type AttireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * The filter to search for the Attire to update in case it exists.
     */
    where: AttireWhereUniqueInput
    /**
     * In case the Attire found by the `where` argument doesn't exist, create a new Attire with this data.
     */
    create: XOR<AttireCreateInput, AttireUncheckedCreateInput>
    /**
     * In case the Attire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttireUpdateInput, AttireUncheckedUpdateInput>
  }

  /**
   * Attire delete
   */
  export type AttireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    /**
     * Filter which Attire to delete.
     */
    where: AttireWhereUniqueInput
  }

  /**
   * Attire deleteMany
   */
  export type AttireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attires to delete
     */
    where?: AttireWhereInput
    /**
     * Limit how many Attires to delete.
     */
    limit?: number
  }

  /**
   * Attire.charactersUsingAsMain
   */
  export type Attire$charactersUsingAsMainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Attire.characters
   */
  export type Attire$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Attire without action
   */
  export type AttireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    weight: number | null
  }

  export type TagSumAggregateOutputType = {
    weight: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TagType | null
    ageRating: $Enums.AgeRating | null
    originalLanguageCode: string | null
    weight: number | null
    searchable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TagType | null
    ageRating: $Enums.AgeRating | null
    originalLanguageCode: string | null
    weight: number | null
    searchable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    ageRating: number
    contentTags: number
    originalLanguageCode: number
    weight: number
    searchable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    weight?: true
  }

  export type TagSumAggregateInputType = {
    weight?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    ageRating?: true
    originalLanguageCode?: true
    weight?: true
    searchable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    ageRating?: true
    originalLanguageCode?: true
    weight?: true
    searchable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    ageRating?: true
    contentTags?: true
    originalLanguageCode?: true
    weight?: true
    searchable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.TagType
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    originalLanguageCode: string | null
    weight: number
    searchable: boolean
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    ageRating?: boolean
    contentTags?: boolean
    originalLanguageCode?: boolean
    weight?: boolean
    searchable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characters?: boolean | Tag$charactersArgs<ExtArgs>
    stories?: boolean | Tag$storiesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    ageRating?: boolean
    contentTags?: boolean
    originalLanguageCode?: boolean
    weight?: boolean
    searchable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    ageRating?: boolean
    contentTags?: boolean
    originalLanguageCode?: boolean
    weight?: boolean
    searchable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    ageRating?: boolean
    contentTags?: boolean
    originalLanguageCode?: boolean
    weight?: boolean
    searchable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "ageRating" | "contentTags" | "originalLanguageCode" | "weight" | "searchable" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | Tag$charactersArgs<ExtArgs>
    stories?: boolean | Tag$storiesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      stories: Prisma.$StoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.TagType
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      originalLanguageCode: string | null
      weight: number
      searchable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends Tag$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Tag$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends Tag$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly type: FieldRef<"Tag", 'TagType'>
    readonly ageRating: FieldRef<"Tag", 'AgeRating'>
    readonly contentTags: FieldRef<"Tag", 'ContentTag[]'>
    readonly originalLanguageCode: FieldRef<"Tag", 'String'>
    readonly weight: FieldRef<"Tag", 'Int'>
    readonly searchable: FieldRef<"Tag", 'Boolean'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.characters
   */
  export type Tag$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Tag.stories
   */
  export type Tag$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    age: number | null
    contentVersion: number | null
  }

  export type CharacterSumAggregateOutputType = {
    age: number | null
    contentVersion: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    age: number | null
    gender: string | null
    species: string | null
    style: $Enums.VisualStyle | null
    reference: string | null
    physicalCharacteristics: string | null
    personality: string | null
    history: string | null
    visibility: $Enums.Visibility | null
    isSystemCharacter: boolean | null
    originalLanguageCode: string | null
    ageRating: $Enums.AgeRating | null
    userId: string | null
    loraId: string | null
    mainAttireId: string | null
    contentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    age: number | null
    gender: string | null
    species: string | null
    style: $Enums.VisualStyle | null
    reference: string | null
    physicalCharacteristics: string | null
    personality: string | null
    history: string | null
    visibility: $Enums.Visibility | null
    isSystemCharacter: boolean | null
    originalLanguageCode: string | null
    ageRating: $Enums.AgeRating | null
    userId: string | null
    loraId: string | null
    mainAttireId: string | null
    contentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    age: number
    gender: number
    species: number
    style: number
    reference: number
    physicalCharacteristics: number
    personality: number
    history: number
    visibility: number
    isSystemCharacter: number
    originalLanguageCode: number
    ageRating: number
    contentTags: number
    userId: number
    loraId: number
    mainAttireId: number
    contentVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    age?: true
    contentVersion?: true
  }

  export type CharacterSumAggregateInputType = {
    age?: true
    contentVersion?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    gender?: true
    species?: true
    style?: true
    reference?: true
    physicalCharacteristics?: true
    personality?: true
    history?: true
    visibility?: true
    isSystemCharacter?: true
    originalLanguageCode?: true
    ageRating?: true
    userId?: true
    loraId?: true
    mainAttireId?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    gender?: true
    species?: true
    style?: true
    reference?: true
    physicalCharacteristics?: true
    personality?: true
    history?: true
    visibility?: true
    isSystemCharacter?: true
    originalLanguageCode?: true
    ageRating?: true
    userId?: true
    loraId?: true
    mainAttireId?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    age?: true
    gender?: true
    species?: true
    style?: true
    reference?: true
    physicalCharacteristics?: true
    personality?: true
    history?: true
    visibility?: true
    isSystemCharacter?: true
    originalLanguageCode?: true
    ageRating?: true
    contentTags?: true
    userId?: true
    loraId?: true
    mainAttireId?: true
    contentVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    firstName: string
    lastName: string | null
    age: number | null
    gender: string | null
    species: string | null
    style: $Enums.VisualStyle | null
    reference: string | null
    physicalCharacteristics: string | null
    personality: string | null
    history: string | null
    visibility: $Enums.Visibility
    isSystemCharacter: boolean
    originalLanguageCode: string | null
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    userId: string
    loraId: string | null
    mainAttireId: string | null
    contentVersion: number
    createdAt: Date
    updatedAt: Date
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    style?: boolean
    reference?: boolean
    physicalCharacteristics?: boolean
    personality?: boolean
    history?: boolean
    visibility?: boolean
    isSystemCharacter?: boolean
    originalLanguageCode?: boolean
    ageRating?: boolean
    contentTags?: boolean
    userId?: boolean
    loraId?: boolean
    mainAttireId?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
    stories?: boolean | Character$storiesArgs<ExtArgs>
    attires?: boolean | Character$attiresArgs<ExtArgs>
    tags?: boolean | Character$tagsArgs<ExtArgs>
    stickers?: boolean | Character$stickersArgs<ExtArgs>
    images?: boolean | Character$imagesArgs<ExtArgs>
    assistantsUsingAsDefault?: boolean | Character$assistantsUsingAsDefaultArgs<ExtArgs>
    actingParticipations?: boolean | Character$actingParticipationsArgs<ExtArgs>
    representingParticipations?: boolean | Character$representingParticipationsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    style?: boolean
    reference?: boolean
    physicalCharacteristics?: boolean
    personality?: boolean
    history?: boolean
    visibility?: boolean
    isSystemCharacter?: boolean
    originalLanguageCode?: boolean
    ageRating?: boolean
    contentTags?: boolean
    userId?: boolean
    loraId?: boolean
    mainAttireId?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    style?: boolean
    reference?: boolean
    physicalCharacteristics?: boolean
    personality?: boolean
    history?: boolean
    visibility?: boolean
    isSystemCharacter?: boolean
    originalLanguageCode?: boolean
    ageRating?: boolean
    contentTags?: boolean
    userId?: boolean
    loraId?: boolean
    mainAttireId?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    style?: boolean
    reference?: boolean
    physicalCharacteristics?: boolean
    personality?: boolean
    history?: boolean
    visibility?: boolean
    isSystemCharacter?: boolean
    originalLanguageCode?: boolean
    ageRating?: boolean
    contentTags?: boolean
    userId?: boolean
    loraId?: boolean
    mainAttireId?: boolean
    contentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "age" | "gender" | "species" | "style" | "reference" | "physicalCharacteristics" | "personality" | "history" | "visibility" | "isSystemCharacter" | "originalLanguageCode" | "ageRating" | "contentTags" | "userId" | "loraId" | "mainAttireId" | "contentVersion" | "createdAt" | "updatedAt", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
    stories?: boolean | Character$storiesArgs<ExtArgs>
    attires?: boolean | Character$attiresArgs<ExtArgs>
    tags?: boolean | Character$tagsArgs<ExtArgs>
    stickers?: boolean | Character$stickersArgs<ExtArgs>
    images?: boolean | Character$imagesArgs<ExtArgs>
    assistantsUsingAsDefault?: boolean | Character$assistantsUsingAsDefaultArgs<ExtArgs>
    actingParticipations?: boolean | Character$actingParticipationsArgs<ExtArgs>
    representingParticipations?: boolean | Character$representingParticipationsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
  }
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lora?: boolean | Character$loraArgs<ExtArgs>
    mainAttire?: boolean | Character$mainAttireArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      lora: Prisma.$LoraPayload<ExtArgs> | null
      mainAttire: Prisma.$AttirePayload<ExtArgs> | null
      stories: Prisma.$StoryPayload<ExtArgs>[]
      attires: Prisma.$AttirePayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      stickers: Prisma.$CharacterStickerPayload<ExtArgs>[]
      images: Prisma.$CharacterImagePayload<ExtArgs>[]
      assistantsUsingAsDefault: Prisma.$AssistantPayload<ExtArgs>[]
      actingParticipations: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      representingParticipations: Prisma.$ConversationParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string | null
      age: number | null
      gender: string | null
      species: string | null
      style: $Enums.VisualStyle | null
      reference: string | null
      physicalCharacteristics: string | null
      personality: string | null
      history: string | null
      visibility: $Enums.Visibility
      isSystemCharacter: boolean
      originalLanguageCode: string | null
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      userId: string
      loraId: string | null
      mainAttireId: string | null
      contentVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lora<T extends Character$loraArgs<ExtArgs> = {}>(args?: Subset<T, Character$loraArgs<ExtArgs>>): Prisma__LoraClient<$Result.GetResult<Prisma.$LoraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mainAttire<T extends Character$mainAttireArgs<ExtArgs> = {}>(args?: Subset<T, Character$mainAttireArgs<ExtArgs>>): Prisma__AttireClient<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stories<T extends Character$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Character$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attires<T extends Character$attiresArgs<ExtArgs> = {}>(args?: Subset<T, Character$attiresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttirePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Character$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Character$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stickers<T extends Character$stickersArgs<ExtArgs> = {}>(args?: Subset<T, Character$stickersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Character$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Character$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assistantsUsingAsDefault<T extends Character$assistantsUsingAsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Character$assistantsUsingAsDefaultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actingParticipations<T extends Character$actingParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Character$actingParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    representingParticipations<T extends Character$representingParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Character$representingParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly firstName: FieldRef<"Character", 'String'>
    readonly lastName: FieldRef<"Character", 'String'>
    readonly age: FieldRef<"Character", 'Int'>
    readonly gender: FieldRef<"Character", 'String'>
    readonly species: FieldRef<"Character", 'String'>
    readonly style: FieldRef<"Character", 'VisualStyle'>
    readonly reference: FieldRef<"Character", 'String'>
    readonly physicalCharacteristics: FieldRef<"Character", 'String'>
    readonly personality: FieldRef<"Character", 'String'>
    readonly history: FieldRef<"Character", 'String'>
    readonly visibility: FieldRef<"Character", 'Visibility'>
    readonly isSystemCharacter: FieldRef<"Character", 'Boolean'>
    readonly originalLanguageCode: FieldRef<"Character", 'String'>
    readonly ageRating: FieldRef<"Character", 'AgeRating'>
    readonly contentTags: FieldRef<"Character", 'ContentTag[]'>
    readonly userId: FieldRef<"Character", 'String'>
    readonly loraId: FieldRef<"Character", 'String'>
    readonly mainAttireId: FieldRef<"Character", 'String'>
    readonly contentVersion: FieldRef<"Character", 'Int'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.lora
   */
  export type Character$loraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lora
     */
    select?: LoraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lora
     */
    omit?: LoraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoraInclude<ExtArgs> | null
    where?: LoraWhereInput
  }

  /**
   * Character.mainAttire
   */
  export type Character$mainAttireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    where?: AttireWhereInput
  }

  /**
   * Character.stories
   */
  export type Character$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Character.attires
   */
  export type Character$attiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attire
     */
    select?: AttireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attire
     */
    omit?: AttireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttireInclude<ExtArgs> | null
    where?: AttireWhereInput
    orderBy?: AttireOrderByWithRelationInput | AttireOrderByWithRelationInput[]
    cursor?: AttireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttireScalarFieldEnum | AttireScalarFieldEnum[]
  }

  /**
   * Character.tags
   */
  export type Character$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Character.stickers
   */
  export type Character$stickersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    where?: CharacterStickerWhereInput
    orderBy?: CharacterStickerOrderByWithRelationInput | CharacterStickerOrderByWithRelationInput[]
    cursor?: CharacterStickerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterStickerScalarFieldEnum | CharacterStickerScalarFieldEnum[]
  }

  /**
   * Character.images
   */
  export type Character$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    where?: CharacterImageWhereInput
    orderBy?: CharacterImageOrderByWithRelationInput | CharacterImageOrderByWithRelationInput[]
    cursor?: CharacterImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterImageScalarFieldEnum | CharacterImageScalarFieldEnum[]
  }

  /**
   * Character.assistantsUsingAsDefault
   */
  export type Character$assistantsUsingAsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    where?: AssistantWhereInput
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    cursor?: AssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }

  /**
   * Character.actingParticipations
   */
  export type Character$actingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Character.representingParticipations
   */
  export type Character$representingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model CharacterSticker
   */

  export type AggregateCharacterSticker = {
    _count: CharacterStickerCountAggregateOutputType | null
    _min: CharacterStickerMinAggregateOutputType | null
    _max: CharacterStickerMaxAggregateOutputType | null
  }

  export type CharacterStickerMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    emotionTag: string | null
    actionTag: string | null
    imageUrl: string | null
    promptUsed: string | null
    status: $Enums.StickerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterStickerMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    emotionTag: string | null
    actionTag: string | null
    imageUrl: string | null
    promptUsed: string | null
    status: $Enums.StickerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterStickerCountAggregateOutputType = {
    id: number
    characterId: number
    emotionTag: number
    actionTag: number
    imageUrl: number
    promptUsed: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterStickerMinAggregateInputType = {
    id?: true
    characterId?: true
    emotionTag?: true
    actionTag?: true
    imageUrl?: true
    promptUsed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterStickerMaxAggregateInputType = {
    id?: true
    characterId?: true
    emotionTag?: true
    actionTag?: true
    imageUrl?: true
    promptUsed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterStickerCountAggregateInputType = {
    id?: true
    characterId?: true
    emotionTag?: true
    actionTag?: true
    imageUrl?: true
    promptUsed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterStickerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSticker to aggregate.
     */
    where?: CharacterStickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStickers to fetch.
     */
    orderBy?: CharacterStickerOrderByWithRelationInput | CharacterStickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterStickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterStickers
    **/
    _count?: true | CharacterStickerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterStickerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterStickerMaxAggregateInputType
  }

  export type GetCharacterStickerAggregateType<T extends CharacterStickerAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSticker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSticker[P]>
      : GetScalarType<T[P], AggregateCharacterSticker[P]>
  }




  export type CharacterStickerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterStickerWhereInput
    orderBy?: CharacterStickerOrderByWithAggregationInput | CharacterStickerOrderByWithAggregationInput[]
    by: CharacterStickerScalarFieldEnum[] | CharacterStickerScalarFieldEnum
    having?: CharacterStickerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterStickerCountAggregateInputType | true
    _min?: CharacterStickerMinAggregateInputType
    _max?: CharacterStickerMaxAggregateInputType
  }

  export type CharacterStickerGroupByOutputType = {
    id: string
    characterId: string
    emotionTag: string | null
    actionTag: string | null
    imageUrl: string | null
    promptUsed: string | null
    status: $Enums.StickerStatus
    createdAt: Date
    updatedAt: Date
    _count: CharacterStickerCountAggregateOutputType | null
    _min: CharacterStickerMinAggregateOutputType | null
    _max: CharacterStickerMaxAggregateOutputType | null
  }

  type GetCharacterStickerGroupByPayload<T extends CharacterStickerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterStickerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterStickerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterStickerGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterStickerGroupByOutputType[P]>
        }
      >
    >


  export type CharacterStickerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    emotionTag?: boolean
    actionTag?: boolean
    imageUrl?: boolean
    promptUsed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSticker"]>

  export type CharacterStickerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    emotionTag?: boolean
    actionTag?: boolean
    imageUrl?: boolean
    promptUsed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSticker"]>

  export type CharacterStickerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    emotionTag?: boolean
    actionTag?: boolean
    imageUrl?: boolean
    promptUsed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSticker"]>

  export type CharacterStickerSelectScalar = {
    id?: boolean
    characterId?: boolean
    emotionTag?: boolean
    actionTag?: boolean
    imageUrl?: boolean
    promptUsed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterStickerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "emotionTag" | "actionTag" | "imageUrl" | "promptUsed" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["characterSticker"]>
  export type CharacterStickerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterStickerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterStickerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterStickerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSticker"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      emotionTag: string | null
      actionTag: string | null
      imageUrl: string | null
      promptUsed: string | null
      status: $Enums.StickerStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["characterSticker"]>
    composites: {}
  }

  type CharacterStickerGetPayload<S extends boolean | null | undefined | CharacterStickerDefaultArgs> = $Result.GetResult<Prisma.$CharacterStickerPayload, S>

  type CharacterStickerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterStickerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterStickerCountAggregateInputType | true
    }

  export interface CharacterStickerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSticker'], meta: { name: 'CharacterSticker' } }
    /**
     * Find zero or one CharacterSticker that matches the filter.
     * @param {CharacterStickerFindUniqueArgs} args - Arguments to find a CharacterSticker
     * @example
     * // Get one CharacterSticker
     * const characterSticker = await prisma.characterSticker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterStickerFindUniqueArgs>(args: SelectSubset<T, CharacterStickerFindUniqueArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterSticker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterStickerFindUniqueOrThrowArgs} args - Arguments to find a CharacterSticker
     * @example
     * // Get one CharacterSticker
     * const characterSticker = await prisma.characterSticker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterStickerFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterStickerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSticker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerFindFirstArgs} args - Arguments to find a CharacterSticker
     * @example
     * // Get one CharacterSticker
     * const characterSticker = await prisma.characterSticker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterStickerFindFirstArgs>(args?: SelectSubset<T, CharacterStickerFindFirstArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSticker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerFindFirstOrThrowArgs} args - Arguments to find a CharacterSticker
     * @example
     * // Get one CharacterSticker
     * const characterSticker = await prisma.characterSticker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterStickerFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterStickerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterStickers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterStickers
     * const characterStickers = await prisma.characterSticker.findMany()
     * 
     * // Get first 10 CharacterStickers
     * const characterStickers = await prisma.characterSticker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterStickerWithIdOnly = await prisma.characterSticker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterStickerFindManyArgs>(args?: SelectSubset<T, CharacterStickerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterSticker.
     * @param {CharacterStickerCreateArgs} args - Arguments to create a CharacterSticker.
     * @example
     * // Create one CharacterSticker
     * const CharacterSticker = await prisma.characterSticker.create({
     *   data: {
     *     // ... data to create a CharacterSticker
     *   }
     * })
     * 
     */
    create<T extends CharacterStickerCreateArgs>(args: SelectSubset<T, CharacterStickerCreateArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterStickers.
     * @param {CharacterStickerCreateManyArgs} args - Arguments to create many CharacterStickers.
     * @example
     * // Create many CharacterStickers
     * const characterSticker = await prisma.characterSticker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterStickerCreateManyArgs>(args?: SelectSubset<T, CharacterStickerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterStickers and returns the data saved in the database.
     * @param {CharacterStickerCreateManyAndReturnArgs} args - Arguments to create many CharacterStickers.
     * @example
     * // Create many CharacterStickers
     * const characterSticker = await prisma.characterSticker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterStickers and only return the `id`
     * const characterStickerWithIdOnly = await prisma.characterSticker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterStickerCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterStickerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterSticker.
     * @param {CharacterStickerDeleteArgs} args - Arguments to delete one CharacterSticker.
     * @example
     * // Delete one CharacterSticker
     * const CharacterSticker = await prisma.characterSticker.delete({
     *   where: {
     *     // ... filter to delete one CharacterSticker
     *   }
     * })
     * 
     */
    delete<T extends CharacterStickerDeleteArgs>(args: SelectSubset<T, CharacterStickerDeleteArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterSticker.
     * @param {CharacterStickerUpdateArgs} args - Arguments to update one CharacterSticker.
     * @example
     * // Update one CharacterSticker
     * const characterSticker = await prisma.characterSticker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterStickerUpdateArgs>(args: SelectSubset<T, CharacterStickerUpdateArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterStickers.
     * @param {CharacterStickerDeleteManyArgs} args - Arguments to filter CharacterStickers to delete.
     * @example
     * // Delete a few CharacterStickers
     * const { count } = await prisma.characterSticker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterStickerDeleteManyArgs>(args?: SelectSubset<T, CharacterStickerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterStickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterStickers
     * const characterSticker = await prisma.characterSticker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterStickerUpdateManyArgs>(args: SelectSubset<T, CharacterStickerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterStickers and returns the data updated in the database.
     * @param {CharacterStickerUpdateManyAndReturnArgs} args - Arguments to update many CharacterStickers.
     * @example
     * // Update many CharacterStickers
     * const characterSticker = await prisma.characterSticker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterStickers and only return the `id`
     * const characterStickerWithIdOnly = await prisma.characterSticker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterStickerUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterStickerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterSticker.
     * @param {CharacterStickerUpsertArgs} args - Arguments to update or create a CharacterSticker.
     * @example
     * // Update or create a CharacterSticker
     * const characterSticker = await prisma.characterSticker.upsert({
     *   create: {
     *     // ... data to create a CharacterSticker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSticker we want to update
     *   }
     * })
     */
    upsert<T extends CharacterStickerUpsertArgs>(args: SelectSubset<T, CharacterStickerUpsertArgs<ExtArgs>>): Prisma__CharacterStickerClient<$Result.GetResult<Prisma.$CharacterStickerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterStickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerCountArgs} args - Arguments to filter CharacterStickers to count.
     * @example
     * // Count the number of CharacterStickers
     * const count = await prisma.characterSticker.count({
     *   where: {
     *     // ... the filter for the CharacterStickers we want to count
     *   }
     * })
    **/
    count<T extends CharacterStickerCountArgs>(
      args?: Subset<T, CharacterStickerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterStickerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSticker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterStickerAggregateArgs>(args: Subset<T, CharacterStickerAggregateArgs>): Prisma.PrismaPromise<GetCharacterStickerAggregateType<T>>

    /**
     * Group by CharacterSticker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStickerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterStickerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterStickerGroupByArgs['orderBy'] }
        : { orderBy?: CharacterStickerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterStickerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterStickerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSticker model
   */
  readonly fields: CharacterStickerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSticker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterStickerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterSticker model
   */
  interface CharacterStickerFieldRefs {
    readonly id: FieldRef<"CharacterSticker", 'String'>
    readonly characterId: FieldRef<"CharacterSticker", 'String'>
    readonly emotionTag: FieldRef<"CharacterSticker", 'String'>
    readonly actionTag: FieldRef<"CharacterSticker", 'String'>
    readonly imageUrl: FieldRef<"CharacterSticker", 'String'>
    readonly promptUsed: FieldRef<"CharacterSticker", 'String'>
    readonly status: FieldRef<"CharacterSticker", 'StickerStatus'>
    readonly createdAt: FieldRef<"CharacterSticker", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterSticker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterSticker findUnique
   */
  export type CharacterStickerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSticker to fetch.
     */
    where: CharacterStickerWhereUniqueInput
  }

  /**
   * CharacterSticker findUniqueOrThrow
   */
  export type CharacterStickerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSticker to fetch.
     */
    where: CharacterStickerWhereUniqueInput
  }

  /**
   * CharacterSticker findFirst
   */
  export type CharacterStickerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSticker to fetch.
     */
    where?: CharacterStickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStickers to fetch.
     */
    orderBy?: CharacterStickerOrderByWithRelationInput | CharacterStickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterStickers.
     */
    cursor?: CharacterStickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterStickers.
     */
    distinct?: CharacterStickerScalarFieldEnum | CharacterStickerScalarFieldEnum[]
  }

  /**
   * CharacterSticker findFirstOrThrow
   */
  export type CharacterStickerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSticker to fetch.
     */
    where?: CharacterStickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStickers to fetch.
     */
    orderBy?: CharacterStickerOrderByWithRelationInput | CharacterStickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterStickers.
     */
    cursor?: CharacterStickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterStickers.
     */
    distinct?: CharacterStickerScalarFieldEnum | CharacterStickerScalarFieldEnum[]
  }

  /**
   * CharacterSticker findMany
   */
  export type CharacterStickerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStickers to fetch.
     */
    where?: CharacterStickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStickers to fetch.
     */
    orderBy?: CharacterStickerOrderByWithRelationInput | CharacterStickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterStickers.
     */
    cursor?: CharacterStickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStickers.
     */
    skip?: number
    distinct?: CharacterStickerScalarFieldEnum | CharacterStickerScalarFieldEnum[]
  }

  /**
   * CharacterSticker create
   */
  export type CharacterStickerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSticker.
     */
    data: XOR<CharacterStickerCreateInput, CharacterStickerUncheckedCreateInput>
  }

  /**
   * CharacterSticker createMany
   */
  export type CharacterStickerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterStickers.
     */
    data: CharacterStickerCreateManyInput | CharacterStickerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSticker createManyAndReturn
   */
  export type CharacterStickerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterStickers.
     */
    data: CharacterStickerCreateManyInput | CharacterStickerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSticker update
   */
  export type CharacterStickerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSticker.
     */
    data: XOR<CharacterStickerUpdateInput, CharacterStickerUncheckedUpdateInput>
    /**
     * Choose, which CharacterSticker to update.
     */
    where: CharacterStickerWhereUniqueInput
  }

  /**
   * CharacterSticker updateMany
   */
  export type CharacterStickerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterStickers.
     */
    data: XOR<CharacterStickerUpdateManyMutationInput, CharacterStickerUncheckedUpdateManyInput>
    /**
     * Filter which CharacterStickers to update
     */
    where?: CharacterStickerWhereInput
    /**
     * Limit how many CharacterStickers to update.
     */
    limit?: number
  }

  /**
   * CharacterSticker updateManyAndReturn
   */
  export type CharacterStickerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * The data used to update CharacterStickers.
     */
    data: XOR<CharacterStickerUpdateManyMutationInput, CharacterStickerUncheckedUpdateManyInput>
    /**
     * Filter which CharacterStickers to update
     */
    where?: CharacterStickerWhereInput
    /**
     * Limit how many CharacterStickers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSticker upsert
   */
  export type CharacterStickerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSticker to update in case it exists.
     */
    where: CharacterStickerWhereUniqueInput
    /**
     * In case the CharacterSticker found by the `where` argument doesn't exist, create a new CharacterSticker with this data.
     */
    create: XOR<CharacterStickerCreateInput, CharacterStickerUncheckedCreateInput>
    /**
     * In case the CharacterSticker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterStickerUpdateInput, CharacterStickerUncheckedUpdateInput>
  }

  /**
   * CharacterSticker delete
   */
  export type CharacterStickerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
    /**
     * Filter which CharacterSticker to delete.
     */
    where: CharacterStickerWhereUniqueInput
  }

  /**
   * CharacterSticker deleteMany
   */
  export type CharacterStickerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterStickers to delete
     */
    where?: CharacterStickerWhereInput
    /**
     * Limit how many CharacterStickers to delete.
     */
    limit?: number
  }

  /**
   * CharacterSticker without action
   */
  export type CharacterStickerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSticker
     */
    select?: CharacterStickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSticker
     */
    omit?: CharacterStickerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterStickerInclude<ExtArgs> | null
  }


  /**
   * Model CharacterImage
   */

  export type AggregateCharacterImage = {
    _count: CharacterImageCountAggregateOutputType | null
    _avg: CharacterImageAvgAggregateOutputType | null
    _sum: CharacterImageSumAggregateOutputType | null
    _min: CharacterImageMinAggregateOutputType | null
    _max: CharacterImageMaxAggregateOutputType | null
  }

  export type CharacterImageAvgAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
  }

  export type CharacterImageSumAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
  }

  export type CharacterImageMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    type: $Enums.ImageType | null
    url: string | null
    key: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    contentType: string | null
    ageRating: $Enums.AgeRating | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterImageMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    type: $Enums.ImageType | null
    url: string | null
    key: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    contentType: string | null
    ageRating: $Enums.AgeRating | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterImageCountAggregateOutputType = {
    id: number
    characterId: number
    type: number
    url: number
    key: number
    width: number
    height: number
    sizeBytes: number
    contentType: number
    ageRating: number
    contentTags: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterImageAvgAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type CharacterImageSumAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type CharacterImageMinAggregateInputType = {
    id?: true
    characterId?: true
    type?: true
    url?: true
    key?: true
    width?: true
    height?: true
    sizeBytes?: true
    contentType?: true
    ageRating?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterImageMaxAggregateInputType = {
    id?: true
    characterId?: true
    type?: true
    url?: true
    key?: true
    width?: true
    height?: true
    sizeBytes?: true
    contentType?: true
    ageRating?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterImageCountAggregateInputType = {
    id?: true
    characterId?: true
    type?: true
    url?: true
    key?: true
    width?: true
    height?: true
    sizeBytes?: true
    contentType?: true
    ageRating?: true
    contentTags?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterImage to aggregate.
     */
    where?: CharacterImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterImages to fetch.
     */
    orderBy?: CharacterImageOrderByWithRelationInput | CharacterImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterImages
    **/
    _count?: true | CharacterImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterImageMaxAggregateInputType
  }

  export type GetCharacterImageAggregateType<T extends CharacterImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterImage[P]>
      : GetScalarType<T[P], AggregateCharacterImage[P]>
  }




  export type CharacterImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterImageWhereInput
    orderBy?: CharacterImageOrderByWithAggregationInput | CharacterImageOrderByWithAggregationInput[]
    by: CharacterImageScalarFieldEnum[] | CharacterImageScalarFieldEnum
    having?: CharacterImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterImageCountAggregateInputType | true
    _avg?: CharacterImageAvgAggregateInputType
    _sum?: CharacterImageSumAggregateInputType
    _min?: CharacterImageMinAggregateInputType
    _max?: CharacterImageMaxAggregateInputType
  }

  export type CharacterImageGroupByOutputType = {
    id: string
    characterId: string
    type: $Enums.ImageType
    url: string
    key: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    contentType: string | null
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CharacterImageCountAggregateOutputType | null
    _avg: CharacterImageAvgAggregateOutputType | null
    _sum: CharacterImageSumAggregateOutputType | null
    _min: CharacterImageMinAggregateOutputType | null
    _max: CharacterImageMaxAggregateOutputType | null
  }

  type GetCharacterImageGroupByPayload<T extends CharacterImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterImageGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterImageGroupByOutputType[P]>
        }
      >
    >


  export type CharacterImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    contentType?: boolean
    ageRating?: boolean
    contentTags?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterImage"]>

  export type CharacterImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    contentType?: boolean
    ageRating?: boolean
    contentTags?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterImage"]>

  export type CharacterImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    contentType?: boolean
    ageRating?: boolean
    contentTags?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterImage"]>

  export type CharacterImageSelectScalar = {
    id?: boolean
    characterId?: boolean
    type?: boolean
    url?: boolean
    key?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    contentType?: boolean
    ageRating?: boolean
    contentTags?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "type" | "url" | "key" | "width" | "height" | "sizeBytes" | "contentType" | "ageRating" | "contentTags" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["characterImage"]>
  export type CharacterImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterImage"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      type: $Enums.ImageType
      url: string
      key: string | null
      width: number | null
      height: number | null
      sizeBytes: number | null
      contentType: string | null
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["characterImage"]>
    composites: {}
  }

  type CharacterImageGetPayload<S extends boolean | null | undefined | CharacterImageDefaultArgs> = $Result.GetResult<Prisma.$CharacterImagePayload, S>

  type CharacterImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterImageCountAggregateInputType | true
    }

  export interface CharacterImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterImage'], meta: { name: 'CharacterImage' } }
    /**
     * Find zero or one CharacterImage that matches the filter.
     * @param {CharacterImageFindUniqueArgs} args - Arguments to find a CharacterImage
     * @example
     * // Get one CharacterImage
     * const characterImage = await prisma.characterImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterImageFindUniqueArgs>(args: SelectSubset<T, CharacterImageFindUniqueArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterImageFindUniqueOrThrowArgs} args - Arguments to find a CharacterImage
     * @example
     * // Get one CharacterImage
     * const characterImage = await prisma.characterImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageFindFirstArgs} args - Arguments to find a CharacterImage
     * @example
     * // Get one CharacterImage
     * const characterImage = await prisma.characterImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterImageFindFirstArgs>(args?: SelectSubset<T, CharacterImageFindFirstArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageFindFirstOrThrowArgs} args - Arguments to find a CharacterImage
     * @example
     * // Get one CharacterImage
     * const characterImage = await prisma.characterImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterImages
     * const characterImages = await prisma.characterImage.findMany()
     * 
     * // Get first 10 CharacterImages
     * const characterImages = await prisma.characterImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterImageWithIdOnly = await prisma.characterImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterImageFindManyArgs>(args?: SelectSubset<T, CharacterImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterImage.
     * @param {CharacterImageCreateArgs} args - Arguments to create a CharacterImage.
     * @example
     * // Create one CharacterImage
     * const CharacterImage = await prisma.characterImage.create({
     *   data: {
     *     // ... data to create a CharacterImage
     *   }
     * })
     * 
     */
    create<T extends CharacterImageCreateArgs>(args: SelectSubset<T, CharacterImageCreateArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterImages.
     * @param {CharacterImageCreateManyArgs} args - Arguments to create many CharacterImages.
     * @example
     * // Create many CharacterImages
     * const characterImage = await prisma.characterImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterImageCreateManyArgs>(args?: SelectSubset<T, CharacterImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterImages and returns the data saved in the database.
     * @param {CharacterImageCreateManyAndReturnArgs} args - Arguments to create many CharacterImages.
     * @example
     * // Create many CharacterImages
     * const characterImage = await prisma.characterImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterImages and only return the `id`
     * const characterImageWithIdOnly = await prisma.characterImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterImage.
     * @param {CharacterImageDeleteArgs} args - Arguments to delete one CharacterImage.
     * @example
     * // Delete one CharacterImage
     * const CharacterImage = await prisma.characterImage.delete({
     *   where: {
     *     // ... filter to delete one CharacterImage
     *   }
     * })
     * 
     */
    delete<T extends CharacterImageDeleteArgs>(args: SelectSubset<T, CharacterImageDeleteArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterImage.
     * @param {CharacterImageUpdateArgs} args - Arguments to update one CharacterImage.
     * @example
     * // Update one CharacterImage
     * const characterImage = await prisma.characterImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterImageUpdateArgs>(args: SelectSubset<T, CharacterImageUpdateArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterImages.
     * @param {CharacterImageDeleteManyArgs} args - Arguments to filter CharacterImages to delete.
     * @example
     * // Delete a few CharacterImages
     * const { count } = await prisma.characterImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterImageDeleteManyArgs>(args?: SelectSubset<T, CharacterImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterImages
     * const characterImage = await prisma.characterImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterImageUpdateManyArgs>(args: SelectSubset<T, CharacterImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterImages and returns the data updated in the database.
     * @param {CharacterImageUpdateManyAndReturnArgs} args - Arguments to update many CharacterImages.
     * @example
     * // Update many CharacterImages
     * const characterImage = await prisma.characterImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterImages and only return the `id`
     * const characterImageWithIdOnly = await prisma.characterImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterImage.
     * @param {CharacterImageUpsertArgs} args - Arguments to update or create a CharacterImage.
     * @example
     * // Update or create a CharacterImage
     * const characterImage = await prisma.characterImage.upsert({
     *   create: {
     *     // ... data to create a CharacterImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterImage we want to update
     *   }
     * })
     */
    upsert<T extends CharacterImageUpsertArgs>(args: SelectSubset<T, CharacterImageUpsertArgs<ExtArgs>>): Prisma__CharacterImageClient<$Result.GetResult<Prisma.$CharacterImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageCountArgs} args - Arguments to filter CharacterImages to count.
     * @example
     * // Count the number of CharacterImages
     * const count = await prisma.characterImage.count({
     *   where: {
     *     // ... the filter for the CharacterImages we want to count
     *   }
     * })
    **/
    count<T extends CharacterImageCountArgs>(
      args?: Subset<T, CharacterImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterImageAggregateArgs>(args: Subset<T, CharacterImageAggregateArgs>): Prisma.PrismaPromise<GetCharacterImageAggregateType<T>>

    /**
     * Group by CharacterImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterImageGroupByArgs['orderBy'] }
        : { orderBy?: CharacterImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterImage model
   */
  readonly fields: CharacterImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterImage model
   */
  interface CharacterImageFieldRefs {
    readonly id: FieldRef<"CharacterImage", 'String'>
    readonly characterId: FieldRef<"CharacterImage", 'String'>
    readonly type: FieldRef<"CharacterImage", 'ImageType'>
    readonly url: FieldRef<"CharacterImage", 'String'>
    readonly key: FieldRef<"CharacterImage", 'String'>
    readonly width: FieldRef<"CharacterImage", 'Int'>
    readonly height: FieldRef<"CharacterImage", 'Int'>
    readonly sizeBytes: FieldRef<"CharacterImage", 'Int'>
    readonly contentType: FieldRef<"CharacterImage", 'String'>
    readonly ageRating: FieldRef<"CharacterImage", 'AgeRating'>
    readonly contentTags: FieldRef<"CharacterImage", 'ContentTag[]'>
    readonly description: FieldRef<"CharacterImage", 'String'>
    readonly isActive: FieldRef<"CharacterImage", 'Boolean'>
    readonly createdAt: FieldRef<"CharacterImage", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterImage findUnique
   */
  export type CharacterImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter, which CharacterImage to fetch.
     */
    where: CharacterImageWhereUniqueInput
  }

  /**
   * CharacterImage findUniqueOrThrow
   */
  export type CharacterImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter, which CharacterImage to fetch.
     */
    where: CharacterImageWhereUniqueInput
  }

  /**
   * CharacterImage findFirst
   */
  export type CharacterImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter, which CharacterImage to fetch.
     */
    where?: CharacterImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterImages to fetch.
     */
    orderBy?: CharacterImageOrderByWithRelationInput | CharacterImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterImages.
     */
    cursor?: CharacterImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterImages.
     */
    distinct?: CharacterImageScalarFieldEnum | CharacterImageScalarFieldEnum[]
  }

  /**
   * CharacterImage findFirstOrThrow
   */
  export type CharacterImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter, which CharacterImage to fetch.
     */
    where?: CharacterImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterImages to fetch.
     */
    orderBy?: CharacterImageOrderByWithRelationInput | CharacterImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterImages.
     */
    cursor?: CharacterImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterImages.
     */
    distinct?: CharacterImageScalarFieldEnum | CharacterImageScalarFieldEnum[]
  }

  /**
   * CharacterImage findMany
   */
  export type CharacterImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter, which CharacterImages to fetch.
     */
    where?: CharacterImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterImages to fetch.
     */
    orderBy?: CharacterImageOrderByWithRelationInput | CharacterImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterImages.
     */
    cursor?: CharacterImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterImages.
     */
    skip?: number
    distinct?: CharacterImageScalarFieldEnum | CharacterImageScalarFieldEnum[]
  }

  /**
   * CharacterImage create
   */
  export type CharacterImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterImage.
     */
    data: XOR<CharacterImageCreateInput, CharacterImageUncheckedCreateInput>
  }

  /**
   * CharacterImage createMany
   */
  export type CharacterImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterImages.
     */
    data: CharacterImageCreateManyInput | CharacterImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterImage createManyAndReturn
   */
  export type CharacterImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterImages.
     */
    data: CharacterImageCreateManyInput | CharacterImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterImage update
   */
  export type CharacterImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterImage.
     */
    data: XOR<CharacterImageUpdateInput, CharacterImageUncheckedUpdateInput>
    /**
     * Choose, which CharacterImage to update.
     */
    where: CharacterImageWhereUniqueInput
  }

  /**
   * CharacterImage updateMany
   */
  export type CharacterImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterImages.
     */
    data: XOR<CharacterImageUpdateManyMutationInput, CharacterImageUncheckedUpdateManyInput>
    /**
     * Filter which CharacterImages to update
     */
    where?: CharacterImageWhereInput
    /**
     * Limit how many CharacterImages to update.
     */
    limit?: number
  }

  /**
   * CharacterImage updateManyAndReturn
   */
  export type CharacterImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * The data used to update CharacterImages.
     */
    data: XOR<CharacterImageUpdateManyMutationInput, CharacterImageUncheckedUpdateManyInput>
    /**
     * Filter which CharacterImages to update
     */
    where?: CharacterImageWhereInput
    /**
     * Limit how many CharacterImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterImage upsert
   */
  export type CharacterImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterImage to update in case it exists.
     */
    where: CharacterImageWhereUniqueInput
    /**
     * In case the CharacterImage found by the `where` argument doesn't exist, create a new CharacterImage with this data.
     */
    create: XOR<CharacterImageCreateInput, CharacterImageUncheckedCreateInput>
    /**
     * In case the CharacterImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterImageUpdateInput, CharacterImageUncheckedUpdateInput>
  }

  /**
   * CharacterImage delete
   */
  export type CharacterImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
    /**
     * Filter which CharacterImage to delete.
     */
    where: CharacterImageWhereUniqueInput
  }

  /**
   * CharacterImage deleteMany
   */
  export type CharacterImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterImages to delete
     */
    where?: CharacterImageWhereInput
    /**
     * Limit how many CharacterImages to delete.
     */
    limit?: number
  }

  /**
   * CharacterImage without action
   */
  export type CharacterImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterImage
     */
    select?: CharacterImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterImage
     */
    omit?: CharacterImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterImageInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryAvgAggregateOutputType = {
    contentVersion: number | null
  }

  export type StorySumAggregateOutputType = {
    contentVersion: number | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    synopsis: string | null
    initialText: string | null
    coverImage: string | null
    authorId: string | null
    ageRating: $Enums.AgeRating | null
    visibility: $Enums.Visibility | null
    contentVersion: number | null
    originalLanguageCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    synopsis: string | null
    initialText: string | null
    coverImage: string | null
    authorId: string | null
    ageRating: $Enums.AgeRating | null
    visibility: $Enums.Visibility | null
    contentVersion: number | null
    originalLanguageCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    title: number
    synopsis: number
    initialText: number
    coverImage: number
    objectives: number
    authorId: number
    ageRating: number
    contentTags: number
    visibility: number
    contentVersion: number
    originalLanguageCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryAvgAggregateInputType = {
    contentVersion?: true
  }

  export type StorySumAggregateInputType = {
    contentVersion?: true
  }

  export type StoryMinAggregateInputType = {
    id?: true
    title?: true
    synopsis?: true
    initialText?: true
    coverImage?: true
    authorId?: true
    ageRating?: true
    visibility?: true
    contentVersion?: true
    originalLanguageCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    title?: true
    synopsis?: true
    initialText?: true
    coverImage?: true
    authorId?: true
    ageRating?: true
    visibility?: true
    contentVersion?: true
    originalLanguageCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    title?: true
    synopsis?: true
    initialText?: true
    coverImage?: true
    objectives?: true
    authorId?: true
    ageRating?: true
    contentTags?: true
    visibility?: true
    contentVersion?: true
    originalLanguageCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _avg?: StoryAvgAggregateInputType
    _sum?: StorySumAggregateInputType
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    title: string
    synopsis: string | null
    initialText: string | null
    coverImage: string | null
    objectives: JsonValue | null
    authorId: string
    ageRating: $Enums.AgeRating
    contentTags: $Enums.ContentTag[]
    visibility: $Enums.Visibility
    contentVersion: number
    originalLanguageCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    synopsis?: boolean
    initialText?: boolean
    coverImage?: boolean
    objectives?: boolean
    authorId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    visibility?: boolean
    contentVersion?: boolean
    originalLanguageCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    characters?: boolean | Story$charactersArgs<ExtArgs>
    tags?: boolean | Story$tagsArgs<ExtArgs>
    conversations?: boolean | Story$conversationsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    synopsis?: boolean
    initialText?: boolean
    coverImage?: boolean
    objectives?: boolean
    authorId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    visibility?: boolean
    contentVersion?: boolean
    originalLanguageCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    synopsis?: boolean
    initialText?: boolean
    coverImage?: boolean
    objectives?: boolean
    authorId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    visibility?: boolean
    contentVersion?: boolean
    originalLanguageCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    title?: boolean
    synopsis?: boolean
    initialText?: boolean
    coverImage?: boolean
    objectives?: boolean
    authorId?: boolean
    ageRating?: boolean
    contentTags?: boolean
    visibility?: boolean
    contentVersion?: boolean
    originalLanguageCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "synopsis" | "initialText" | "coverImage" | "objectives" | "authorId" | "ageRating" | "contentTags" | "visibility" | "contentVersion" | "originalLanguageCode" | "createdAt" | "updatedAt", ExtArgs["result"]["story"]>
  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    characters?: boolean | Story$charactersArgs<ExtArgs>
    tags?: boolean | Story$tagsArgs<ExtArgs>
    conversations?: boolean | Story$conversationsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      synopsis: string | null
      initialText: string | null
      coverImage: string | null
      objectives: Prisma.JsonValue | null
      authorId: string
      ageRating: $Enums.AgeRating
      contentTags: $Enums.ContentTag[]
      visibility: $Enums.Visibility
      contentVersion: number
      originalLanguageCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories and returns the data updated in the database.
     * @param {StoryUpdateManyAndReturnArgs} args - Arguments to update many Stories.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characters<T extends Story$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Story$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Story$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Story$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Story$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Story$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly title: FieldRef<"Story", 'String'>
    readonly synopsis: FieldRef<"Story", 'String'>
    readonly initialText: FieldRef<"Story", 'String'>
    readonly coverImage: FieldRef<"Story", 'String'>
    readonly objectives: FieldRef<"Story", 'Json'>
    readonly authorId: FieldRef<"Story", 'String'>
    readonly ageRating: FieldRef<"Story", 'AgeRating'>
    readonly contentTags: FieldRef<"Story", 'ContentTag[]'>
    readonly visibility: FieldRef<"Story", 'Visibility'>
    readonly contentVersion: FieldRef<"Story", 'Int'>
    readonly originalLanguageCode: FieldRef<"Story", 'String'>
    readonly createdAt: FieldRef<"Story", 'DateTime'>
    readonly updatedAt: FieldRef<"Story", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
  }

  /**
   * Story updateManyAndReturn
   */
  export type StoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to delete.
     */
    limit?: number
  }

  /**
   * Story.characters
   */
  export type Story$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Story.tags
   */
  export type Story$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Story.conversations
   */
  export type Story$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model Assistant
   */

  export type AggregateAssistant = {
    _count: AssistantCountAggregateOutputType | null
    _min: AssistantMinAggregateOutputType | null
    _max: AssistantMaxAggregateOutputType | null
  }

  export type AssistantMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    instructions: string | null
    defaultCharacterId: string | null
    visibility: $Enums.Visibility | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssistantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    instructions: string | null
    defaultCharacterId: string | null
    visibility: $Enums.Visibility | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssistantCountAggregateOutputType = {
    id: number
    name: number
    description: number
    instructions: number
    defaultCharacterId: number
    visibility: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssistantMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    instructions?: true
    defaultCharacterId?: true
    visibility?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssistantMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    instructions?: true
    defaultCharacterId?: true
    visibility?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssistantCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    instructions?: true
    defaultCharacterId?: true
    visibility?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssistantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assistant to aggregate.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assistants
    **/
    _count?: true | AssistantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssistantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssistantMaxAggregateInputType
  }

  export type GetAssistantAggregateType<T extends AssistantAggregateArgs> = {
        [P in keyof T & keyof AggregateAssistant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssistant[P]>
      : GetScalarType<T[P], AggregateAssistant[P]>
  }




  export type AssistantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssistantWhereInput
    orderBy?: AssistantOrderByWithAggregationInput | AssistantOrderByWithAggregationInput[]
    by: AssistantScalarFieldEnum[] | AssistantScalarFieldEnum
    having?: AssistantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssistantCountAggregateInputType | true
    _min?: AssistantMinAggregateInputType
    _max?: AssistantMaxAggregateInputType
  }

  export type AssistantGroupByOutputType = {
    id: string
    name: string
    description: string | null
    instructions: string
    defaultCharacterId: string | null
    visibility: $Enums.Visibility
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: AssistantCountAggregateOutputType | null
    _min: AssistantMinAggregateOutputType | null
    _max: AssistantMaxAggregateOutputType | null
  }

  type GetAssistantGroupByPayload<T extends AssistantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssistantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssistantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssistantGroupByOutputType[P]>
            : GetScalarType<T[P], AssistantGroupByOutputType[P]>
        }
      >
    >


  export type AssistantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    instructions?: boolean
    defaultCharacterId?: boolean
    visibility?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participations?: boolean | Assistant$participationsArgs<ExtArgs>
    _count?: boolean | AssistantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistant"]>

  export type AssistantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    instructions?: boolean
    defaultCharacterId?: boolean
    visibility?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistant"]>

  export type AssistantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    instructions?: boolean
    defaultCharacterId?: boolean
    visibility?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistant"]>

  export type AssistantSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    instructions?: boolean
    defaultCharacterId?: boolean
    visibility?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssistantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "instructions" | "defaultCharacterId" | "visibility" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["assistant"]>
  export type AssistantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participations?: boolean | Assistant$participationsArgs<ExtArgs>
    _count?: boolean | AssistantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssistantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssistantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultCharacter?: boolean | Assistant$defaultCharacterArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssistantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assistant"
    objects: {
      defaultCharacter: Prisma.$CharacterPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      participations: Prisma.$ConversationParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      instructions: string
      defaultCharacterId: string | null
      visibility: $Enums.Visibility
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assistant"]>
    composites: {}
  }

  type AssistantGetPayload<S extends boolean | null | undefined | AssistantDefaultArgs> = $Result.GetResult<Prisma.$AssistantPayload, S>

  type AssistantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssistantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssistantCountAggregateInputType | true
    }

  export interface AssistantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assistant'], meta: { name: 'Assistant' } }
    /**
     * Find zero or one Assistant that matches the filter.
     * @param {AssistantFindUniqueArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssistantFindUniqueArgs>(args: SelectSubset<T, AssistantFindUniqueArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assistant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssistantFindUniqueOrThrowArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssistantFindUniqueOrThrowArgs>(args: SelectSubset<T, AssistantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assistant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindFirstArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssistantFindFirstArgs>(args?: SelectSubset<T, AssistantFindFirstArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assistant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindFirstOrThrowArgs} args - Arguments to find a Assistant
     * @example
     * // Get one Assistant
     * const assistant = await prisma.assistant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssistantFindFirstOrThrowArgs>(args?: SelectSubset<T, AssistantFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assistants
     * const assistants = await prisma.assistant.findMany()
     * 
     * // Get first 10 Assistants
     * const assistants = await prisma.assistant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assistantWithIdOnly = await prisma.assistant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssistantFindManyArgs>(args?: SelectSubset<T, AssistantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assistant.
     * @param {AssistantCreateArgs} args - Arguments to create a Assistant.
     * @example
     * // Create one Assistant
     * const Assistant = await prisma.assistant.create({
     *   data: {
     *     // ... data to create a Assistant
     *   }
     * })
     * 
     */
    create<T extends AssistantCreateArgs>(args: SelectSubset<T, AssistantCreateArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assistants.
     * @param {AssistantCreateManyArgs} args - Arguments to create many Assistants.
     * @example
     * // Create many Assistants
     * const assistant = await prisma.assistant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssistantCreateManyArgs>(args?: SelectSubset<T, AssistantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assistants and returns the data saved in the database.
     * @param {AssistantCreateManyAndReturnArgs} args - Arguments to create many Assistants.
     * @example
     * // Create many Assistants
     * const assistant = await prisma.assistant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assistants and only return the `id`
     * const assistantWithIdOnly = await prisma.assistant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssistantCreateManyAndReturnArgs>(args?: SelectSubset<T, AssistantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assistant.
     * @param {AssistantDeleteArgs} args - Arguments to delete one Assistant.
     * @example
     * // Delete one Assistant
     * const Assistant = await prisma.assistant.delete({
     *   where: {
     *     // ... filter to delete one Assistant
     *   }
     * })
     * 
     */
    delete<T extends AssistantDeleteArgs>(args: SelectSubset<T, AssistantDeleteArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assistant.
     * @param {AssistantUpdateArgs} args - Arguments to update one Assistant.
     * @example
     * // Update one Assistant
     * const assistant = await prisma.assistant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssistantUpdateArgs>(args: SelectSubset<T, AssistantUpdateArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assistants.
     * @param {AssistantDeleteManyArgs} args - Arguments to filter Assistants to delete.
     * @example
     * // Delete a few Assistants
     * const { count } = await prisma.assistant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssistantDeleteManyArgs>(args?: SelectSubset<T, AssistantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assistants
     * const assistant = await prisma.assistant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssistantUpdateManyArgs>(args: SelectSubset<T, AssistantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assistants and returns the data updated in the database.
     * @param {AssistantUpdateManyAndReturnArgs} args - Arguments to update many Assistants.
     * @example
     * // Update many Assistants
     * const assistant = await prisma.assistant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assistants and only return the `id`
     * const assistantWithIdOnly = await prisma.assistant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssistantUpdateManyAndReturnArgs>(args: SelectSubset<T, AssistantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assistant.
     * @param {AssistantUpsertArgs} args - Arguments to update or create a Assistant.
     * @example
     * // Update or create a Assistant
     * const assistant = await prisma.assistant.upsert({
     *   create: {
     *     // ... data to create a Assistant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assistant we want to update
     *   }
     * })
     */
    upsert<T extends AssistantUpsertArgs>(args: SelectSubset<T, AssistantUpsertArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantCountArgs} args - Arguments to filter Assistants to count.
     * @example
     * // Count the number of Assistants
     * const count = await prisma.assistant.count({
     *   where: {
     *     // ... the filter for the Assistants we want to count
     *   }
     * })
    **/
    count<T extends AssistantCountArgs>(
      args?: Subset<T, AssistantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssistantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssistantAggregateArgs>(args: Subset<T, AssistantAggregateArgs>): Prisma.PrismaPromise<GetAssistantAggregateType<T>>

    /**
     * Group by Assistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssistantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssistantGroupByArgs['orderBy'] }
        : { orderBy?: AssistantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssistantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssistantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assistant model
   */
  readonly fields: AssistantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assistant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssistantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultCharacter<T extends Assistant$defaultCharacterArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$defaultCharacterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participations<T extends Assistant$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Assistant$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assistant model
   */
  interface AssistantFieldRefs {
    readonly id: FieldRef<"Assistant", 'String'>
    readonly name: FieldRef<"Assistant", 'String'>
    readonly description: FieldRef<"Assistant", 'String'>
    readonly instructions: FieldRef<"Assistant", 'String'>
    readonly defaultCharacterId: FieldRef<"Assistant", 'String'>
    readonly visibility: FieldRef<"Assistant", 'Visibility'>
    readonly userId: FieldRef<"Assistant", 'String'>
    readonly createdAt: FieldRef<"Assistant", 'DateTime'>
    readonly updatedAt: FieldRef<"Assistant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assistant findUnique
   */
  export type AssistantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where: AssistantWhereUniqueInput
  }

  /**
   * Assistant findUniqueOrThrow
   */
  export type AssistantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where: AssistantWhereUniqueInput
  }

  /**
   * Assistant findFirst
   */
  export type AssistantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assistants.
     */
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }

  /**
   * Assistant findFirstOrThrow
   */
  export type AssistantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistant to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assistants.
     */
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }

  /**
   * Assistant findMany
   */
  export type AssistantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter, which Assistants to fetch.
     */
    where?: AssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assistants to fetch.
     */
    orderBy?: AssistantOrderByWithRelationInput | AssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assistants.
     */
    cursor?: AssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assistants.
     */
    skip?: number
    distinct?: AssistantScalarFieldEnum | AssistantScalarFieldEnum[]
  }

  /**
   * Assistant create
   */
  export type AssistantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The data needed to create a Assistant.
     */
    data: XOR<AssistantCreateInput, AssistantUncheckedCreateInput>
  }

  /**
   * Assistant createMany
   */
  export type AssistantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assistants.
     */
    data: AssistantCreateManyInput | AssistantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assistant createManyAndReturn
   */
  export type AssistantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * The data used to create many Assistants.
     */
    data: AssistantCreateManyInput | AssistantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assistant update
   */
  export type AssistantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The data needed to update a Assistant.
     */
    data: XOR<AssistantUpdateInput, AssistantUncheckedUpdateInput>
    /**
     * Choose, which Assistant to update.
     */
    where: AssistantWhereUniqueInput
  }

  /**
   * Assistant updateMany
   */
  export type AssistantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assistants.
     */
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyInput>
    /**
     * Filter which Assistants to update
     */
    where?: AssistantWhereInput
    /**
     * Limit how many Assistants to update.
     */
    limit?: number
  }

  /**
   * Assistant updateManyAndReturn
   */
  export type AssistantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * The data used to update Assistants.
     */
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyInput>
    /**
     * Filter which Assistants to update
     */
    where?: AssistantWhereInput
    /**
     * Limit how many Assistants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assistant upsert
   */
  export type AssistantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * The filter to search for the Assistant to update in case it exists.
     */
    where: AssistantWhereUniqueInput
    /**
     * In case the Assistant found by the `where` argument doesn't exist, create a new Assistant with this data.
     */
    create: XOR<AssistantCreateInput, AssistantUncheckedCreateInput>
    /**
     * In case the Assistant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssistantUpdateInput, AssistantUncheckedUpdateInput>
  }

  /**
   * Assistant delete
   */
  export type AssistantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    /**
     * Filter which Assistant to delete.
     */
    where: AssistantWhereUniqueInput
  }

  /**
   * Assistant deleteMany
   */
  export type AssistantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assistants to delete
     */
    where?: AssistantWhereInput
    /**
     * Limit how many Assistants to delete.
     */
    limit?: number
  }

  /**
   * Assistant.defaultCharacter
   */
  export type Assistant$defaultCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * Assistant.participations
   */
  export type Assistant$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Assistant without action
   */
  export type AssistantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    maxUsers: number | null
  }

  export type ConversationSumAggregateOutputType = {
    maxUsers: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    title: string | null
    isTitleUserEdited: boolean | null
    isTitleSystemEdited: boolean | null
    projectId: string | null
    storyId: string | null
    lastMessageAt: Date | null
    titleLastUpdatedAt: Date | null
    memoryLastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    isMultiUser: boolean | null
    maxUsers: number | null
    ownerUserId: string | null
    allowUserInvites: boolean | null
    requireApproval: boolean | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    isTitleUserEdited: boolean | null
    isTitleSystemEdited: boolean | null
    projectId: string | null
    storyId: string | null
    lastMessageAt: Date | null
    titleLastUpdatedAt: Date | null
    memoryLastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    isMultiUser: boolean | null
    maxUsers: number | null
    ownerUserId: string | null
    allowUserInvites: boolean | null
    requireApproval: boolean | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    isTitleUserEdited: number
    isTitleSystemEdited: number
    projectId: number
    storyId: number
    settings: number
    lastMessageAt: number
    titleLastUpdatedAt: number
    memoryLastUpdatedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    isMultiUser: number
    maxUsers: number
    ownerUserId: number
    allowUserInvites: number
    requireApproval: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    maxUsers?: true
  }

  export type ConversationSumAggregateInputType = {
    maxUsers?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    isTitleUserEdited?: true
    isTitleSystemEdited?: true
    projectId?: true
    storyId?: true
    lastMessageAt?: true
    titleLastUpdatedAt?: true
    memoryLastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    isMultiUser?: true
    maxUsers?: true
    ownerUserId?: true
    allowUserInvites?: true
    requireApproval?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    isTitleUserEdited?: true
    isTitleSystemEdited?: true
    projectId?: true
    storyId?: true
    lastMessageAt?: true
    titleLastUpdatedAt?: true
    memoryLastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    isMultiUser?: true
    maxUsers?: true
    ownerUserId?: true
    allowUserInvites?: true
    requireApproval?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    isTitleUserEdited?: true
    isTitleSystemEdited?: true
    projectId?: true
    storyId?: true
    settings?: true
    lastMessageAt?: true
    titleLastUpdatedAt?: true
    memoryLastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    isMultiUser?: true
    maxUsers?: true
    ownerUserId?: true
    allowUserInvites?: true
    requireApproval?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    title: string
    isTitleUserEdited: boolean
    isTitleSystemEdited: boolean
    projectId: string | null
    storyId: string | null
    settings: JsonValue | null
    lastMessageAt: Date | null
    titleLastUpdatedAt: Date | null
    memoryLastUpdatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    isMultiUser: boolean
    maxUsers: number
    ownerUserId: string | null
    allowUserInvites: boolean
    requireApproval: boolean
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: boolean
    storyId?: boolean
    settings?: boolean
    lastMessageAt?: boolean
    titleLastUpdatedAt?: boolean
    memoryLastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    isMultiUser?: boolean
    maxUsers?: boolean
    ownerUserId?: boolean
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    memories?: boolean | Conversation$memoriesArgs<ExtArgs>
    members?: boolean | Conversation$membersArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: boolean
    storyId?: boolean
    settings?: boolean
    lastMessageAt?: boolean
    titleLastUpdatedAt?: boolean
    memoryLastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    isMultiUser?: boolean
    maxUsers?: boolean
    ownerUserId?: boolean
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: boolean
    storyId?: boolean
    settings?: boolean
    lastMessageAt?: boolean
    titleLastUpdatedAt?: boolean
    memoryLastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    isMultiUser?: boolean
    maxUsers?: boolean
    ownerUserId?: boolean
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    title?: boolean
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: boolean
    storyId?: boolean
    settings?: boolean
    lastMessageAt?: boolean
    titleLastUpdatedAt?: boolean
    memoryLastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    isMultiUser?: boolean
    maxUsers?: boolean
    ownerUserId?: boolean
    allowUserInvites?: boolean
    requireApproval?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isTitleUserEdited" | "isTitleSystemEdited" | "projectId" | "storyId" | "settings" | "lastMessageAt" | "titleLastUpdatedAt" | "memoryLastUpdatedAt" | "createdAt" | "updatedAt" | "userId" | "isMultiUser" | "maxUsers" | "ownerUserId" | "allowUserInvites" | "requireApproval", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    memories?: boolean | Conversation$memoriesArgs<ExtArgs>
    members?: boolean | Conversation$membersArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | Conversation$storyArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    conversationOwner?: boolean | Conversation$conversationOwnerArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs>
      conversationOwner: Prisma.$UserPayload<ExtArgs> | null
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      memories: Prisma.$ConversationMemoryPayload<ExtArgs>[]
      members: Prisma.$UserConversationMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      isTitleUserEdited: boolean
      isTitleSystemEdited: boolean
      projectId: string | null
      storyId: string | null
      settings: Prisma.JsonValue | null
      lastMessageAt: Date | null
      titleLastUpdatedAt: Date | null
      memoryLastUpdatedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
      isMultiUser: boolean
      maxUsers: number
      ownerUserId: string | null
      allowUserInvites: boolean
      requireApproval: boolean
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends Conversation$storyArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$storyArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversationOwner<T extends Conversation$conversationOwnerArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$conversationOwnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memories<T extends Conversation$memoriesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$memoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Conversation$membersArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly isTitleUserEdited: FieldRef<"Conversation", 'Boolean'>
    readonly isTitleSystemEdited: FieldRef<"Conversation", 'Boolean'>
    readonly projectId: FieldRef<"Conversation", 'String'>
    readonly storyId: FieldRef<"Conversation", 'String'>
    readonly settings: FieldRef<"Conversation", 'Json'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly titleLastUpdatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly memoryLastUpdatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly isMultiUser: FieldRef<"Conversation", 'Boolean'>
    readonly maxUsers: FieldRef<"Conversation", 'Int'>
    readonly ownerUserId: FieldRef<"Conversation", 'String'>
    readonly allowUserInvites: FieldRef<"Conversation", 'Boolean'>
    readonly requireApproval: FieldRef<"Conversation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.story
   */
  export type Conversation$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
  }

  /**
   * Conversation.conversationOwner
   */
  export type Conversation$conversationOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.memories
   */
  export type Conversation$memoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    where?: ConversationMemoryWhereInput
    orderBy?: ConversationMemoryOrderByWithRelationInput | ConversationMemoryOrderByWithRelationInput[]
    cursor?: ConversationMemoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMemoryScalarFieldEnum | ConversationMemoryScalarFieldEnum[]
  }

  /**
   * Conversation.members
   */
  export type Conversation$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    where?: UserConversationMembershipWhereInput
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    cursor?: UserConversationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model UserConversationMembership
   */

  export type AggregateUserConversationMembership = {
    _count: UserConversationMembershipCountAggregateOutputType | null
    _min: UserConversationMembershipMinAggregateOutputType | null
    _max: UserConversationMembershipMaxAggregateOutputType | null
  }

  export type UserConversationMembershipMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    role: $Enums.MembershipRole | null
    canWrite: boolean | null
    canInvite: boolean | null
    canModerate: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
    isActive: boolean | null
  }

  export type UserConversationMembershipMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    role: $Enums.MembershipRole | null
    canWrite: boolean | null
    canInvite: boolean | null
    canModerate: boolean | null
    joinedAt: Date | null
    invitedBy: string | null
    isActive: boolean | null
  }

  export type UserConversationMembershipCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    role: number
    canWrite: number
    canInvite: number
    canModerate: number
    joinedAt: number
    invitedBy: number
    isActive: number
    _all: number
  }


  export type UserConversationMembershipMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
    canWrite?: true
    canInvite?: true
    canModerate?: true
    joinedAt?: true
    invitedBy?: true
    isActive?: true
  }

  export type UserConversationMembershipMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
    canWrite?: true
    canInvite?: true
    canModerate?: true
    joinedAt?: true
    invitedBy?: true
    isActive?: true
  }

  export type UserConversationMembershipCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
    canWrite?: true
    canInvite?: true
    canModerate?: true
    joinedAt?: true
    invitedBy?: true
    isActive?: true
    _all?: true
  }

  export type UserConversationMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConversationMembership to aggregate.
     */
    where?: UserConversationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversationMemberships to fetch.
     */
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConversationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConversationMemberships
    **/
    _count?: true | UserConversationMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConversationMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConversationMembershipMaxAggregateInputType
  }

  export type GetUserConversationMembershipAggregateType<T extends UserConversationMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConversationMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConversationMembership[P]>
      : GetScalarType<T[P], AggregateUserConversationMembership[P]>
  }




  export type UserConversationMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConversationMembershipWhereInput
    orderBy?: UserConversationMembershipOrderByWithAggregationInput | UserConversationMembershipOrderByWithAggregationInput[]
    by: UserConversationMembershipScalarFieldEnum[] | UserConversationMembershipScalarFieldEnum
    having?: UserConversationMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConversationMembershipCountAggregateInputType | true
    _min?: UserConversationMembershipMinAggregateInputType
    _max?: UserConversationMembershipMaxAggregateInputType
  }

  export type UserConversationMembershipGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    role: $Enums.MembershipRole
    canWrite: boolean
    canInvite: boolean
    canModerate: boolean
    joinedAt: Date
    invitedBy: string | null
    isActive: boolean
    _count: UserConversationMembershipCountAggregateOutputType | null
    _min: UserConversationMembershipMinAggregateOutputType | null
    _max: UserConversationMembershipMaxAggregateOutputType | null
  }

  type GetUserConversationMembershipGroupByPayload<T extends UserConversationMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConversationMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConversationMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConversationMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], UserConversationMembershipGroupByOutputType[P]>
        }
      >
    >


  export type UserConversationMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    isActive?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userConversationMembership"]>

  export type UserConversationMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    isActive?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userConversationMembership"]>

  export type UserConversationMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    isActive?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userConversationMembership"]>

  export type UserConversationMembershipSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    isActive?: boolean
  }

  export type UserConversationMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "userId" | "role" | "canWrite" | "canInvite" | "canModerate" | "joinedAt" | "invitedBy" | "isActive", ExtArgs["result"]["userConversationMembership"]>
  export type UserConversationMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }
  export type UserConversationMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }
  export type UserConversationMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    inviter?: boolean | UserConversationMembership$inviterArgs<ExtArgs>
  }

  export type $UserConversationMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConversationMembership"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      role: $Enums.MembershipRole
      canWrite: boolean
      canInvite: boolean
      canModerate: boolean
      joinedAt: Date
      invitedBy: string | null
      isActive: boolean
    }, ExtArgs["result"]["userConversationMembership"]>
    composites: {}
  }

  type UserConversationMembershipGetPayload<S extends boolean | null | undefined | UserConversationMembershipDefaultArgs> = $Result.GetResult<Prisma.$UserConversationMembershipPayload, S>

  type UserConversationMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserConversationMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserConversationMembershipCountAggregateInputType | true
    }

  export interface UserConversationMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConversationMembership'], meta: { name: 'UserConversationMembership' } }
    /**
     * Find zero or one UserConversationMembership that matches the filter.
     * @param {UserConversationMembershipFindUniqueArgs} args - Arguments to find a UserConversationMembership
     * @example
     * // Get one UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConversationMembershipFindUniqueArgs>(args: SelectSubset<T, UserConversationMembershipFindUniqueArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserConversationMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserConversationMembershipFindUniqueOrThrowArgs} args - Arguments to find a UserConversationMembership
     * @example
     * // Get one UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConversationMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConversationMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConversationMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipFindFirstArgs} args - Arguments to find a UserConversationMembership
     * @example
     * // Get one UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConversationMembershipFindFirstArgs>(args?: SelectSubset<T, UserConversationMembershipFindFirstArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConversationMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipFindFirstOrThrowArgs} args - Arguments to find a UserConversationMembership
     * @example
     * // Get one UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConversationMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConversationMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserConversationMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConversationMemberships
     * const userConversationMemberships = await prisma.userConversationMembership.findMany()
     * 
     * // Get first 10 UserConversationMemberships
     * const userConversationMemberships = await prisma.userConversationMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConversationMembershipWithIdOnly = await prisma.userConversationMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConversationMembershipFindManyArgs>(args?: SelectSubset<T, UserConversationMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserConversationMembership.
     * @param {UserConversationMembershipCreateArgs} args - Arguments to create a UserConversationMembership.
     * @example
     * // Create one UserConversationMembership
     * const UserConversationMembership = await prisma.userConversationMembership.create({
     *   data: {
     *     // ... data to create a UserConversationMembership
     *   }
     * })
     * 
     */
    create<T extends UserConversationMembershipCreateArgs>(args: SelectSubset<T, UserConversationMembershipCreateArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserConversationMemberships.
     * @param {UserConversationMembershipCreateManyArgs} args - Arguments to create many UserConversationMemberships.
     * @example
     * // Create many UserConversationMemberships
     * const userConversationMembership = await prisma.userConversationMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConversationMembershipCreateManyArgs>(args?: SelectSubset<T, UserConversationMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConversationMemberships and returns the data saved in the database.
     * @param {UserConversationMembershipCreateManyAndReturnArgs} args - Arguments to create many UserConversationMemberships.
     * @example
     * // Create many UserConversationMemberships
     * const userConversationMembership = await prisma.userConversationMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConversationMemberships and only return the `id`
     * const userConversationMembershipWithIdOnly = await prisma.userConversationMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConversationMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConversationMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserConversationMembership.
     * @param {UserConversationMembershipDeleteArgs} args - Arguments to delete one UserConversationMembership.
     * @example
     * // Delete one UserConversationMembership
     * const UserConversationMembership = await prisma.userConversationMembership.delete({
     *   where: {
     *     // ... filter to delete one UserConversationMembership
     *   }
     * })
     * 
     */
    delete<T extends UserConversationMembershipDeleteArgs>(args: SelectSubset<T, UserConversationMembershipDeleteArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserConversationMembership.
     * @param {UserConversationMembershipUpdateArgs} args - Arguments to update one UserConversationMembership.
     * @example
     * // Update one UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConversationMembershipUpdateArgs>(args: SelectSubset<T, UserConversationMembershipUpdateArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserConversationMemberships.
     * @param {UserConversationMembershipDeleteManyArgs} args - Arguments to filter UserConversationMemberships to delete.
     * @example
     * // Delete a few UserConversationMemberships
     * const { count } = await prisma.userConversationMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConversationMembershipDeleteManyArgs>(args?: SelectSubset<T, UserConversationMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConversationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConversationMemberships
     * const userConversationMembership = await prisma.userConversationMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConversationMembershipUpdateManyArgs>(args: SelectSubset<T, UserConversationMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConversationMemberships and returns the data updated in the database.
     * @param {UserConversationMembershipUpdateManyAndReturnArgs} args - Arguments to update many UserConversationMemberships.
     * @example
     * // Update many UserConversationMemberships
     * const userConversationMembership = await prisma.userConversationMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserConversationMemberships and only return the `id`
     * const userConversationMembershipWithIdOnly = await prisma.userConversationMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserConversationMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, UserConversationMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserConversationMembership.
     * @param {UserConversationMembershipUpsertArgs} args - Arguments to update or create a UserConversationMembership.
     * @example
     * // Update or create a UserConversationMembership
     * const userConversationMembership = await prisma.userConversationMembership.upsert({
     *   create: {
     *     // ... data to create a UserConversationMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConversationMembership we want to update
     *   }
     * })
     */
    upsert<T extends UserConversationMembershipUpsertArgs>(args: SelectSubset<T, UserConversationMembershipUpsertArgs<ExtArgs>>): Prisma__UserConversationMembershipClient<$Result.GetResult<Prisma.$UserConversationMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserConversationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipCountArgs} args - Arguments to filter UserConversationMemberships to count.
     * @example
     * // Count the number of UserConversationMemberships
     * const count = await prisma.userConversationMembership.count({
     *   where: {
     *     // ... the filter for the UserConversationMemberships we want to count
     *   }
     * })
    **/
    count<T extends UserConversationMembershipCountArgs>(
      args?: Subset<T, UserConversationMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConversationMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConversationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConversationMembershipAggregateArgs>(args: Subset<T, UserConversationMembershipAggregateArgs>): Prisma.PrismaPromise<GetUserConversationMembershipAggregateType<T>>

    /**
     * Group by UserConversationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConversationMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConversationMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConversationMembershipGroupByArgs['orderBy'] }
        : { orderBy?: UserConversationMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConversationMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConversationMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConversationMembership model
   */
  readonly fields: UserConversationMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConversationMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConversationMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserConversationMembership$inviterArgs<ExtArgs> = {}>(args?: Subset<T, UserConversationMembership$inviterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConversationMembership model
   */
  interface UserConversationMembershipFieldRefs {
    readonly id: FieldRef<"UserConversationMembership", 'String'>
    readonly conversationId: FieldRef<"UserConversationMembership", 'String'>
    readonly userId: FieldRef<"UserConversationMembership", 'String'>
    readonly role: FieldRef<"UserConversationMembership", 'MembershipRole'>
    readonly canWrite: FieldRef<"UserConversationMembership", 'Boolean'>
    readonly canInvite: FieldRef<"UserConversationMembership", 'Boolean'>
    readonly canModerate: FieldRef<"UserConversationMembership", 'Boolean'>
    readonly joinedAt: FieldRef<"UserConversationMembership", 'DateTime'>
    readonly invitedBy: FieldRef<"UserConversationMembership", 'String'>
    readonly isActive: FieldRef<"UserConversationMembership", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserConversationMembership findUnique
   */
  export type UserConversationMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which UserConversationMembership to fetch.
     */
    where: UserConversationMembershipWhereUniqueInput
  }

  /**
   * UserConversationMembership findUniqueOrThrow
   */
  export type UserConversationMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which UserConversationMembership to fetch.
     */
    where: UserConversationMembershipWhereUniqueInput
  }

  /**
   * UserConversationMembership findFirst
   */
  export type UserConversationMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which UserConversationMembership to fetch.
     */
    where?: UserConversationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversationMemberships to fetch.
     */
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConversationMemberships.
     */
    cursor?: UserConversationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConversationMemberships.
     */
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * UserConversationMembership findFirstOrThrow
   */
  export type UserConversationMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which UserConversationMembership to fetch.
     */
    where?: UserConversationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversationMemberships to fetch.
     */
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConversationMemberships.
     */
    cursor?: UserConversationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConversationMemberships.
     */
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * UserConversationMembership findMany
   */
  export type UserConversationMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which UserConversationMemberships to fetch.
     */
    where?: UserConversationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConversationMemberships to fetch.
     */
    orderBy?: UserConversationMembershipOrderByWithRelationInput | UserConversationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConversationMemberships.
     */
    cursor?: UserConversationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConversationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConversationMemberships.
     */
    skip?: number
    distinct?: UserConversationMembershipScalarFieldEnum | UserConversationMembershipScalarFieldEnum[]
  }

  /**
   * UserConversationMembership create
   */
  export type UserConversationMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConversationMembership.
     */
    data: XOR<UserConversationMembershipCreateInput, UserConversationMembershipUncheckedCreateInput>
  }

  /**
   * UserConversationMembership createMany
   */
  export type UserConversationMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConversationMemberships.
     */
    data: UserConversationMembershipCreateManyInput | UserConversationMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConversationMembership createManyAndReturn
   */
  export type UserConversationMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many UserConversationMemberships.
     */
    data: UserConversationMembershipCreateManyInput | UserConversationMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConversationMembership update
   */
  export type UserConversationMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConversationMembership.
     */
    data: XOR<UserConversationMembershipUpdateInput, UserConversationMembershipUncheckedUpdateInput>
    /**
     * Choose, which UserConversationMembership to update.
     */
    where: UserConversationMembershipWhereUniqueInput
  }

  /**
   * UserConversationMembership updateMany
   */
  export type UserConversationMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConversationMemberships.
     */
    data: XOR<UserConversationMembershipUpdateManyMutationInput, UserConversationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which UserConversationMemberships to update
     */
    where?: UserConversationMembershipWhereInput
    /**
     * Limit how many UserConversationMemberships to update.
     */
    limit?: number
  }

  /**
   * UserConversationMembership updateManyAndReturn
   */
  export type UserConversationMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * The data used to update UserConversationMemberships.
     */
    data: XOR<UserConversationMembershipUpdateManyMutationInput, UserConversationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which UserConversationMemberships to update
     */
    where?: UserConversationMembershipWhereInput
    /**
     * Limit how many UserConversationMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConversationMembership upsert
   */
  export type UserConversationMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConversationMembership to update in case it exists.
     */
    where: UserConversationMembershipWhereUniqueInput
    /**
     * In case the UserConversationMembership found by the `where` argument doesn't exist, create a new UserConversationMembership with this data.
     */
    create: XOR<UserConversationMembershipCreateInput, UserConversationMembershipUncheckedCreateInput>
    /**
     * In case the UserConversationMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConversationMembershipUpdateInput, UserConversationMembershipUncheckedUpdateInput>
  }

  /**
   * UserConversationMembership delete
   */
  export type UserConversationMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
    /**
     * Filter which UserConversationMembership to delete.
     */
    where: UserConversationMembershipWhereUniqueInput
  }

  /**
   * UserConversationMembership deleteMany
   */
  export type UserConversationMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConversationMemberships to delete
     */
    where?: UserConversationMembershipWhereInput
    /**
     * Limit how many UserConversationMemberships to delete.
     */
    limit?: number
  }

  /**
   * UserConversationMembership.inviter
   */
  export type UserConversationMembership$inviterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserConversationMembership without action
   */
  export type UserConversationMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConversationMembership
     */
    select?: UserConversationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConversationMembership
     */
    omit?: UserConversationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConversationMembershipInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    actingCharacterId: string | null
    actingAssistantId: string | null
    representingCharacterId: string | null
    configOverride: string | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    actingCharacterId: string | null
    actingAssistantId: string | null
    representingCharacterId: string | null
    configOverride: string | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    actingCharacterId: number
    actingAssistantId: number
    representingCharacterId: number
    configOverride: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    actingCharacterId?: true
    actingAssistantId?: true
    representingCharacterId?: true
    configOverride?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    actingCharacterId?: true
    actingAssistantId?: true
    representingCharacterId?: true
    configOverride?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    actingCharacterId?: true
    actingAssistantId?: true
    representingCharacterId?: true
    configOverride?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    userId: string | null
    actingCharacterId: string | null
    actingAssistantId: string | null
    representingCharacterId: string | null
    configOverride: string | null
    joinedAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    actingCharacterId?: boolean
    actingAssistantId?: boolean
    representingCharacterId?: boolean
    configOverride?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    actingCharacterId?: boolean
    actingAssistantId?: boolean
    representingCharacterId?: boolean
    configOverride?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    actingCharacterId?: boolean
    actingAssistantId?: boolean
    representingCharacterId?: boolean
    configOverride?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    actingCharacterId?: boolean
    actingAssistantId?: boolean
    representingCharacterId?: boolean
    configOverride?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "userId" | "actingCharacterId" | "actingAssistantId" | "representingCharacterId" | "configOverride" | "joinedAt", ExtArgs["result"]["conversationParticipant"]>
  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | ConversationParticipant$userArgs<ExtArgs>
    actingCharacter?: boolean | ConversationParticipant$actingCharacterArgs<ExtArgs>
    actingAssistant?: boolean | ConversationParticipant$actingAssistantArgs<ExtArgs>
    representingCharacter?: boolean | ConversationParticipant$representingCharacterArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      actingCharacter: Prisma.$CharacterPayload<ExtArgs> | null
      actingAssistant: Prisma.$AssistantPayload<ExtArgs> | null
      representingCharacter: Prisma.$CharacterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string | null
      actingCharacterId: string | null
      actingAssistantId: string | null
      representingCharacterId: string | null
      configOverride: string | null
      joinedAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants and returns the data updated in the database.
     * @param {ConversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many ConversationParticipants.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ConversationParticipant$userArgs<ExtArgs> = {}>(args?: Subset<T, ConversationParticipant$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actingCharacter<T extends ConversationParticipant$actingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, ConversationParticipant$actingCharacterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actingAssistant<T extends ConversationParticipant$actingAssistantArgs<ExtArgs> = {}>(args?: Subset<T, ConversationParticipant$actingAssistantArgs<ExtArgs>>): Prisma__AssistantClient<$Result.GetResult<Prisma.$AssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    representingCharacter<T extends ConversationParticipant$representingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, ConversationParticipant$representingCharacterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */
  interface ConversationParticipantFieldRefs {
    readonly id: FieldRef<"ConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly userId: FieldRef<"ConversationParticipant", 'String'>
    readonly actingCharacterId: FieldRef<"ConversationParticipant", 'String'>
    readonly actingAssistantId: FieldRef<"ConversationParticipant", 'String'>
    readonly representingCharacterId: FieldRef<"ConversationParticipant", 'String'>
    readonly configOverride: FieldRef<"ConversationParticipant", 'String'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
  }

  /**
   * ConversationParticipant updateManyAndReturn
   */
  export type ConversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * ConversationParticipant.user
   */
  export type ConversationParticipant$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ConversationParticipant.actingCharacter
   */
  export type ConversationParticipant$actingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * ConversationParticipant.actingAssistant
   */
  export type ConversationParticipant$actingAssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assistant
     */
    select?: AssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assistant
     */
    omit?: AssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssistantInclude<ExtArgs> | null
    where?: AssistantWhereInput
  }

  /**
   * ConversationParticipant.representingCharacter
   */
  export type ConversationParticipant$representingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    content: string | null
    attachments: string | null
    timestamp: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    content: string | null
    attachments: string | null
    timestamp: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    senderType: number
    content: number
    attachments: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    senderType?: true
    content?: true
    attachments?: true
    timestamp?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    senderType?: true
    content?: true
    attachments?: true
    timestamp?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    senderType?: true
    content?: true
    attachments?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "senderType" | "content" | "attachments" | "metadata" | "timestamp", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      senderType: $Enums.SenderType
      content: string
      attachments: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderType: FieldRef<"Message", 'SenderType'>
    readonly content: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteCharacter
   */

  export type AggregateFavoriteCharacter = {
    _count: FavoriteCharacterCountAggregateOutputType | null
    _min: FavoriteCharacterMinAggregateOutputType | null
    _max: FavoriteCharacterMaxAggregateOutputType | null
  }

  export type FavoriteCharacterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    characterId: string | null
    createdAt: Date | null
  }

  export type FavoriteCharacterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    characterId: string | null
    createdAt: Date | null
  }

  export type FavoriteCharacterCountAggregateOutputType = {
    id: number
    userId: number
    characterId: number
    createdAt: number
    _all: number
  }


  export type FavoriteCharacterMinAggregateInputType = {
    id?: true
    userId?: true
    characterId?: true
    createdAt?: true
  }

  export type FavoriteCharacterMaxAggregateInputType = {
    id?: true
    userId?: true
    characterId?: true
    createdAt?: true
  }

  export type FavoriteCharacterCountAggregateInputType = {
    id?: true
    userId?: true
    characterId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteCharacter to aggregate.
     */
    where?: FavoriteCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteCharacters to fetch.
     */
    orderBy?: FavoriteCharacterOrderByWithRelationInput | FavoriteCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteCharacters
    **/
    _count?: true | FavoriteCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteCharacterMaxAggregateInputType
  }

  export type GetFavoriteCharacterAggregateType<T extends FavoriteCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteCharacter[P]>
      : GetScalarType<T[P], AggregateFavoriteCharacter[P]>
  }




  export type FavoriteCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteCharacterWhereInput
    orderBy?: FavoriteCharacterOrderByWithAggregationInput | FavoriteCharacterOrderByWithAggregationInput[]
    by: FavoriteCharacterScalarFieldEnum[] | FavoriteCharacterScalarFieldEnum
    having?: FavoriteCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCharacterCountAggregateInputType | true
    _min?: FavoriteCharacterMinAggregateInputType
    _max?: FavoriteCharacterMaxAggregateInputType
  }

  export type FavoriteCharacterGroupByOutputType = {
    id: string
    userId: string
    characterId: string
    createdAt: Date
    _count: FavoriteCharacterCountAggregateOutputType | null
    _min: FavoriteCharacterMinAggregateOutputType | null
    _max: FavoriteCharacterMaxAggregateOutputType | null
  }

  type GetFavoriteCharacterGroupByPayload<T extends FavoriteCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteCharacterGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteCharacter"]>

  export type FavoriteCharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteCharacter"]>

  export type FavoriteCharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteCharacter"]>

  export type FavoriteCharacterSelectScalar = {
    id?: boolean
    userId?: boolean
    characterId?: boolean
    createdAt?: boolean
  }

  export type FavoriteCharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "characterId" | "createdAt", ExtArgs["result"]["favoriteCharacter"]>
  export type FavoriteCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteCharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteCharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FavoriteCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteCharacter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      characterId: string
      createdAt: Date
    }, ExtArgs["result"]["favoriteCharacter"]>
    composites: {}
  }

  type FavoriteCharacterGetPayload<S extends boolean | null | undefined | FavoriteCharacterDefaultArgs> = $Result.GetResult<Prisma.$FavoriteCharacterPayload, S>

  type FavoriteCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteCharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCharacterCountAggregateInputType | true
    }

  export interface FavoriteCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteCharacter'], meta: { name: 'FavoriteCharacter' } }
    /**
     * Find zero or one FavoriteCharacter that matches the filter.
     * @param {FavoriteCharacterFindUniqueArgs} args - Arguments to find a FavoriteCharacter
     * @example
     * // Get one FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteCharacterFindUniqueArgs>(args: SelectSubset<T, FavoriteCharacterFindUniqueArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FavoriteCharacter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteCharacterFindUniqueOrThrowArgs} args - Arguments to find a FavoriteCharacter
     * @example
     * // Get one FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteCharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteCharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterFindFirstArgs} args - Arguments to find a FavoriteCharacter
     * @example
     * // Get one FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteCharacterFindFirstArgs>(args?: SelectSubset<T, FavoriteCharacterFindFirstArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterFindFirstOrThrowArgs} args - Arguments to find a FavoriteCharacter
     * @example
     * // Get one FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteCharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteCharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FavoriteCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteCharacters
     * const favoriteCharacters = await prisma.favoriteCharacter.findMany()
     * 
     * // Get first 10 FavoriteCharacters
     * const favoriteCharacters = await prisma.favoriteCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteCharacterWithIdOnly = await prisma.favoriteCharacter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteCharacterFindManyArgs>(args?: SelectSubset<T, FavoriteCharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FavoriteCharacter.
     * @param {FavoriteCharacterCreateArgs} args - Arguments to create a FavoriteCharacter.
     * @example
     * // Create one FavoriteCharacter
     * const FavoriteCharacter = await prisma.favoriteCharacter.create({
     *   data: {
     *     // ... data to create a FavoriteCharacter
     *   }
     * })
     * 
     */
    create<T extends FavoriteCharacterCreateArgs>(args: SelectSubset<T, FavoriteCharacterCreateArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FavoriteCharacters.
     * @param {FavoriteCharacterCreateManyArgs} args - Arguments to create many FavoriteCharacters.
     * @example
     * // Create many FavoriteCharacters
     * const favoriteCharacter = await prisma.favoriteCharacter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCharacterCreateManyArgs>(args?: SelectSubset<T, FavoriteCharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteCharacters and returns the data saved in the database.
     * @param {FavoriteCharacterCreateManyAndReturnArgs} args - Arguments to create many FavoriteCharacters.
     * @example
     * // Create many FavoriteCharacters
     * const favoriteCharacter = await prisma.favoriteCharacter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteCharacters and only return the `id`
     * const favoriteCharacterWithIdOnly = await prisma.favoriteCharacter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FavoriteCharacter.
     * @param {FavoriteCharacterDeleteArgs} args - Arguments to delete one FavoriteCharacter.
     * @example
     * // Delete one FavoriteCharacter
     * const FavoriteCharacter = await prisma.favoriteCharacter.delete({
     *   where: {
     *     // ... filter to delete one FavoriteCharacter
     *   }
     * })
     * 
     */
    delete<T extends FavoriteCharacterDeleteArgs>(args: SelectSubset<T, FavoriteCharacterDeleteArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FavoriteCharacter.
     * @param {FavoriteCharacterUpdateArgs} args - Arguments to update one FavoriteCharacter.
     * @example
     * // Update one FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteCharacterUpdateArgs>(args: SelectSubset<T, FavoriteCharacterUpdateArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FavoriteCharacters.
     * @param {FavoriteCharacterDeleteManyArgs} args - Arguments to filter FavoriteCharacters to delete.
     * @example
     * // Delete a few FavoriteCharacters
     * const { count } = await prisma.favoriteCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteCharacterDeleteManyArgs>(args?: SelectSubset<T, FavoriteCharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteCharacters
     * const favoriteCharacter = await prisma.favoriteCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteCharacterUpdateManyArgs>(args: SelectSubset<T, FavoriteCharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteCharacters and returns the data updated in the database.
     * @param {FavoriteCharacterUpdateManyAndReturnArgs} args - Arguments to update many FavoriteCharacters.
     * @example
     * // Update many FavoriteCharacters
     * const favoriteCharacter = await prisma.favoriteCharacter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FavoriteCharacters and only return the `id`
     * const favoriteCharacterWithIdOnly = await prisma.favoriteCharacter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteCharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteCharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FavoriteCharacter.
     * @param {FavoriteCharacterUpsertArgs} args - Arguments to update or create a FavoriteCharacter.
     * @example
     * // Update or create a FavoriteCharacter
     * const favoriteCharacter = await prisma.favoriteCharacter.upsert({
     *   create: {
     *     // ... data to create a FavoriteCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteCharacter we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteCharacterUpsertArgs>(args: SelectSubset<T, FavoriteCharacterUpsertArgs<ExtArgs>>): Prisma__FavoriteCharacterClient<$Result.GetResult<Prisma.$FavoriteCharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FavoriteCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterCountArgs} args - Arguments to filter FavoriteCharacters to count.
     * @example
     * // Count the number of FavoriteCharacters
     * const count = await prisma.favoriteCharacter.count({
     *   where: {
     *     // ... the filter for the FavoriteCharacters we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCharacterCountArgs>(
      args?: Subset<T, FavoriteCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteCharacterAggregateArgs>(args: Subset<T, FavoriteCharacterAggregateArgs>): Prisma.PrismaPromise<GetFavoriteCharacterAggregateType<T>>

    /**
     * Group by FavoriteCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteCharacterGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteCharacter model
   */
  readonly fields: FavoriteCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteCharacter model
   */
  interface FavoriteCharacterFieldRefs {
    readonly id: FieldRef<"FavoriteCharacter", 'String'>
    readonly userId: FieldRef<"FavoriteCharacter", 'String'>
    readonly characterId: FieldRef<"FavoriteCharacter", 'String'>
    readonly createdAt: FieldRef<"FavoriteCharacter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteCharacter findUnique
   */
  export type FavoriteCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteCharacter to fetch.
     */
    where: FavoriteCharacterWhereUniqueInput
  }

  /**
   * FavoriteCharacter findUniqueOrThrow
   */
  export type FavoriteCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteCharacter to fetch.
     */
    where: FavoriteCharacterWhereUniqueInput
  }

  /**
   * FavoriteCharacter findFirst
   */
  export type FavoriteCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteCharacter to fetch.
     */
    where?: FavoriteCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteCharacters to fetch.
     */
    orderBy?: FavoriteCharacterOrderByWithRelationInput | FavoriteCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteCharacters.
     */
    cursor?: FavoriteCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteCharacters.
     */
    distinct?: FavoriteCharacterScalarFieldEnum | FavoriteCharacterScalarFieldEnum[]
  }

  /**
   * FavoriteCharacter findFirstOrThrow
   */
  export type FavoriteCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteCharacter to fetch.
     */
    where?: FavoriteCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteCharacters to fetch.
     */
    orderBy?: FavoriteCharacterOrderByWithRelationInput | FavoriteCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteCharacters.
     */
    cursor?: FavoriteCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteCharacters.
     */
    distinct?: FavoriteCharacterScalarFieldEnum | FavoriteCharacterScalarFieldEnum[]
  }

  /**
   * FavoriteCharacter findMany
   */
  export type FavoriteCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteCharacters to fetch.
     */
    where?: FavoriteCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteCharacters to fetch.
     */
    orderBy?: FavoriteCharacterOrderByWithRelationInput | FavoriteCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteCharacters.
     */
    cursor?: FavoriteCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteCharacters.
     */
    skip?: number
    distinct?: FavoriteCharacterScalarFieldEnum | FavoriteCharacterScalarFieldEnum[]
  }

  /**
   * FavoriteCharacter create
   */
  export type FavoriteCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteCharacter.
     */
    data: XOR<FavoriteCharacterCreateInput, FavoriteCharacterUncheckedCreateInput>
  }

  /**
   * FavoriteCharacter createMany
   */
  export type FavoriteCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteCharacters.
     */
    data: FavoriteCharacterCreateManyInput | FavoriteCharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteCharacter createManyAndReturn
   */
  export type FavoriteCharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * The data used to create many FavoriteCharacters.
     */
    data: FavoriteCharacterCreateManyInput | FavoriteCharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteCharacter update
   */
  export type FavoriteCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteCharacter.
     */
    data: XOR<FavoriteCharacterUpdateInput, FavoriteCharacterUncheckedUpdateInput>
    /**
     * Choose, which FavoriteCharacter to update.
     */
    where: FavoriteCharacterWhereUniqueInput
  }

  /**
   * FavoriteCharacter updateMany
   */
  export type FavoriteCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteCharacters.
     */
    data: XOR<FavoriteCharacterUpdateManyMutationInput, FavoriteCharacterUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteCharacters to update
     */
    where?: FavoriteCharacterWhereInput
    /**
     * Limit how many FavoriteCharacters to update.
     */
    limit?: number
  }

  /**
   * FavoriteCharacter updateManyAndReturn
   */
  export type FavoriteCharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * The data used to update FavoriteCharacters.
     */
    data: XOR<FavoriteCharacterUpdateManyMutationInput, FavoriteCharacterUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteCharacters to update
     */
    where?: FavoriteCharacterWhereInput
    /**
     * Limit how many FavoriteCharacters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteCharacter upsert
   */
  export type FavoriteCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteCharacter to update in case it exists.
     */
    where: FavoriteCharacterWhereUniqueInput
    /**
     * In case the FavoriteCharacter found by the `where` argument doesn't exist, create a new FavoriteCharacter with this data.
     */
    create: XOR<FavoriteCharacterCreateInput, FavoriteCharacterUncheckedCreateInput>
    /**
     * In case the FavoriteCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteCharacterUpdateInput, FavoriteCharacterUncheckedUpdateInput>
  }

  /**
   * FavoriteCharacter delete
   */
  export type FavoriteCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
    /**
     * Filter which FavoriteCharacter to delete.
     */
    where: FavoriteCharacterWhereUniqueInput
  }

  /**
   * FavoriteCharacter deleteMany
   */
  export type FavoriteCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteCharacters to delete
     */
    where?: FavoriteCharacterWhereInput
    /**
     * Limit how many FavoriteCharacters to delete.
     */
    limit?: number
  }

  /**
   * FavoriteCharacter without action
   */
  export type FavoriteCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteCharacter
     */
    select?: FavoriteCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteCharacter
     */
    omit?: FavoriteCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteCharacterInclude<ExtArgs> | null
  }


  /**
   * Model ContentTranslation
   */

  export type AggregateContentTranslation = {
    _count: ContentTranslationCountAggregateOutputType | null
    _avg: ContentTranslationAvgAggregateOutputType | null
    _sum: ContentTranslationSumAggregateOutputType | null
    _min: ContentTranslationMinAggregateOutputType | null
    _max: ContentTranslationMaxAggregateOutputType | null
  }

  export type ContentTranslationAvgAggregateOutputType = {
    confidence: number | null
    translationTimeMs: number | null
    characterCount: number | null
    sourceVersion: number | null
  }

  export type ContentTranslationSumAggregateOutputType = {
    confidence: number | null
    translationTimeMs: number | null
    characterCount: number | null
    sourceVersion: number | null
  }

  export type ContentTranslationMinAggregateOutputType = {
    id: string | null
    contentType: string | null
    contentId: string | null
    fieldName: string | null
    originalLanguageCode: string | null
    targetLanguageCode: string | null
    originalText: string | null
    translatedText: string | null
    translationProvider: string | null
    translationModel: string | null
    confidence: number | null
    status: $Enums.TranslationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    translationTimeMs: number | null
    characterCount: number | null
    sourceVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentTranslationMaxAggregateOutputType = {
    id: string | null
    contentType: string | null
    contentId: string | null
    fieldName: string | null
    originalLanguageCode: string | null
    targetLanguageCode: string | null
    originalText: string | null
    translatedText: string | null
    translationProvider: string | null
    translationModel: string | null
    confidence: number | null
    status: $Enums.TranslationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    translationTimeMs: number | null
    characterCount: number | null
    sourceVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentTranslationCountAggregateOutputType = {
    id: number
    contentType: number
    contentId: number
    fieldName: number
    originalLanguageCode: number
    targetLanguageCode: number
    originalText: number
    translatedText: number
    translationProvider: number
    translationModel: number
    confidence: number
    status: number
    reviewedBy: number
    reviewedAt: number
    translationTimeMs: number
    characterCount: number
    sourceVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentTranslationAvgAggregateInputType = {
    confidence?: true
    translationTimeMs?: true
    characterCount?: true
    sourceVersion?: true
  }

  export type ContentTranslationSumAggregateInputType = {
    confidence?: true
    translationTimeMs?: true
    characterCount?: true
    sourceVersion?: true
  }

  export type ContentTranslationMinAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    fieldName?: true
    originalLanguageCode?: true
    targetLanguageCode?: true
    originalText?: true
    translatedText?: true
    translationProvider?: true
    translationModel?: true
    confidence?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    translationTimeMs?: true
    characterCount?: true
    sourceVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentTranslationMaxAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    fieldName?: true
    originalLanguageCode?: true
    targetLanguageCode?: true
    originalText?: true
    translatedText?: true
    translationProvider?: true
    translationModel?: true
    confidence?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    translationTimeMs?: true
    characterCount?: true
    sourceVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentTranslationCountAggregateInputType = {
    id?: true
    contentType?: true
    contentId?: true
    fieldName?: true
    originalLanguageCode?: true
    targetLanguageCode?: true
    originalText?: true
    translatedText?: true
    translationProvider?: true
    translationModel?: true
    confidence?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    translationTimeMs?: true
    characterCount?: true
    sourceVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTranslation to aggregate.
     */
    where?: ContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTranslations to fetch.
     */
    orderBy?: ContentTranslationOrderByWithRelationInput | ContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTranslations
    **/
    _count?: true | ContentTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTranslationMaxAggregateInputType
  }

  export type GetContentTranslationAggregateType<T extends ContentTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateContentTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentTranslation[P]>
      : GetScalarType<T[P], AggregateContentTranslation[P]>
  }




  export type ContentTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTranslationWhereInput
    orderBy?: ContentTranslationOrderByWithAggregationInput | ContentTranslationOrderByWithAggregationInput[]
    by: ContentTranslationScalarFieldEnum[] | ContentTranslationScalarFieldEnum
    having?: ContentTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTranslationCountAggregateInputType | true
    _avg?: ContentTranslationAvgAggregateInputType
    _sum?: ContentTranslationSumAggregateInputType
    _min?: ContentTranslationMinAggregateInputType
    _max?: ContentTranslationMaxAggregateInputType
  }

  export type ContentTranslationGroupByOutputType = {
    id: string
    contentType: string
    contentId: string
    fieldName: string
    originalLanguageCode: string
    targetLanguageCode: string
    originalText: string
    translatedText: string
    translationProvider: string | null
    translationModel: string | null
    confidence: number | null
    status: $Enums.TranslationStatus
    reviewedBy: string | null
    reviewedAt: Date | null
    translationTimeMs: number | null
    characterCount: number | null
    sourceVersion: number
    createdAt: Date
    updatedAt: Date
    _count: ContentTranslationCountAggregateOutputType | null
    _avg: ContentTranslationAvgAggregateOutputType | null
    _sum: ContentTranslationSumAggregateOutputType | null
    _min: ContentTranslationMinAggregateOutputType | null
    _max: ContentTranslationMaxAggregateOutputType | null
  }

  type GetContentTranslationGroupByPayload<T extends ContentTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ContentTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    fieldName?: boolean
    originalLanguageCode?: boolean
    targetLanguageCode?: boolean
    originalText?: boolean
    translatedText?: boolean
    translationProvider?: boolean
    translationModel?: boolean
    confidence?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    translationTimeMs?: boolean
    characterCount?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentTranslation"]>

  export type ContentTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    fieldName?: boolean
    originalLanguageCode?: boolean
    targetLanguageCode?: boolean
    originalText?: boolean
    translatedText?: boolean
    translationProvider?: boolean
    translationModel?: boolean
    confidence?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    translationTimeMs?: boolean
    characterCount?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentTranslation"]>

  export type ContentTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    fieldName?: boolean
    originalLanguageCode?: boolean
    targetLanguageCode?: boolean
    originalText?: boolean
    translatedText?: boolean
    translationProvider?: boolean
    translationModel?: boolean
    confidence?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    translationTimeMs?: boolean
    characterCount?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentTranslation"]>

  export type ContentTranslationSelectScalar = {
    id?: boolean
    contentType?: boolean
    contentId?: boolean
    fieldName?: boolean
    originalLanguageCode?: boolean
    targetLanguageCode?: boolean
    originalText?: boolean
    translatedText?: boolean
    translationProvider?: boolean
    translationModel?: boolean
    confidence?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    translationTimeMs?: boolean
    characterCount?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentType" | "contentId" | "fieldName" | "originalLanguageCode" | "targetLanguageCode" | "originalText" | "translatedText" | "translationProvider" | "translationModel" | "confidence" | "status" | "reviewedBy" | "reviewedAt" | "translationTimeMs" | "characterCount" | "sourceVersion" | "createdAt" | "updatedAt", ExtArgs["result"]["contentTranslation"]>

  export type $ContentTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentType: string
      contentId: string
      fieldName: string
      originalLanguageCode: string
      targetLanguageCode: string
      originalText: string
      translatedText: string
      translationProvider: string | null
      translationModel: string | null
      confidence: number | null
      status: $Enums.TranslationStatus
      reviewedBy: string | null
      reviewedAt: Date | null
      translationTimeMs: number | null
      characterCount: number | null
      sourceVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentTranslation"]>
    composites: {}
  }

  type ContentTranslationGetPayload<S extends boolean | null | undefined | ContentTranslationDefaultArgs> = $Result.GetResult<Prisma.$ContentTranslationPayload, S>

  type ContentTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentTranslationCountAggregateInputType | true
    }

  export interface ContentTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentTranslation'], meta: { name: 'ContentTranslation' } }
    /**
     * Find zero or one ContentTranslation that matches the filter.
     * @param {ContentTranslationFindUniqueArgs} args - Arguments to find a ContentTranslation
     * @example
     * // Get one ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTranslationFindUniqueArgs>(args: SelectSubset<T, ContentTranslationFindUniqueArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentTranslationFindUniqueOrThrowArgs} args - Arguments to find a ContentTranslation
     * @example
     * // Get one ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationFindFirstArgs} args - Arguments to find a ContentTranslation
     * @example
     * // Get one ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTranslationFindFirstArgs>(args?: SelectSubset<T, ContentTranslationFindFirstArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationFindFirstOrThrowArgs} args - Arguments to find a ContentTranslation
     * @example
     * // Get one ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTranslations
     * const contentTranslations = await prisma.contentTranslation.findMany()
     * 
     * // Get first 10 ContentTranslations
     * const contentTranslations = await prisma.contentTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentTranslationWithIdOnly = await prisma.contentTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentTranslationFindManyArgs>(args?: SelectSubset<T, ContentTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentTranslation.
     * @param {ContentTranslationCreateArgs} args - Arguments to create a ContentTranslation.
     * @example
     * // Create one ContentTranslation
     * const ContentTranslation = await prisma.contentTranslation.create({
     *   data: {
     *     // ... data to create a ContentTranslation
     *   }
     * })
     * 
     */
    create<T extends ContentTranslationCreateArgs>(args: SelectSubset<T, ContentTranslationCreateArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentTranslations.
     * @param {ContentTranslationCreateManyArgs} args - Arguments to create many ContentTranslations.
     * @example
     * // Create many ContentTranslations
     * const contentTranslation = await prisma.contentTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTranslationCreateManyArgs>(args?: SelectSubset<T, ContentTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentTranslations and returns the data saved in the database.
     * @param {ContentTranslationCreateManyAndReturnArgs} args - Arguments to create many ContentTranslations.
     * @example
     * // Create many ContentTranslations
     * const contentTranslation = await prisma.contentTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentTranslations and only return the `id`
     * const contentTranslationWithIdOnly = await prisma.contentTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentTranslation.
     * @param {ContentTranslationDeleteArgs} args - Arguments to delete one ContentTranslation.
     * @example
     * // Delete one ContentTranslation
     * const ContentTranslation = await prisma.contentTranslation.delete({
     *   where: {
     *     // ... filter to delete one ContentTranslation
     *   }
     * })
     * 
     */
    delete<T extends ContentTranslationDeleteArgs>(args: SelectSubset<T, ContentTranslationDeleteArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentTranslation.
     * @param {ContentTranslationUpdateArgs} args - Arguments to update one ContentTranslation.
     * @example
     * // Update one ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTranslationUpdateArgs>(args: SelectSubset<T, ContentTranslationUpdateArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentTranslations.
     * @param {ContentTranslationDeleteManyArgs} args - Arguments to filter ContentTranslations to delete.
     * @example
     * // Delete a few ContentTranslations
     * const { count } = await prisma.contentTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTranslationDeleteManyArgs>(args?: SelectSubset<T, ContentTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTranslations
     * const contentTranslation = await prisma.contentTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTranslationUpdateManyArgs>(args: SelectSubset<T, ContentTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTranslations and returns the data updated in the database.
     * @param {ContentTranslationUpdateManyAndReturnArgs} args - Arguments to update many ContentTranslations.
     * @example
     * // Update many ContentTranslations
     * const contentTranslation = await prisma.contentTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentTranslations and only return the `id`
     * const contentTranslationWithIdOnly = await prisma.contentTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentTranslation.
     * @param {ContentTranslationUpsertArgs} args - Arguments to update or create a ContentTranslation.
     * @example
     * // Update or create a ContentTranslation
     * const contentTranslation = await prisma.contentTranslation.upsert({
     *   create: {
     *     // ... data to create a ContentTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ContentTranslationUpsertArgs>(args: SelectSubset<T, ContentTranslationUpsertArgs<ExtArgs>>): Prisma__ContentTranslationClient<$Result.GetResult<Prisma.$ContentTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationCountArgs} args - Arguments to filter ContentTranslations to count.
     * @example
     * // Count the number of ContentTranslations
     * const count = await prisma.contentTranslation.count({
     *   where: {
     *     // ... the filter for the ContentTranslations we want to count
     *   }
     * })
    **/
    count<T extends ContentTranslationCountArgs>(
      args?: Subset<T, ContentTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTranslationAggregateArgs>(args: Subset<T, ContentTranslationAggregateArgs>): Prisma.PrismaPromise<GetContentTranslationAggregateType<T>>

    /**
     * Group by ContentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ContentTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentTranslation model
   */
  readonly fields: ContentTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentTranslation model
   */
  interface ContentTranslationFieldRefs {
    readonly id: FieldRef<"ContentTranslation", 'String'>
    readonly contentType: FieldRef<"ContentTranslation", 'String'>
    readonly contentId: FieldRef<"ContentTranslation", 'String'>
    readonly fieldName: FieldRef<"ContentTranslation", 'String'>
    readonly originalLanguageCode: FieldRef<"ContentTranslation", 'String'>
    readonly targetLanguageCode: FieldRef<"ContentTranslation", 'String'>
    readonly originalText: FieldRef<"ContentTranslation", 'String'>
    readonly translatedText: FieldRef<"ContentTranslation", 'String'>
    readonly translationProvider: FieldRef<"ContentTranslation", 'String'>
    readonly translationModel: FieldRef<"ContentTranslation", 'String'>
    readonly confidence: FieldRef<"ContentTranslation", 'Float'>
    readonly status: FieldRef<"ContentTranslation", 'TranslationStatus'>
    readonly reviewedBy: FieldRef<"ContentTranslation", 'String'>
    readonly reviewedAt: FieldRef<"ContentTranslation", 'DateTime'>
    readonly translationTimeMs: FieldRef<"ContentTranslation", 'Int'>
    readonly characterCount: FieldRef<"ContentTranslation", 'Int'>
    readonly sourceVersion: FieldRef<"ContentTranslation", 'Int'>
    readonly createdAt: FieldRef<"ContentTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentTranslation findUnique
   */
  export type ContentTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which ContentTranslation to fetch.
     */
    where: ContentTranslationWhereUniqueInput
  }

  /**
   * ContentTranslation findUniqueOrThrow
   */
  export type ContentTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which ContentTranslation to fetch.
     */
    where: ContentTranslationWhereUniqueInput
  }

  /**
   * ContentTranslation findFirst
   */
  export type ContentTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which ContentTranslation to fetch.
     */
    where?: ContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTranslations to fetch.
     */
    orderBy?: ContentTranslationOrderByWithRelationInput | ContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTranslations.
     */
    cursor?: ContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTranslations.
     */
    distinct?: ContentTranslationScalarFieldEnum | ContentTranslationScalarFieldEnum[]
  }

  /**
   * ContentTranslation findFirstOrThrow
   */
  export type ContentTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which ContentTranslation to fetch.
     */
    where?: ContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTranslations to fetch.
     */
    orderBy?: ContentTranslationOrderByWithRelationInput | ContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTranslations.
     */
    cursor?: ContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTranslations.
     */
    distinct?: ContentTranslationScalarFieldEnum | ContentTranslationScalarFieldEnum[]
  }

  /**
   * ContentTranslation findMany
   */
  export type ContentTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which ContentTranslations to fetch.
     */
    where?: ContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTranslations to fetch.
     */
    orderBy?: ContentTranslationOrderByWithRelationInput | ContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTranslations.
     */
    cursor?: ContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTranslations.
     */
    skip?: number
    distinct?: ContentTranslationScalarFieldEnum | ContentTranslationScalarFieldEnum[]
  }

  /**
   * ContentTranslation create
   */
  export type ContentTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a ContentTranslation.
     */
    data: XOR<ContentTranslationCreateInput, ContentTranslationUncheckedCreateInput>
  }

  /**
   * ContentTranslation createMany
   */
  export type ContentTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTranslations.
     */
    data: ContentTranslationCreateManyInput | ContentTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentTranslation createManyAndReturn
   */
  export type ContentTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ContentTranslations.
     */
    data: ContentTranslationCreateManyInput | ContentTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentTranslation update
   */
  export type ContentTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a ContentTranslation.
     */
    data: XOR<ContentTranslationUpdateInput, ContentTranslationUncheckedUpdateInput>
    /**
     * Choose, which ContentTranslation to update.
     */
    where: ContentTranslationWhereUniqueInput
  }

  /**
   * ContentTranslation updateMany
   */
  export type ContentTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTranslations.
     */
    data: XOR<ContentTranslationUpdateManyMutationInput, ContentTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ContentTranslations to update
     */
    where?: ContentTranslationWhereInput
    /**
     * Limit how many ContentTranslations to update.
     */
    limit?: number
  }

  /**
   * ContentTranslation updateManyAndReturn
   */
  export type ContentTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ContentTranslations.
     */
    data: XOR<ContentTranslationUpdateManyMutationInput, ContentTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ContentTranslations to update
     */
    where?: ContentTranslationWhereInput
    /**
     * Limit how many ContentTranslations to update.
     */
    limit?: number
  }

  /**
   * ContentTranslation upsert
   */
  export type ContentTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the ContentTranslation to update in case it exists.
     */
    where: ContentTranslationWhereUniqueInput
    /**
     * In case the ContentTranslation found by the `where` argument doesn't exist, create a new ContentTranslation with this data.
     */
    create: XOR<ContentTranslationCreateInput, ContentTranslationUncheckedCreateInput>
    /**
     * In case the ContentTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTranslationUpdateInput, ContentTranslationUncheckedUpdateInput>
  }

  /**
   * ContentTranslation delete
   */
  export type ContentTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
    /**
     * Filter which ContentTranslation to delete.
     */
    where: ContentTranslationWhereUniqueInput
  }

  /**
   * ContentTranslation deleteMany
   */
  export type ContentTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTranslations to delete
     */
    where?: ContentTranslationWhereInput
    /**
     * Limit how many ContentTranslations to delete.
     */
    limit?: number
  }

  /**
   * ContentTranslation without action
   */
  export type ContentTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTranslation
     */
    select?: ContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTranslation
     */
    omit?: ContentTranslationOmit<ExtArgs> | null
  }


  /**
   * Model ConversationMemory
   */

  export type AggregateConversationMemory = {
    _count: ConversationMemoryCountAggregateOutputType | null
    _avg: ConversationMemoryAvgAggregateOutputType | null
    _sum: ConversationMemorySumAggregateOutputType | null
    _min: ConversationMemoryMinAggregateOutputType | null
    _max: ConversationMemoryMaxAggregateOutputType | null
  }

  export type ConversationMemoryAvgAggregateOutputType = {
    messageCount: number | null
  }

  export type ConversationMemorySumAggregateOutputType = {
    messageCount: number | null
  }

  export type ConversationMemoryMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    summary: string | null
    messageCount: number | null
    startMessageId: string | null
    endMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMemoryMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    summary: string | null
    messageCount: number | null
    startMessageId: string | null
    endMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMemoryCountAggregateOutputType = {
    id: number
    conversationId: number
    summary: number
    keyEvents: number
    messageCount: number
    startMessageId: number
    endMessageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMemoryAvgAggregateInputType = {
    messageCount?: true
  }

  export type ConversationMemorySumAggregateInputType = {
    messageCount?: true
  }

  export type ConversationMemoryMinAggregateInputType = {
    id?: true
    conversationId?: true
    summary?: true
    messageCount?: true
    startMessageId?: true
    endMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMemoryMaxAggregateInputType = {
    id?: true
    conversationId?: true
    summary?: true
    messageCount?: true
    startMessageId?: true
    endMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMemoryCountAggregateInputType = {
    id?: true
    conversationId?: true
    summary?: true
    keyEvents?: true
    messageCount?: true
    startMessageId?: true
    endMessageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationMemoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMemory to aggregate.
     */
    where?: ConversationMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMemories to fetch.
     */
    orderBy?: ConversationMemoryOrderByWithRelationInput | ConversationMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMemories
    **/
    _count?: true | ConversationMemoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationMemoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationMemorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMemoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMemoryMaxAggregateInputType
  }

  export type GetConversationMemoryAggregateType<T extends ConversationMemoryAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMemory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMemory[P]>
      : GetScalarType<T[P], AggregateConversationMemory[P]>
  }




  export type ConversationMemoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMemoryWhereInput
    orderBy?: ConversationMemoryOrderByWithAggregationInput | ConversationMemoryOrderByWithAggregationInput[]
    by: ConversationMemoryScalarFieldEnum[] | ConversationMemoryScalarFieldEnum
    having?: ConversationMemoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMemoryCountAggregateInputType | true
    _avg?: ConversationMemoryAvgAggregateInputType
    _sum?: ConversationMemorySumAggregateInputType
    _min?: ConversationMemoryMinAggregateInputType
    _max?: ConversationMemoryMaxAggregateInputType
  }

  export type ConversationMemoryGroupByOutputType = {
    id: string
    conversationId: string
    summary: string
    keyEvents: JsonValue
    messageCount: number
    startMessageId: string | null
    endMessageId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationMemoryCountAggregateOutputType | null
    _avg: ConversationMemoryAvgAggregateOutputType | null
    _sum: ConversationMemorySumAggregateOutputType | null
    _min: ConversationMemoryMinAggregateOutputType | null
    _max: ConversationMemoryMaxAggregateOutputType | null
  }

  type GetConversationMemoryGroupByPayload<T extends ConversationMemoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationMemoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMemoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMemoryGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMemoryGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMemorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    summary?: boolean
    keyEvents?: boolean
    messageCount?: boolean
    startMessageId?: boolean
    endMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMemory"]>

  export type ConversationMemorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    summary?: boolean
    keyEvents?: boolean
    messageCount?: boolean
    startMessageId?: boolean
    endMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMemory"]>

  export type ConversationMemorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    summary?: boolean
    keyEvents?: boolean
    messageCount?: boolean
    startMessageId?: boolean
    endMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMemory"]>

  export type ConversationMemorySelectScalar = {
    id?: boolean
    conversationId?: boolean
    summary?: boolean
    keyEvents?: boolean
    messageCount?: boolean
    startMessageId?: boolean
    endMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationMemoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "summary" | "keyEvents" | "messageCount" | "startMessageId" | "endMessageId" | "createdAt" | "updatedAt", ExtArgs["result"]["conversationMemory"]>
  export type ConversationMemoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMemoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMemoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationMemoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationMemory"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      summary: string
      keyEvents: Prisma.JsonValue
      messageCount: number
      startMessageId: string | null
      endMessageId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversationMemory"]>
    composites: {}
  }

  type ConversationMemoryGetPayload<S extends boolean | null | undefined | ConversationMemoryDefaultArgs> = $Result.GetResult<Prisma.$ConversationMemoryPayload, S>

  type ConversationMemoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationMemoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationMemoryCountAggregateInputType | true
    }

  export interface ConversationMemoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationMemory'], meta: { name: 'ConversationMemory' } }
    /**
     * Find zero or one ConversationMemory that matches the filter.
     * @param {ConversationMemoryFindUniqueArgs} args - Arguments to find a ConversationMemory
     * @example
     * // Get one ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationMemoryFindUniqueArgs>(args: SelectSubset<T, ConversationMemoryFindUniqueArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationMemory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationMemoryFindUniqueOrThrowArgs} args - Arguments to find a ConversationMemory
     * @example
     * // Get one ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationMemoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationMemoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMemory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryFindFirstArgs} args - Arguments to find a ConversationMemory
     * @example
     * // Get one ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationMemoryFindFirstArgs>(args?: SelectSubset<T, ConversationMemoryFindFirstArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMemory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryFindFirstOrThrowArgs} args - Arguments to find a ConversationMemory
     * @example
     * // Get one ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationMemoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationMemoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationMemories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMemories
     * const conversationMemories = await prisma.conversationMemory.findMany()
     * 
     * // Get first 10 ConversationMemories
     * const conversationMemories = await prisma.conversationMemory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMemoryWithIdOnly = await prisma.conversationMemory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationMemoryFindManyArgs>(args?: SelectSubset<T, ConversationMemoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationMemory.
     * @param {ConversationMemoryCreateArgs} args - Arguments to create a ConversationMemory.
     * @example
     * // Create one ConversationMemory
     * const ConversationMemory = await prisma.conversationMemory.create({
     *   data: {
     *     // ... data to create a ConversationMemory
     *   }
     * })
     * 
     */
    create<T extends ConversationMemoryCreateArgs>(args: SelectSubset<T, ConversationMemoryCreateArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationMemories.
     * @param {ConversationMemoryCreateManyArgs} args - Arguments to create many ConversationMemories.
     * @example
     * // Create many ConversationMemories
     * const conversationMemory = await prisma.conversationMemory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationMemoryCreateManyArgs>(args?: SelectSubset<T, ConversationMemoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationMemories and returns the data saved in the database.
     * @param {ConversationMemoryCreateManyAndReturnArgs} args - Arguments to create many ConversationMemories.
     * @example
     * // Create many ConversationMemories
     * const conversationMemory = await prisma.conversationMemory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationMemories and only return the `id`
     * const conversationMemoryWithIdOnly = await prisma.conversationMemory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationMemoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationMemoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationMemory.
     * @param {ConversationMemoryDeleteArgs} args - Arguments to delete one ConversationMemory.
     * @example
     * // Delete one ConversationMemory
     * const ConversationMemory = await prisma.conversationMemory.delete({
     *   where: {
     *     // ... filter to delete one ConversationMemory
     *   }
     * })
     * 
     */
    delete<T extends ConversationMemoryDeleteArgs>(args: SelectSubset<T, ConversationMemoryDeleteArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationMemory.
     * @param {ConversationMemoryUpdateArgs} args - Arguments to update one ConversationMemory.
     * @example
     * // Update one ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationMemoryUpdateArgs>(args: SelectSubset<T, ConversationMemoryUpdateArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationMemories.
     * @param {ConversationMemoryDeleteManyArgs} args - Arguments to filter ConversationMemories to delete.
     * @example
     * // Delete a few ConversationMemories
     * const { count } = await prisma.conversationMemory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationMemoryDeleteManyArgs>(args?: SelectSubset<T, ConversationMemoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMemories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMemories
     * const conversationMemory = await prisma.conversationMemory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationMemoryUpdateManyArgs>(args: SelectSubset<T, ConversationMemoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMemories and returns the data updated in the database.
     * @param {ConversationMemoryUpdateManyAndReturnArgs} args - Arguments to update many ConversationMemories.
     * @example
     * // Update many ConversationMemories
     * const conversationMemory = await prisma.conversationMemory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationMemories and only return the `id`
     * const conversationMemoryWithIdOnly = await prisma.conversationMemory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationMemoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationMemoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationMemory.
     * @param {ConversationMemoryUpsertArgs} args - Arguments to update or create a ConversationMemory.
     * @example
     * // Update or create a ConversationMemory
     * const conversationMemory = await prisma.conversationMemory.upsert({
     *   create: {
     *     // ... data to create a ConversationMemory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMemory we want to update
     *   }
     * })
     */
    upsert<T extends ConversationMemoryUpsertArgs>(args: SelectSubset<T, ConversationMemoryUpsertArgs<ExtArgs>>): Prisma__ConversationMemoryClient<$Result.GetResult<Prisma.$ConversationMemoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationMemories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryCountArgs} args - Arguments to filter ConversationMemories to count.
     * @example
     * // Count the number of ConversationMemories
     * const count = await prisma.conversationMemory.count({
     *   where: {
     *     // ... the filter for the ConversationMemories we want to count
     *   }
     * })
    **/
    count<T extends ConversationMemoryCountArgs>(
      args?: Subset<T, ConversationMemoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMemoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMemory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMemoryAggregateArgs>(args: Subset<T, ConversationMemoryAggregateArgs>): Prisma.PrismaPromise<GetConversationMemoryAggregateType<T>>

    /**
     * Group by ConversationMemory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMemoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMemoryGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMemoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMemoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMemoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationMemory model
   */
  readonly fields: ConversationMemoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMemory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationMemoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationMemory model
   */
  interface ConversationMemoryFieldRefs {
    readonly id: FieldRef<"ConversationMemory", 'String'>
    readonly conversationId: FieldRef<"ConversationMemory", 'String'>
    readonly summary: FieldRef<"ConversationMemory", 'String'>
    readonly keyEvents: FieldRef<"ConversationMemory", 'Json'>
    readonly messageCount: FieldRef<"ConversationMemory", 'Int'>
    readonly startMessageId: FieldRef<"ConversationMemory", 'String'>
    readonly endMessageId: FieldRef<"ConversationMemory", 'String'>
    readonly createdAt: FieldRef<"ConversationMemory", 'DateTime'>
    readonly updatedAt: FieldRef<"ConversationMemory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationMemory findUnique
   */
  export type ConversationMemoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMemory to fetch.
     */
    where: ConversationMemoryWhereUniqueInput
  }

  /**
   * ConversationMemory findUniqueOrThrow
   */
  export type ConversationMemoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMemory to fetch.
     */
    where: ConversationMemoryWhereUniqueInput
  }

  /**
   * ConversationMemory findFirst
   */
  export type ConversationMemoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMemory to fetch.
     */
    where?: ConversationMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMemories to fetch.
     */
    orderBy?: ConversationMemoryOrderByWithRelationInput | ConversationMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMemories.
     */
    cursor?: ConversationMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMemories.
     */
    distinct?: ConversationMemoryScalarFieldEnum | ConversationMemoryScalarFieldEnum[]
  }

  /**
   * ConversationMemory findFirstOrThrow
   */
  export type ConversationMemoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMemory to fetch.
     */
    where?: ConversationMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMemories to fetch.
     */
    orderBy?: ConversationMemoryOrderByWithRelationInput | ConversationMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMemories.
     */
    cursor?: ConversationMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMemories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMemories.
     */
    distinct?: ConversationMemoryScalarFieldEnum | ConversationMemoryScalarFieldEnum[]
  }

  /**
   * ConversationMemory findMany
   */
  export type ConversationMemoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMemories to fetch.
     */
    where?: ConversationMemoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMemories to fetch.
     */
    orderBy?: ConversationMemoryOrderByWithRelationInput | ConversationMemoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMemories.
     */
    cursor?: ConversationMemoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMemories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMemories.
     */
    skip?: number
    distinct?: ConversationMemoryScalarFieldEnum | ConversationMemoryScalarFieldEnum[]
  }

  /**
   * ConversationMemory create
   */
  export type ConversationMemoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationMemory.
     */
    data: XOR<ConversationMemoryCreateInput, ConversationMemoryUncheckedCreateInput>
  }

  /**
   * ConversationMemory createMany
   */
  export type ConversationMemoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationMemories.
     */
    data: ConversationMemoryCreateManyInput | ConversationMemoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationMemory createManyAndReturn
   */
  export type ConversationMemoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationMemories.
     */
    data: ConversationMemoryCreateManyInput | ConversationMemoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMemory update
   */
  export type ConversationMemoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationMemory.
     */
    data: XOR<ConversationMemoryUpdateInput, ConversationMemoryUncheckedUpdateInput>
    /**
     * Choose, which ConversationMemory to update.
     */
    where: ConversationMemoryWhereUniqueInput
  }

  /**
   * ConversationMemory updateMany
   */
  export type ConversationMemoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationMemories.
     */
    data: XOR<ConversationMemoryUpdateManyMutationInput, ConversationMemoryUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMemories to update
     */
    where?: ConversationMemoryWhereInput
    /**
     * Limit how many ConversationMemories to update.
     */
    limit?: number
  }

  /**
   * ConversationMemory updateManyAndReturn
   */
  export type ConversationMemoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * The data used to update ConversationMemories.
     */
    data: XOR<ConversationMemoryUpdateManyMutationInput, ConversationMemoryUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMemories to update
     */
    where?: ConversationMemoryWhereInput
    /**
     * Limit how many ConversationMemories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMemory upsert
   */
  export type ConversationMemoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationMemory to update in case it exists.
     */
    where: ConversationMemoryWhereUniqueInput
    /**
     * In case the ConversationMemory found by the `where` argument doesn't exist, create a new ConversationMemory with this data.
     */
    create: XOR<ConversationMemoryCreateInput, ConversationMemoryUncheckedCreateInput>
    /**
     * In case the ConversationMemory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationMemoryUpdateInput, ConversationMemoryUncheckedUpdateInput>
  }

  /**
   * ConversationMemory delete
   */
  export type ConversationMemoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
    /**
     * Filter which ConversationMemory to delete.
     */
    where: ConversationMemoryWhereUniqueInput
  }

  /**
   * ConversationMemory deleteMany
   */
  export type ConversationMemoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMemories to delete
     */
    where?: ConversationMemoryWhereInput
    /**
     * Limit how many ConversationMemories to delete.
     */
    limit?: number
  }

  /**
   * ConversationMemory without action
   */
  export type ConversationMemoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMemory
     */
    select?: ConversationMemorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMemory
     */
    omit?: ConversationMemoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemoryInclude<ExtArgs> | null
  }


  /**
   * Model CreditTransaction
   */

  export type AggregateCreditTransaction = {
    _count: CreditTransactionCountAggregateOutputType | null
    _avg: CreditTransactionAvgAggregateOutputType | null
    _sum: CreditTransactionSumAggregateOutputType | null
    _min: CreditTransactionMinAggregateOutputType | null
    _max: CreditTransactionMaxAggregateOutputType | null
  }

  export type CreditTransactionAvgAggregateOutputType = {
    amountCredits: number | null
    balanceAfter: number | null
  }

  export type CreditTransactionSumAggregateOutputType = {
    amountCredits: number | null
    balanceAfter: number | null
  }

  export type CreditTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionType: $Enums.CreditTransactionType | null
    amountCredits: number | null
    balanceAfter: number | null
    notes: string | null
    relatedUsageLogId: string | null
    relatedPlanId: string | null
    timestamp: Date | null
  }

  export type CreditTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionType: $Enums.CreditTransactionType | null
    amountCredits: number | null
    balanceAfter: number | null
    notes: string | null
    relatedUsageLogId: string | null
    relatedPlanId: string | null
    timestamp: Date | null
  }

  export type CreditTransactionCountAggregateOutputType = {
    id: number
    userId: number
    transactionType: number
    amountCredits: number
    balanceAfter: number
    notes: number
    relatedUsageLogId: number
    relatedPlanId: number
    timestamp: number
    _all: number
  }


  export type CreditTransactionAvgAggregateInputType = {
    amountCredits?: true
    balanceAfter?: true
  }

  export type CreditTransactionSumAggregateInputType = {
    amountCredits?: true
    balanceAfter?: true
  }

  export type CreditTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amountCredits?: true
    balanceAfter?: true
    notes?: true
    relatedUsageLogId?: true
    relatedPlanId?: true
    timestamp?: true
  }

  export type CreditTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amountCredits?: true
    balanceAfter?: true
    notes?: true
    relatedUsageLogId?: true
    relatedPlanId?: true
    timestamp?: true
  }

  export type CreditTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amountCredits?: true
    balanceAfter?: true
    notes?: true
    relatedUsageLogId?: true
    relatedPlanId?: true
    timestamp?: true
    _all?: true
  }

  export type CreditTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTransaction to aggregate.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTransactions
    **/
    _count?: true | CreditTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTransactionMaxAggregateInputType
  }

  export type GetCreditTransactionAggregateType<T extends CreditTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTransaction[P]>
      : GetScalarType<T[P], AggregateCreditTransaction[P]>
  }




  export type CreditTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTransactionWhereInput
    orderBy?: CreditTransactionOrderByWithAggregationInput | CreditTransactionOrderByWithAggregationInput[]
    by: CreditTransactionScalarFieldEnum[] | CreditTransactionScalarFieldEnum
    having?: CreditTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTransactionCountAggregateInputType | true
    _avg?: CreditTransactionAvgAggregateInputType
    _sum?: CreditTransactionSumAggregateInputType
    _min?: CreditTransactionMinAggregateInputType
    _max?: CreditTransactionMaxAggregateInputType
  }

  export type CreditTransactionGroupByOutputType = {
    id: string
    userId: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter: number | null
    notes: string | null
    relatedUsageLogId: string | null
    relatedPlanId: string | null
    timestamp: Date
    _count: CreditTransactionCountAggregateOutputType | null
    _avg: CreditTransactionAvgAggregateOutputType | null
    _sum: CreditTransactionSumAggregateOutputType | null
    _min: CreditTransactionMinAggregateOutputType | null
    _max: CreditTransactionMaxAggregateOutputType | null
  }

  type GetCreditTransactionGroupByPayload<T extends CreditTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CreditTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amountCredits?: boolean
    balanceAfter?: boolean
    notes?: boolean
    relatedUsageLogId?: boolean
    relatedPlanId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amountCredits?: boolean
    balanceAfter?: boolean
    notes?: boolean
    relatedUsageLogId?: boolean
    relatedPlanId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amountCredits?: boolean
    balanceAfter?: boolean
    notes?: boolean
    relatedUsageLogId?: boolean
    relatedPlanId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amountCredits?: boolean
    balanceAfter?: boolean
    notes?: boolean
    relatedUsageLogId?: boolean
    relatedPlanId?: boolean
    timestamp?: boolean
  }

  export type CreditTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionType" | "amountCredits" | "balanceAfter" | "notes" | "relatedUsageLogId" | "relatedPlanId" | "timestamp", ExtArgs["result"]["creditTransaction"]>
  export type CreditTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      transactionType: $Enums.CreditTransactionType
      amountCredits: number
      balanceAfter: number | null
      notes: string | null
      relatedUsageLogId: string | null
      relatedPlanId: string | null
      timestamp: Date
    }, ExtArgs["result"]["creditTransaction"]>
    composites: {}
  }

  type CreditTransactionGetPayload<S extends boolean | null | undefined | CreditTransactionDefaultArgs> = $Result.GetResult<Prisma.$CreditTransactionPayload, S>

  type CreditTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTransactionCountAggregateInputType | true
    }

  export interface CreditTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTransaction'], meta: { name: 'CreditTransaction' } }
    /**
     * Find zero or one CreditTransaction that matches the filter.
     * @param {CreditTransactionFindUniqueArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTransactionFindUniqueArgs>(args: SelectSubset<T, CreditTransactionFindUniqueArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTransactionFindUniqueOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTransactionFindFirstArgs>(args?: SelectSubset<T, CreditTransactionFindFirstArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany()
     * 
     * // Get first 10 CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTransactionFindManyArgs>(args?: SelectSubset<T, CreditTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTransaction.
     * @param {CreditTransactionCreateArgs} args - Arguments to create a CreditTransaction.
     * @example
     * // Create one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.create({
     *   data: {
     *     // ... data to create a CreditTransaction
     *   }
     * })
     * 
     */
    create<T extends CreditTransactionCreateArgs>(args: SelectSubset<T, CreditTransactionCreateArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTransactions.
     * @param {CreditTransactionCreateManyArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTransactionCreateManyArgs>(args?: SelectSubset<T, CreditTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTransactions and returns the data saved in the database.
     * @param {CreditTransactionCreateManyAndReturnArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTransaction.
     * @param {CreditTransactionDeleteArgs} args - Arguments to delete one CreditTransaction.
     * @example
     * // Delete one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.delete({
     *   where: {
     *     // ... filter to delete one CreditTransaction
     *   }
     * })
     * 
     */
    delete<T extends CreditTransactionDeleteArgs>(args: SelectSubset<T, CreditTransactionDeleteArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTransaction.
     * @param {CreditTransactionUpdateArgs} args - Arguments to update one CreditTransaction.
     * @example
     * // Update one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTransactionUpdateArgs>(args: SelectSubset<T, CreditTransactionUpdateArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTransactions.
     * @param {CreditTransactionDeleteManyArgs} args - Arguments to filter CreditTransactions to delete.
     * @example
     * // Delete a few CreditTransactions
     * const { count } = await prisma.creditTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTransactionDeleteManyArgs>(args?: SelectSubset<T, CreditTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTransactionUpdateManyArgs>(args: SelectSubset<T, CreditTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTransactions and returns the data updated in the database.
     * @param {CreditTransactionUpdateManyAndReturnArgs} args - Arguments to update many CreditTransactions.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTransaction.
     * @param {CreditTransactionUpsertArgs} args - Arguments to update or create a CreditTransaction.
     * @example
     * // Update or create a CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.upsert({
     *   create: {
     *     // ... data to create a CreditTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CreditTransactionUpsertArgs>(args: SelectSubset<T, CreditTransactionUpsertArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionCountArgs} args - Arguments to filter CreditTransactions to count.
     * @example
     * // Count the number of CreditTransactions
     * const count = await prisma.creditTransaction.count({
     *   where: {
     *     // ... the filter for the CreditTransactions we want to count
     *   }
     * })
    **/
    count<T extends CreditTransactionCountArgs>(
      args?: Subset<T, CreditTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTransactionAggregateArgs>(args: Subset<T, CreditTransactionAggregateArgs>): Prisma.PrismaPromise<GetCreditTransactionAggregateType<T>>

    /**
     * Group by CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CreditTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTransaction model
   */
  readonly fields: CreditTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTransaction model
   */
  interface CreditTransactionFieldRefs {
    readonly id: FieldRef<"CreditTransaction", 'String'>
    readonly userId: FieldRef<"CreditTransaction", 'String'>
    readonly transactionType: FieldRef<"CreditTransaction", 'CreditTransactionType'>
    readonly amountCredits: FieldRef<"CreditTransaction", 'Float'>
    readonly balanceAfter: FieldRef<"CreditTransaction", 'Float'>
    readonly notes: FieldRef<"CreditTransaction", 'String'>
    readonly relatedUsageLogId: FieldRef<"CreditTransaction", 'String'>
    readonly relatedPlanId: FieldRef<"CreditTransaction", 'String'>
    readonly timestamp: FieldRef<"CreditTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditTransaction findUnique
   */
  export type CreditTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction findUniqueOrThrow
   */
  export type CreditTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction findFirst
   */
  export type CreditTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction findFirstOrThrow
   */
  export type CreditTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction findMany
   */
  export type CreditTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransactions to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction create
   */
  export type CreditTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTransaction.
     */
    data: XOR<CreditTransactionCreateInput, CreditTransactionUncheckedCreateInput>
  }

  /**
   * CreditTransaction createMany
   */
  export type CreditTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditTransaction createManyAndReturn
   */
  export type CreditTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTransaction update
   */
  export type CreditTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTransaction.
     */
    data: XOR<CreditTransactionUpdateInput, CreditTransactionUncheckedUpdateInput>
    /**
     * Choose, which CreditTransaction to update.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction updateMany
   */
  export type CreditTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number
  }

  /**
   * CreditTransaction updateManyAndReturn
   */
  export type CreditTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTransaction upsert
   */
  export type CreditTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTransaction to update in case it exists.
     */
    where: CreditTransactionWhereUniqueInput
    /**
     * In case the CreditTransaction found by the `where` argument doesn't exist, create a new CreditTransaction with this data.
     */
    create: XOR<CreditTransactionCreateInput, CreditTransactionUncheckedCreateInput>
    /**
     * In case the CreditTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTransactionUpdateInput, CreditTransactionUncheckedUpdateInput>
  }

  /**
   * CreditTransaction delete
   */
  export type CreditTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter which CreditTransaction to delete.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction deleteMany
   */
  export type CreditTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTransactions to delete
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to delete.
     */
    limit?: number
  }

  /**
   * CreditTransaction without action
   */
  export type CreditTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    priceMonthly: number | null
    creditsPerMonth: number | null
  }

  export type PlanSumAggregateOutputType = {
    priceMonthly: number | null
    creditsPerMonth: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    tier: $Enums.PlanTier | null
    name: string | null
    priceMonthly: number | null
    creditsPerMonth: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    paypalPlanId: string | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    tier: $Enums.PlanTier | null
    name: string | null
    priceMonthly: number | null
    creditsPerMonth: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    paypalPlanId: string | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    tier: number
    name: number
    priceMonthly: number
    creditsPerMonth: number
    description: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    paypalPlanId: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    priceMonthly?: true
    creditsPerMonth?: true
  }

  export type PlanSumAggregateInputType = {
    priceMonthly?: true
    creditsPerMonth?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    tier?: true
    name?: true
    priceMonthly?: true
    creditsPerMonth?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    paypalPlanId?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    tier?: true
    name?: true
    priceMonthly?: true
    creditsPerMonth?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    paypalPlanId?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    tier?: true
    name?: true
    priceMonthly?: true
    creditsPerMonth?: true
    description?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    paypalPlanId?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description: string | null
    features: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    paypalPlanId: string | null
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tier?: boolean
    name?: boolean
    priceMonthly?: boolean
    creditsPerMonth?: boolean
    description?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paypalPlanId?: boolean
    userPlans?: boolean | Plan$userPlansArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tier?: boolean
    name?: boolean
    priceMonthly?: boolean
    creditsPerMonth?: boolean
    description?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paypalPlanId?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tier?: boolean
    name?: boolean
    priceMonthly?: boolean
    creditsPerMonth?: boolean
    description?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paypalPlanId?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    tier?: boolean
    name?: boolean
    priceMonthly?: boolean
    creditsPerMonth?: boolean
    description?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paypalPlanId?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tier" | "name" | "priceMonthly" | "creditsPerMonth" | "description" | "features" | "isActive" | "createdAt" | "updatedAt" | "paypalPlanId", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPlans?: boolean | Plan$userPlansArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      userPlans: Prisma.$UserPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tier: $Enums.PlanTier
      name: string
      priceMonthly: number
      creditsPerMonth: number
      description: string | null
      features: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      paypalPlanId: string | null
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userPlans<T extends Plan$userPlansArgs<ExtArgs> = {}>(args?: Subset<T, Plan$userPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly tier: FieldRef<"Plan", 'PlanTier'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly priceMonthly: FieldRef<"Plan", 'Float'>
    readonly creditsPerMonth: FieldRef<"Plan", 'Int'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly paypalPlanId: FieldRef<"Plan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.userPlans
   */
  export type Plan$userPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    where?: UserPlanWhereInput
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    cursor?: UserPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPlanScalarFieldEnum | UserPlanScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCreditCost
   */

  export type AggregateServiceCreditCost = {
    _count: ServiceCreditCostCountAggregateOutputType | null
    _avg: ServiceCreditCostAvgAggregateOutputType | null
    _sum: ServiceCreditCostSumAggregateOutputType | null
    _min: ServiceCreditCostMinAggregateOutputType | null
    _max: ServiceCreditCostMaxAggregateOutputType | null
  }

  export type ServiceCreditCostAvgAggregateOutputType = {
    creditsPerUnit: number | null
  }

  export type ServiceCreditCostSumAggregateOutputType = {
    creditsPerUnit: number | null
  }

  export type ServiceCreditCostMinAggregateOutputType = {
    id: string | null
    serviceIdentifier: string | null
    creditsPerUnit: number | null
    unitDescription: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCreditCostMaxAggregateOutputType = {
    id: string | null
    serviceIdentifier: string | null
    creditsPerUnit: number | null
    unitDescription: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCreditCostCountAggregateOutputType = {
    id: number
    serviceIdentifier: number
    creditsPerUnit: number
    unitDescription: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCreditCostAvgAggregateInputType = {
    creditsPerUnit?: true
  }

  export type ServiceCreditCostSumAggregateInputType = {
    creditsPerUnit?: true
  }

  export type ServiceCreditCostMinAggregateInputType = {
    id?: true
    serviceIdentifier?: true
    creditsPerUnit?: true
    unitDescription?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCreditCostMaxAggregateInputType = {
    id?: true
    serviceIdentifier?: true
    creditsPerUnit?: true
    unitDescription?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCreditCostCountAggregateInputType = {
    id?: true
    serviceIdentifier?: true
    creditsPerUnit?: true
    unitDescription?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCreditCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCreditCost to aggregate.
     */
    where?: ServiceCreditCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCreditCosts to fetch.
     */
    orderBy?: ServiceCreditCostOrderByWithRelationInput | ServiceCreditCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCreditCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCreditCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCreditCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCreditCosts
    **/
    _count?: true | ServiceCreditCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceCreditCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceCreditCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCreditCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCreditCostMaxAggregateInputType
  }

  export type GetServiceCreditCostAggregateType<T extends ServiceCreditCostAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCreditCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCreditCost[P]>
      : GetScalarType<T[P], AggregateServiceCreditCost[P]>
  }




  export type ServiceCreditCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCreditCostWhereInput
    orderBy?: ServiceCreditCostOrderByWithAggregationInput | ServiceCreditCostOrderByWithAggregationInput[]
    by: ServiceCreditCostScalarFieldEnum[] | ServiceCreditCostScalarFieldEnum
    having?: ServiceCreditCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCreditCostCountAggregateInputType | true
    _avg?: ServiceCreditCostAvgAggregateInputType
    _sum?: ServiceCreditCostSumAggregateInputType
    _min?: ServiceCreditCostMinAggregateInputType
    _max?: ServiceCreditCostMaxAggregateInputType
  }

  export type ServiceCreditCostGroupByOutputType = {
    id: string
    serviceIdentifier: string
    creditsPerUnit: number
    unitDescription: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCreditCostCountAggregateOutputType | null
    _avg: ServiceCreditCostAvgAggregateOutputType | null
    _sum: ServiceCreditCostSumAggregateOutputType | null
    _min: ServiceCreditCostMinAggregateOutputType | null
    _max: ServiceCreditCostMaxAggregateOutputType | null
  }

  type GetServiceCreditCostGroupByPayload<T extends ServiceCreditCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCreditCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCreditCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCreditCostGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCreditCostGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCreditCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceIdentifier?: boolean
    creditsPerUnit?: boolean
    unitDescription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCreditCost"]>

  export type ServiceCreditCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceIdentifier?: boolean
    creditsPerUnit?: boolean
    unitDescription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCreditCost"]>

  export type ServiceCreditCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceIdentifier?: boolean
    creditsPerUnit?: boolean
    unitDescription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCreditCost"]>

  export type ServiceCreditCostSelectScalar = {
    id?: boolean
    serviceIdentifier?: boolean
    creditsPerUnit?: boolean
    unitDescription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceCreditCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceIdentifier" | "creditsPerUnit" | "unitDescription" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceCreditCost"]>

  export type $ServiceCreditCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCreditCost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceIdentifier: string
      creditsPerUnit: number
      unitDescription: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceCreditCost"]>
    composites: {}
  }

  type ServiceCreditCostGetPayload<S extends boolean | null | undefined | ServiceCreditCostDefaultArgs> = $Result.GetResult<Prisma.$ServiceCreditCostPayload, S>

  type ServiceCreditCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCreditCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCreditCostCountAggregateInputType | true
    }

  export interface ServiceCreditCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCreditCost'], meta: { name: 'ServiceCreditCost' } }
    /**
     * Find zero or one ServiceCreditCost that matches the filter.
     * @param {ServiceCreditCostFindUniqueArgs} args - Arguments to find a ServiceCreditCost
     * @example
     * // Get one ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCreditCostFindUniqueArgs>(args: SelectSubset<T, ServiceCreditCostFindUniqueArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCreditCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCreditCostFindUniqueOrThrowArgs} args - Arguments to find a ServiceCreditCost
     * @example
     * // Get one ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCreditCostFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCreditCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCreditCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostFindFirstArgs} args - Arguments to find a ServiceCreditCost
     * @example
     * // Get one ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCreditCostFindFirstArgs>(args?: SelectSubset<T, ServiceCreditCostFindFirstArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCreditCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostFindFirstOrThrowArgs} args - Arguments to find a ServiceCreditCost
     * @example
     * // Get one ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCreditCostFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCreditCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCreditCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCreditCosts
     * const serviceCreditCosts = await prisma.serviceCreditCost.findMany()
     * 
     * // Get first 10 ServiceCreditCosts
     * const serviceCreditCosts = await prisma.serviceCreditCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCreditCostWithIdOnly = await prisma.serviceCreditCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCreditCostFindManyArgs>(args?: SelectSubset<T, ServiceCreditCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCreditCost.
     * @param {ServiceCreditCostCreateArgs} args - Arguments to create a ServiceCreditCost.
     * @example
     * // Create one ServiceCreditCost
     * const ServiceCreditCost = await prisma.serviceCreditCost.create({
     *   data: {
     *     // ... data to create a ServiceCreditCost
     *   }
     * })
     * 
     */
    create<T extends ServiceCreditCostCreateArgs>(args: SelectSubset<T, ServiceCreditCostCreateArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCreditCosts.
     * @param {ServiceCreditCostCreateManyArgs} args - Arguments to create many ServiceCreditCosts.
     * @example
     * // Create many ServiceCreditCosts
     * const serviceCreditCost = await prisma.serviceCreditCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreditCostCreateManyArgs>(args?: SelectSubset<T, ServiceCreditCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCreditCosts and returns the data saved in the database.
     * @param {ServiceCreditCostCreateManyAndReturnArgs} args - Arguments to create many ServiceCreditCosts.
     * @example
     * // Create many ServiceCreditCosts
     * const serviceCreditCost = await prisma.serviceCreditCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCreditCosts and only return the `id`
     * const serviceCreditCostWithIdOnly = await prisma.serviceCreditCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreditCostCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreditCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCreditCost.
     * @param {ServiceCreditCostDeleteArgs} args - Arguments to delete one ServiceCreditCost.
     * @example
     * // Delete one ServiceCreditCost
     * const ServiceCreditCost = await prisma.serviceCreditCost.delete({
     *   where: {
     *     // ... filter to delete one ServiceCreditCost
     *   }
     * })
     * 
     */
    delete<T extends ServiceCreditCostDeleteArgs>(args: SelectSubset<T, ServiceCreditCostDeleteArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCreditCost.
     * @param {ServiceCreditCostUpdateArgs} args - Arguments to update one ServiceCreditCost.
     * @example
     * // Update one ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCreditCostUpdateArgs>(args: SelectSubset<T, ServiceCreditCostUpdateArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCreditCosts.
     * @param {ServiceCreditCostDeleteManyArgs} args - Arguments to filter ServiceCreditCosts to delete.
     * @example
     * // Delete a few ServiceCreditCosts
     * const { count } = await prisma.serviceCreditCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCreditCostDeleteManyArgs>(args?: SelectSubset<T, ServiceCreditCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCreditCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCreditCosts
     * const serviceCreditCost = await prisma.serviceCreditCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCreditCostUpdateManyArgs>(args: SelectSubset<T, ServiceCreditCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCreditCosts and returns the data updated in the database.
     * @param {ServiceCreditCostUpdateManyAndReturnArgs} args - Arguments to update many ServiceCreditCosts.
     * @example
     * // Update many ServiceCreditCosts
     * const serviceCreditCost = await prisma.serviceCreditCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCreditCosts and only return the `id`
     * const serviceCreditCostWithIdOnly = await prisma.serviceCreditCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCreditCostUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCreditCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCreditCost.
     * @param {ServiceCreditCostUpsertArgs} args - Arguments to update or create a ServiceCreditCost.
     * @example
     * // Update or create a ServiceCreditCost
     * const serviceCreditCost = await prisma.serviceCreditCost.upsert({
     *   create: {
     *     // ... data to create a ServiceCreditCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCreditCost we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCreditCostUpsertArgs>(args: SelectSubset<T, ServiceCreditCostUpsertArgs<ExtArgs>>): Prisma__ServiceCreditCostClient<$Result.GetResult<Prisma.$ServiceCreditCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCreditCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostCountArgs} args - Arguments to filter ServiceCreditCosts to count.
     * @example
     * // Count the number of ServiceCreditCosts
     * const count = await prisma.serviceCreditCost.count({
     *   where: {
     *     // ... the filter for the ServiceCreditCosts we want to count
     *   }
     * })
    **/
    count<T extends ServiceCreditCostCountArgs>(
      args?: Subset<T, ServiceCreditCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCreditCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCreditCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCreditCostAggregateArgs>(args: Subset<T, ServiceCreditCostAggregateArgs>): Prisma.PrismaPromise<GetServiceCreditCostAggregateType<T>>

    /**
     * Group by ServiceCreditCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCreditCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCreditCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCreditCostGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCreditCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCreditCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCreditCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCreditCost model
   */
  readonly fields: ServiceCreditCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCreditCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCreditCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCreditCost model
   */
  interface ServiceCreditCostFieldRefs {
    readonly id: FieldRef<"ServiceCreditCost", 'String'>
    readonly serviceIdentifier: FieldRef<"ServiceCreditCost", 'String'>
    readonly creditsPerUnit: FieldRef<"ServiceCreditCost", 'Float'>
    readonly unitDescription: FieldRef<"ServiceCreditCost", 'String'>
    readonly isActive: FieldRef<"ServiceCreditCost", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceCreditCost", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCreditCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCreditCost findUnique
   */
  export type ServiceCreditCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter, which ServiceCreditCost to fetch.
     */
    where: ServiceCreditCostWhereUniqueInput
  }

  /**
   * ServiceCreditCost findUniqueOrThrow
   */
  export type ServiceCreditCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter, which ServiceCreditCost to fetch.
     */
    where: ServiceCreditCostWhereUniqueInput
  }

  /**
   * ServiceCreditCost findFirst
   */
  export type ServiceCreditCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter, which ServiceCreditCost to fetch.
     */
    where?: ServiceCreditCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCreditCosts to fetch.
     */
    orderBy?: ServiceCreditCostOrderByWithRelationInput | ServiceCreditCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCreditCosts.
     */
    cursor?: ServiceCreditCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCreditCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCreditCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCreditCosts.
     */
    distinct?: ServiceCreditCostScalarFieldEnum | ServiceCreditCostScalarFieldEnum[]
  }

  /**
   * ServiceCreditCost findFirstOrThrow
   */
  export type ServiceCreditCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter, which ServiceCreditCost to fetch.
     */
    where?: ServiceCreditCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCreditCosts to fetch.
     */
    orderBy?: ServiceCreditCostOrderByWithRelationInput | ServiceCreditCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCreditCosts.
     */
    cursor?: ServiceCreditCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCreditCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCreditCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCreditCosts.
     */
    distinct?: ServiceCreditCostScalarFieldEnum | ServiceCreditCostScalarFieldEnum[]
  }

  /**
   * ServiceCreditCost findMany
   */
  export type ServiceCreditCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter, which ServiceCreditCosts to fetch.
     */
    where?: ServiceCreditCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCreditCosts to fetch.
     */
    orderBy?: ServiceCreditCostOrderByWithRelationInput | ServiceCreditCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCreditCosts.
     */
    cursor?: ServiceCreditCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCreditCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCreditCosts.
     */
    skip?: number
    distinct?: ServiceCreditCostScalarFieldEnum | ServiceCreditCostScalarFieldEnum[]
  }

  /**
   * ServiceCreditCost create
   */
  export type ServiceCreditCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceCreditCost.
     */
    data: XOR<ServiceCreditCostCreateInput, ServiceCreditCostUncheckedCreateInput>
  }

  /**
   * ServiceCreditCost createMany
   */
  export type ServiceCreditCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCreditCosts.
     */
    data: ServiceCreditCostCreateManyInput | ServiceCreditCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCreditCost createManyAndReturn
   */
  export type ServiceCreditCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCreditCosts.
     */
    data: ServiceCreditCostCreateManyInput | ServiceCreditCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCreditCost update
   */
  export type ServiceCreditCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceCreditCost.
     */
    data: XOR<ServiceCreditCostUpdateInput, ServiceCreditCostUncheckedUpdateInput>
    /**
     * Choose, which ServiceCreditCost to update.
     */
    where: ServiceCreditCostWhereUniqueInput
  }

  /**
   * ServiceCreditCost updateMany
   */
  export type ServiceCreditCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCreditCosts.
     */
    data: XOR<ServiceCreditCostUpdateManyMutationInput, ServiceCreditCostUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCreditCosts to update
     */
    where?: ServiceCreditCostWhereInput
    /**
     * Limit how many ServiceCreditCosts to update.
     */
    limit?: number
  }

  /**
   * ServiceCreditCost updateManyAndReturn
   */
  export type ServiceCreditCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCreditCosts.
     */
    data: XOR<ServiceCreditCostUpdateManyMutationInput, ServiceCreditCostUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCreditCosts to update
     */
    where?: ServiceCreditCostWhereInput
    /**
     * Limit how many ServiceCreditCosts to update.
     */
    limit?: number
  }

  /**
   * ServiceCreditCost upsert
   */
  export type ServiceCreditCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceCreditCost to update in case it exists.
     */
    where: ServiceCreditCostWhereUniqueInput
    /**
     * In case the ServiceCreditCost found by the `where` argument doesn't exist, create a new ServiceCreditCost with this data.
     */
    create: XOR<ServiceCreditCostCreateInput, ServiceCreditCostUncheckedCreateInput>
    /**
     * In case the ServiceCreditCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCreditCostUpdateInput, ServiceCreditCostUncheckedUpdateInput>
  }

  /**
   * ServiceCreditCost delete
   */
  export type ServiceCreditCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
    /**
     * Filter which ServiceCreditCost to delete.
     */
    where: ServiceCreditCostWhereUniqueInput
  }

  /**
   * ServiceCreditCost deleteMany
   */
  export type ServiceCreditCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCreditCosts to delete
     */
    where?: ServiceCreditCostWhereInput
    /**
     * Limit how many ServiceCreditCosts to delete.
     */
    limit?: number
  }

  /**
   * ServiceCreditCost without action
   */
  export type ServiceCreditCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCreditCost
     */
    select?: ServiceCreditCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCreditCost
     */
    omit?: ServiceCreditCostOmit<ExtArgs> | null
  }


  /**
   * Model UsageLog
   */

  export type AggregateUsageLog = {
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  export type UsageLogAvgAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    charactersProcessed: number | null
    imagesProcessed: number | null
    costUsd: number | null
    creditsConsumed: number | null
  }

  export type UsageLogSumAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    charactersProcessed: number | null
    imagesProcessed: number | null
    costUsd: number | null
    creditsConsumed: number | null
  }

  export type UsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    conversationId: string | null
    serviceType: string | null
    providerName: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    charactersProcessed: number | null
    imagesProcessed: number | null
    costUsd: number | null
    creditsConsumed: number | null
    processed: boolean | null
    processedAt: Date | null
    timestamp: Date | null
  }

  export type UsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    conversationId: string | null
    serviceType: string | null
    providerName: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    charactersProcessed: number | null
    imagesProcessed: number | null
    costUsd: number | null
    creditsConsumed: number | null
    processed: boolean | null
    processedAt: Date | null
    timestamp: Date | null
  }

  export type UsageLogCountAggregateOutputType = {
    id: number
    userId: number
    conversationId: number
    serviceType: number
    providerName: number
    modelName: number
    inputTokens: number
    outputTokens: number
    charactersProcessed: number
    imagesProcessed: number
    costUsd: number
    creditsConsumed: number
    additionalMetadata: number
    processed: number
    processedAt: number
    timestamp: number
    _all: number
  }


  export type UsageLogAvgAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    charactersProcessed?: true
    imagesProcessed?: true
    costUsd?: true
    creditsConsumed?: true
  }

  export type UsageLogSumAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    charactersProcessed?: true
    imagesProcessed?: true
    costUsd?: true
    creditsConsumed?: true
  }

  export type UsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    serviceType?: true
    providerName?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    charactersProcessed?: true
    imagesProcessed?: true
    costUsd?: true
    creditsConsumed?: true
    processed?: true
    processedAt?: true
    timestamp?: true
  }

  export type UsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    serviceType?: true
    providerName?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    charactersProcessed?: true
    imagesProcessed?: true
    costUsd?: true
    creditsConsumed?: true
    processed?: true
    processedAt?: true
    timestamp?: true
  }

  export type UsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    serviceType?: true
    providerName?: true
    modelName?: true
    inputTokens?: true
    outputTokens?: true
    charactersProcessed?: true
    imagesProcessed?: true
    costUsd?: true
    creditsConsumed?: true
    additionalMetadata?: true
    processed?: true
    processedAt?: true
    timestamp?: true
    _all?: true
  }

  export type UsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLog to aggregate.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageLogs
    **/
    _count?: true | UsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageLogMaxAggregateInputType
  }

  export type GetUsageLogAggregateType<T extends UsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageLog[P]>
      : GetScalarType<T[P], AggregateUsageLog[P]>
  }




  export type UsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithAggregationInput | UsageLogOrderByWithAggregationInput[]
    by: UsageLogScalarFieldEnum[] | UsageLogScalarFieldEnum
    having?: UsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageLogCountAggregateInputType | true
    _avg?: UsageLogAvgAggregateInputType
    _sum?: UsageLogSumAggregateInputType
    _min?: UsageLogMinAggregateInputType
    _max?: UsageLogMaxAggregateInputType
  }

  export type UsageLogGroupByOutputType = {
    id: string
    userId: string
    conversationId: string | null
    serviceType: string
    providerName: string | null
    modelName: string | null
    inputTokens: number | null
    outputTokens: number | null
    charactersProcessed: number | null
    imagesProcessed: number | null
    costUsd: number | null
    creditsConsumed: number | null
    additionalMetadata: JsonValue | null
    processed: boolean
    processedAt: Date | null
    timestamp: Date
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  type GetUsageLogGroupByPayload<T extends UsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
        }
      >
    >


  export type UsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    serviceType?: boolean
    providerName?: boolean
    modelName?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    charactersProcessed?: boolean
    imagesProcessed?: boolean
    costUsd?: boolean
    creditsConsumed?: boolean
    additionalMetadata?: boolean
    processed?: boolean
    processedAt?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    serviceType?: boolean
    providerName?: boolean
    modelName?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    charactersProcessed?: boolean
    imagesProcessed?: boolean
    costUsd?: boolean
    creditsConsumed?: boolean
    additionalMetadata?: boolean
    processed?: boolean
    processedAt?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    serviceType?: boolean
    providerName?: boolean
    modelName?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    charactersProcessed?: boolean
    imagesProcessed?: boolean
    costUsd?: boolean
    creditsConsumed?: boolean
    additionalMetadata?: boolean
    processed?: boolean
    processedAt?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    serviceType?: boolean
    providerName?: boolean
    modelName?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    charactersProcessed?: boolean
    imagesProcessed?: boolean
    costUsd?: boolean
    creditsConsumed?: boolean
    additionalMetadata?: boolean
    processed?: boolean
    processedAt?: boolean
    timestamp?: boolean
  }

  export type UsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "conversationId" | "serviceType" | "providerName" | "modelName" | "inputTokens" | "outputTokens" | "charactersProcessed" | "imagesProcessed" | "costUsd" | "creditsConsumed" | "additionalMetadata" | "processed" | "processedAt" | "timestamp", ExtArgs["result"]["usageLog"]>
  export type UsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      conversationId: string | null
      serviceType: string
      providerName: string | null
      modelName: string | null
      inputTokens: number | null
      outputTokens: number | null
      charactersProcessed: number | null
      imagesProcessed: number | null
      costUsd: number | null
      creditsConsumed: number | null
      additionalMetadata: Prisma.JsonValue | null
      processed: boolean
      processedAt: Date | null
      timestamp: Date
    }, ExtArgs["result"]["usageLog"]>
    composites: {}
  }

  type UsageLogGetPayload<S extends boolean | null | undefined | UsageLogDefaultArgs> = $Result.GetResult<Prisma.$UsageLogPayload, S>

  type UsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageLogCountAggregateInputType | true
    }

  export interface UsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageLog'], meta: { name: 'UsageLog' } }
    /**
     * Find zero or one UsageLog that matches the filter.
     * @param {UsageLogFindUniqueArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageLogFindUniqueArgs>(args: SelectSubset<T, UsageLogFindUniqueArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageLogFindUniqueOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageLogFindFirstArgs>(args?: SelectSubset<T, UsageLogFindFirstArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageLogs
     * const usageLogs = await prisma.usageLog.findMany()
     * 
     * // Get first 10 UsageLogs
     * const usageLogs = await prisma.usageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageLogFindManyArgs>(args?: SelectSubset<T, UsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageLog.
     * @param {UsageLogCreateArgs} args - Arguments to create a UsageLog.
     * @example
     * // Create one UsageLog
     * const UsageLog = await prisma.usageLog.create({
     *   data: {
     *     // ... data to create a UsageLog
     *   }
     * })
     * 
     */
    create<T extends UsageLogCreateArgs>(args: SelectSubset<T, UsageLogCreateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageLogs.
     * @param {UsageLogCreateManyArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageLogCreateManyArgs>(args?: SelectSubset<T, UsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageLogs and returns the data saved in the database.
     * @param {UsageLogCreateManyAndReturnArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageLogs and only return the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageLog.
     * @param {UsageLogDeleteArgs} args - Arguments to delete one UsageLog.
     * @example
     * // Delete one UsageLog
     * const UsageLog = await prisma.usageLog.delete({
     *   where: {
     *     // ... filter to delete one UsageLog
     *   }
     * })
     * 
     */
    delete<T extends UsageLogDeleteArgs>(args: SelectSubset<T, UsageLogDeleteArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageLog.
     * @param {UsageLogUpdateArgs} args - Arguments to update one UsageLog.
     * @example
     * // Update one UsageLog
     * const usageLog = await prisma.usageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageLogUpdateArgs>(args: SelectSubset<T, UsageLogUpdateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageLogs.
     * @param {UsageLogDeleteManyArgs} args - Arguments to filter UsageLogs to delete.
     * @example
     * // Delete a few UsageLogs
     * const { count } = await prisma.usageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageLogDeleteManyArgs>(args?: SelectSubset<T, UsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageLogUpdateManyArgs>(args: SelectSubset<T, UsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs and returns the data updated in the database.
     * @param {UsageLogUpdateManyAndReturnArgs} args - Arguments to update many UsageLogs.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageLogs and only return the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageLog.
     * @param {UsageLogUpsertArgs} args - Arguments to update or create a UsageLog.
     * @example
     * // Update or create a UsageLog
     * const usageLog = await prisma.usageLog.upsert({
     *   create: {
     *     // ... data to create a UsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageLog we want to update
     *   }
     * })
     */
    upsert<T extends UsageLogUpsertArgs>(args: SelectSubset<T, UsageLogUpsertArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogCountArgs} args - Arguments to filter UsageLogs to count.
     * @example
     * // Count the number of UsageLogs
     * const count = await prisma.usageLog.count({
     *   where: {
     *     // ... the filter for the UsageLogs we want to count
     *   }
     * })
    **/
    count<T extends UsageLogCountArgs>(
      args?: Subset<T, UsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageLogAggregateArgs>(args: Subset<T, UsageLogAggregateArgs>): Prisma.PrismaPromise<GetUsageLogAggregateType<T>>

    /**
     * Group by UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageLogGroupByArgs['orderBy'] }
        : { orderBy?: UsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageLog model
   */
  readonly fields: UsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageLog model
   */
  interface UsageLogFieldRefs {
    readonly id: FieldRef<"UsageLog", 'String'>
    readonly userId: FieldRef<"UsageLog", 'String'>
    readonly conversationId: FieldRef<"UsageLog", 'String'>
    readonly serviceType: FieldRef<"UsageLog", 'String'>
    readonly providerName: FieldRef<"UsageLog", 'String'>
    readonly modelName: FieldRef<"UsageLog", 'String'>
    readonly inputTokens: FieldRef<"UsageLog", 'Int'>
    readonly outputTokens: FieldRef<"UsageLog", 'Int'>
    readonly charactersProcessed: FieldRef<"UsageLog", 'Int'>
    readonly imagesProcessed: FieldRef<"UsageLog", 'Int'>
    readonly costUsd: FieldRef<"UsageLog", 'Float'>
    readonly creditsConsumed: FieldRef<"UsageLog", 'Float'>
    readonly additionalMetadata: FieldRef<"UsageLog", 'Json'>
    readonly processed: FieldRef<"UsageLog", 'Boolean'>
    readonly processedAt: FieldRef<"UsageLog", 'DateTime'>
    readonly timestamp: FieldRef<"UsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageLog findUnique
   */
  export type UsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findUniqueOrThrow
   */
  export type UsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findFirst
   */
  export type UsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findFirstOrThrow
   */
  export type UsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findMany
   */
  export type UsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLogs to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog create
   */
  export type UsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageLog.
     */
    data: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
  }

  /**
   * UsageLog createMany
   */
  export type UsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageLog createManyAndReturn
   */
  export type UsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageLog update
   */
  export type UsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageLog.
     */
    data: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
    /**
     * Choose, which UsageLog to update.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog updateMany
   */
  export type UsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to update.
     */
    limit?: number
  }

  /**
   * UsageLog updateManyAndReturn
   */
  export type UsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageLog upsert
   */
  export type UsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageLog to update in case it exists.
     */
    where: UsageLogWhereUniqueInput
    /**
     * In case the UsageLog found by the `where` argument doesn't exist, create a new UsageLog with this data.
     */
    create: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
    /**
     * In case the UsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
  }

  /**
   * UsageLog delete
   */
  export type UsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter which UsageLog to delete.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog deleteMany
   */
  export type UsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLogs to delete
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to delete.
     */
    limit?: number
  }

  /**
   * UsageLog without action
   */
  export type UsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
  }


  /**
   * Model UserMonthlyBalance
   */

  export type AggregateUserMonthlyBalance = {
    _count: UserMonthlyBalanceCountAggregateOutputType | null
    _avg: UserMonthlyBalanceAvgAggregateOutputType | null
    _sum: UserMonthlyBalanceSumAggregateOutputType | null
    _min: UserMonthlyBalanceMinAggregateOutputType | null
    _max: UserMonthlyBalanceMaxAggregateOutputType | null
  }

  export type UserMonthlyBalanceAvgAggregateOutputType = {
    startingBalance: number | null
    creditsGranted: number | null
    creditsSpent: number | null
    endingBalance: number | null
  }

  export type UserMonthlyBalanceSumAggregateOutputType = {
    startingBalance: number | null
    creditsGranted: number | null
    creditsSpent: number | null
    endingBalance: number | null
  }

  export type UserMonthlyBalanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    monthStartDate: Date | null
    startingBalance: number | null
    creditsGranted: number | null
    creditsSpent: number | null
    endingBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyBalanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    monthStartDate: Date | null
    startingBalance: number | null
    creditsGranted: number | null
    creditsSpent: number | null
    endingBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyBalanceCountAggregateOutputType = {
    id: number
    userId: number
    monthStartDate: number
    startingBalance: number
    creditsGranted: number
    creditsSpent: number
    endingBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMonthlyBalanceAvgAggregateInputType = {
    startingBalance?: true
    creditsGranted?: true
    creditsSpent?: true
    endingBalance?: true
  }

  export type UserMonthlyBalanceSumAggregateInputType = {
    startingBalance?: true
    creditsGranted?: true
    creditsSpent?: true
    endingBalance?: true
  }

  export type UserMonthlyBalanceMinAggregateInputType = {
    id?: true
    userId?: true
    monthStartDate?: true
    startingBalance?: true
    creditsGranted?: true
    creditsSpent?: true
    endingBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyBalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    monthStartDate?: true
    startingBalance?: true
    creditsGranted?: true
    creditsSpent?: true
    endingBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyBalanceCountAggregateInputType = {
    id?: true
    userId?: true
    monthStartDate?: true
    startingBalance?: true
    creditsGranted?: true
    creditsSpent?: true
    endingBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserMonthlyBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyBalance to aggregate.
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyBalances to fetch.
     */
    orderBy?: UserMonthlyBalanceOrderByWithRelationInput | UserMonthlyBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMonthlyBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMonthlyBalances
    **/
    _count?: true | UserMonthlyBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMonthlyBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMonthlyBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMonthlyBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMonthlyBalanceMaxAggregateInputType
  }

  export type GetUserMonthlyBalanceAggregateType<T extends UserMonthlyBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMonthlyBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMonthlyBalance[P]>
      : GetScalarType<T[P], AggregateUserMonthlyBalance[P]>
  }




  export type UserMonthlyBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyBalanceWhereInput
    orderBy?: UserMonthlyBalanceOrderByWithAggregationInput | UserMonthlyBalanceOrderByWithAggregationInput[]
    by: UserMonthlyBalanceScalarFieldEnum[] | UserMonthlyBalanceScalarFieldEnum
    having?: UserMonthlyBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMonthlyBalanceCountAggregateInputType | true
    _avg?: UserMonthlyBalanceAvgAggregateInputType
    _sum?: UserMonthlyBalanceSumAggregateInputType
    _min?: UserMonthlyBalanceMinAggregateInputType
    _max?: UserMonthlyBalanceMaxAggregateInputType
  }

  export type UserMonthlyBalanceGroupByOutputType = {
    id: string
    userId: string
    monthStartDate: Date
    startingBalance: number
    creditsGranted: number
    creditsSpent: number
    endingBalance: number
    createdAt: Date
    updatedAt: Date
    _count: UserMonthlyBalanceCountAggregateOutputType | null
    _avg: UserMonthlyBalanceAvgAggregateOutputType | null
    _sum: UserMonthlyBalanceSumAggregateOutputType | null
    _min: UserMonthlyBalanceMinAggregateOutputType | null
    _max: UserMonthlyBalanceMaxAggregateOutputType | null
  }

  type GetUserMonthlyBalanceGroupByPayload<T extends UserMonthlyBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMonthlyBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMonthlyBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMonthlyBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], UserMonthlyBalanceGroupByOutputType[P]>
        }
      >
    >


  export type UserMonthlyBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthStartDate?: boolean
    startingBalance?: boolean
    creditsGranted?: boolean
    creditsSpent?: boolean
    endingBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyBalance"]>

  export type UserMonthlyBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthStartDate?: boolean
    startingBalance?: boolean
    creditsGranted?: boolean
    creditsSpent?: boolean
    endingBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyBalance"]>

  export type UserMonthlyBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthStartDate?: boolean
    startingBalance?: boolean
    creditsGranted?: boolean
    creditsSpent?: boolean
    endingBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyBalance"]>

  export type UserMonthlyBalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    monthStartDate?: boolean
    startingBalance?: boolean
    creditsGranted?: boolean
    creditsSpent?: boolean
    endingBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserMonthlyBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "monthStartDate" | "startingBalance" | "creditsGranted" | "creditsSpent" | "endingBalance" | "createdAt" | "updatedAt", ExtArgs["result"]["userMonthlyBalance"]>
  export type UserMonthlyBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMonthlyBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMonthlyBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMonthlyBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMonthlyBalance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      monthStartDate: Date
      startingBalance: number
      creditsGranted: number
      creditsSpent: number
      endingBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userMonthlyBalance"]>
    composites: {}
  }

  type UserMonthlyBalanceGetPayload<S extends boolean | null | undefined | UserMonthlyBalanceDefaultArgs> = $Result.GetResult<Prisma.$UserMonthlyBalancePayload, S>

  type UserMonthlyBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMonthlyBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMonthlyBalanceCountAggregateInputType | true
    }

  export interface UserMonthlyBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMonthlyBalance'], meta: { name: 'UserMonthlyBalance' } }
    /**
     * Find zero or one UserMonthlyBalance that matches the filter.
     * @param {UserMonthlyBalanceFindUniqueArgs} args - Arguments to find a UserMonthlyBalance
     * @example
     * // Get one UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMonthlyBalanceFindUniqueArgs>(args: SelectSubset<T, UserMonthlyBalanceFindUniqueArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMonthlyBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMonthlyBalanceFindUniqueOrThrowArgs} args - Arguments to find a UserMonthlyBalance
     * @example
     * // Get one UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMonthlyBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMonthlyBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceFindFirstArgs} args - Arguments to find a UserMonthlyBalance
     * @example
     * // Get one UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMonthlyBalanceFindFirstArgs>(args?: SelectSubset<T, UserMonthlyBalanceFindFirstArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceFindFirstOrThrowArgs} args - Arguments to find a UserMonthlyBalance
     * @example
     * // Get one UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMonthlyBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMonthlyBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMonthlyBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMonthlyBalances
     * const userMonthlyBalances = await prisma.userMonthlyBalance.findMany()
     * 
     * // Get first 10 UserMonthlyBalances
     * const userMonthlyBalances = await prisma.userMonthlyBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMonthlyBalanceWithIdOnly = await prisma.userMonthlyBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMonthlyBalanceFindManyArgs>(args?: SelectSubset<T, UserMonthlyBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMonthlyBalance.
     * @param {UserMonthlyBalanceCreateArgs} args - Arguments to create a UserMonthlyBalance.
     * @example
     * // Create one UserMonthlyBalance
     * const UserMonthlyBalance = await prisma.userMonthlyBalance.create({
     *   data: {
     *     // ... data to create a UserMonthlyBalance
     *   }
     * })
     * 
     */
    create<T extends UserMonthlyBalanceCreateArgs>(args: SelectSubset<T, UserMonthlyBalanceCreateArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMonthlyBalances.
     * @param {UserMonthlyBalanceCreateManyArgs} args - Arguments to create many UserMonthlyBalances.
     * @example
     * // Create many UserMonthlyBalances
     * const userMonthlyBalance = await prisma.userMonthlyBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMonthlyBalanceCreateManyArgs>(args?: SelectSubset<T, UserMonthlyBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMonthlyBalances and returns the data saved in the database.
     * @param {UserMonthlyBalanceCreateManyAndReturnArgs} args - Arguments to create many UserMonthlyBalances.
     * @example
     * // Create many UserMonthlyBalances
     * const userMonthlyBalance = await prisma.userMonthlyBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMonthlyBalances and only return the `id`
     * const userMonthlyBalanceWithIdOnly = await prisma.userMonthlyBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMonthlyBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMonthlyBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMonthlyBalance.
     * @param {UserMonthlyBalanceDeleteArgs} args - Arguments to delete one UserMonthlyBalance.
     * @example
     * // Delete one UserMonthlyBalance
     * const UserMonthlyBalance = await prisma.userMonthlyBalance.delete({
     *   where: {
     *     // ... filter to delete one UserMonthlyBalance
     *   }
     * })
     * 
     */
    delete<T extends UserMonthlyBalanceDeleteArgs>(args: SelectSubset<T, UserMonthlyBalanceDeleteArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMonthlyBalance.
     * @param {UserMonthlyBalanceUpdateArgs} args - Arguments to update one UserMonthlyBalance.
     * @example
     * // Update one UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMonthlyBalanceUpdateArgs>(args: SelectSubset<T, UserMonthlyBalanceUpdateArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMonthlyBalances.
     * @param {UserMonthlyBalanceDeleteManyArgs} args - Arguments to filter UserMonthlyBalances to delete.
     * @example
     * // Delete a few UserMonthlyBalances
     * const { count } = await prisma.userMonthlyBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMonthlyBalanceDeleteManyArgs>(args?: SelectSubset<T, UserMonthlyBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMonthlyBalances
     * const userMonthlyBalance = await prisma.userMonthlyBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMonthlyBalanceUpdateManyArgs>(args: SelectSubset<T, UserMonthlyBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyBalances and returns the data updated in the database.
     * @param {UserMonthlyBalanceUpdateManyAndReturnArgs} args - Arguments to update many UserMonthlyBalances.
     * @example
     * // Update many UserMonthlyBalances
     * const userMonthlyBalance = await prisma.userMonthlyBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMonthlyBalances and only return the `id`
     * const userMonthlyBalanceWithIdOnly = await prisma.userMonthlyBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMonthlyBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMonthlyBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMonthlyBalance.
     * @param {UserMonthlyBalanceUpsertArgs} args - Arguments to update or create a UserMonthlyBalance.
     * @example
     * // Update or create a UserMonthlyBalance
     * const userMonthlyBalance = await prisma.userMonthlyBalance.upsert({
     *   create: {
     *     // ... data to create a UserMonthlyBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMonthlyBalance we want to update
     *   }
     * })
     */
    upsert<T extends UserMonthlyBalanceUpsertArgs>(args: SelectSubset<T, UserMonthlyBalanceUpsertArgs<ExtArgs>>): Prisma__UserMonthlyBalanceClient<$Result.GetResult<Prisma.$UserMonthlyBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMonthlyBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceCountArgs} args - Arguments to filter UserMonthlyBalances to count.
     * @example
     * // Count the number of UserMonthlyBalances
     * const count = await prisma.userMonthlyBalance.count({
     *   where: {
     *     // ... the filter for the UserMonthlyBalances we want to count
     *   }
     * })
    **/
    count<T extends UserMonthlyBalanceCountArgs>(
      args?: Subset<T, UserMonthlyBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMonthlyBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMonthlyBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMonthlyBalanceAggregateArgs>(args: Subset<T, UserMonthlyBalanceAggregateArgs>): Prisma.PrismaPromise<GetUserMonthlyBalanceAggregateType<T>>

    /**
     * Group by UserMonthlyBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMonthlyBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMonthlyBalanceGroupByArgs['orderBy'] }
        : { orderBy?: UserMonthlyBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMonthlyBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMonthlyBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMonthlyBalance model
   */
  readonly fields: UserMonthlyBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMonthlyBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMonthlyBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMonthlyBalance model
   */
  interface UserMonthlyBalanceFieldRefs {
    readonly id: FieldRef<"UserMonthlyBalance", 'String'>
    readonly userId: FieldRef<"UserMonthlyBalance", 'String'>
    readonly monthStartDate: FieldRef<"UserMonthlyBalance", 'DateTime'>
    readonly startingBalance: FieldRef<"UserMonthlyBalance", 'Float'>
    readonly creditsGranted: FieldRef<"UserMonthlyBalance", 'Float'>
    readonly creditsSpent: FieldRef<"UserMonthlyBalance", 'Float'>
    readonly endingBalance: FieldRef<"UserMonthlyBalance", 'Float'>
    readonly createdAt: FieldRef<"UserMonthlyBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"UserMonthlyBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMonthlyBalance findUnique
   */
  export type UserMonthlyBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyBalance to fetch.
     */
    where: UserMonthlyBalanceWhereUniqueInput
  }

  /**
   * UserMonthlyBalance findUniqueOrThrow
   */
  export type UserMonthlyBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyBalance to fetch.
     */
    where: UserMonthlyBalanceWhereUniqueInput
  }

  /**
   * UserMonthlyBalance findFirst
   */
  export type UserMonthlyBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyBalance to fetch.
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyBalances to fetch.
     */
    orderBy?: UserMonthlyBalanceOrderByWithRelationInput | UserMonthlyBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyBalances.
     */
    cursor?: UserMonthlyBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyBalances.
     */
    distinct?: UserMonthlyBalanceScalarFieldEnum | UserMonthlyBalanceScalarFieldEnum[]
  }

  /**
   * UserMonthlyBalance findFirstOrThrow
   */
  export type UserMonthlyBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyBalance to fetch.
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyBalances to fetch.
     */
    orderBy?: UserMonthlyBalanceOrderByWithRelationInput | UserMonthlyBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyBalances.
     */
    cursor?: UserMonthlyBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyBalances.
     */
    distinct?: UserMonthlyBalanceScalarFieldEnum | UserMonthlyBalanceScalarFieldEnum[]
  }

  /**
   * UserMonthlyBalance findMany
   */
  export type UserMonthlyBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyBalances to fetch.
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyBalances to fetch.
     */
    orderBy?: UserMonthlyBalanceOrderByWithRelationInput | UserMonthlyBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMonthlyBalances.
     */
    cursor?: UserMonthlyBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyBalances.
     */
    skip?: number
    distinct?: UserMonthlyBalanceScalarFieldEnum | UserMonthlyBalanceScalarFieldEnum[]
  }

  /**
   * UserMonthlyBalance create
   */
  export type UserMonthlyBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMonthlyBalance.
     */
    data: XOR<UserMonthlyBalanceCreateInput, UserMonthlyBalanceUncheckedCreateInput>
  }

  /**
   * UserMonthlyBalance createMany
   */
  export type UserMonthlyBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMonthlyBalances.
     */
    data: UserMonthlyBalanceCreateManyInput | UserMonthlyBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMonthlyBalance createManyAndReturn
   */
  export type UserMonthlyBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many UserMonthlyBalances.
     */
    data: UserMonthlyBalanceCreateManyInput | UserMonthlyBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyBalance update
   */
  export type UserMonthlyBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMonthlyBalance.
     */
    data: XOR<UserMonthlyBalanceUpdateInput, UserMonthlyBalanceUncheckedUpdateInput>
    /**
     * Choose, which UserMonthlyBalance to update.
     */
    where: UserMonthlyBalanceWhereUniqueInput
  }

  /**
   * UserMonthlyBalance updateMany
   */
  export type UserMonthlyBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMonthlyBalances.
     */
    data: XOR<UserMonthlyBalanceUpdateManyMutationInput, UserMonthlyBalanceUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyBalances to update
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * Limit how many UserMonthlyBalances to update.
     */
    limit?: number
  }

  /**
   * UserMonthlyBalance updateManyAndReturn
   */
  export type UserMonthlyBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * The data used to update UserMonthlyBalances.
     */
    data: XOR<UserMonthlyBalanceUpdateManyMutationInput, UserMonthlyBalanceUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyBalances to update
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * Limit how many UserMonthlyBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyBalance upsert
   */
  export type UserMonthlyBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMonthlyBalance to update in case it exists.
     */
    where: UserMonthlyBalanceWhereUniqueInput
    /**
     * In case the UserMonthlyBalance found by the `where` argument doesn't exist, create a new UserMonthlyBalance with this data.
     */
    create: XOR<UserMonthlyBalanceCreateInput, UserMonthlyBalanceUncheckedCreateInput>
    /**
     * In case the UserMonthlyBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMonthlyBalanceUpdateInput, UserMonthlyBalanceUncheckedUpdateInput>
  }

  /**
   * UserMonthlyBalance delete
   */
  export type UserMonthlyBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
    /**
     * Filter which UserMonthlyBalance to delete.
     */
    where: UserMonthlyBalanceWhereUniqueInput
  }

  /**
   * UserMonthlyBalance deleteMany
   */
  export type UserMonthlyBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyBalances to delete
     */
    where?: UserMonthlyBalanceWhereInput
    /**
     * Limit how many UserMonthlyBalances to delete.
     */
    limit?: number
  }

  /**
   * UserMonthlyBalance without action
   */
  export type UserMonthlyBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyBalance
     */
    select?: UserMonthlyBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyBalance
     */
    omit?: UserMonthlyBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyBalanceInclude<ExtArgs> | null
  }


  /**
   * Model UserPlan
   */

  export type AggregateUserPlan = {
    _count: UserPlanCountAggregateOutputType | null
    _min: UserPlanMinAggregateOutputType | null
    _max: UserPlanMaxAggregateOutputType | null
  }

  export type UserPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastCreditsGrantedAt: Date | null
    paypalSubscriptionId: string | null
  }

  export type UserPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastCreditsGrantedAt: Date | null
    paypalSubscriptionId: string | null
  }

  export type UserPlanCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    createdAt: number
    updatedAt: number
    lastCreditsGrantedAt: number
    paypalSubscriptionId: number
    _all: number
  }


  export type UserPlanMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    lastCreditsGrantedAt?: true
    paypalSubscriptionId?: true
  }

  export type UserPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    lastCreditsGrantedAt?: true
    paypalSubscriptionId?: true
  }

  export type UserPlanCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    lastCreditsGrantedAt?: true
    paypalSubscriptionId?: true
    _all?: true
  }

  export type UserPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPlan to aggregate.
     */
    where?: UserPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlans to fetch.
     */
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPlans
    **/
    _count?: true | UserPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPlanMaxAggregateInputType
  }

  export type GetUserPlanAggregateType<T extends UserPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPlan[P]>
      : GetScalarType<T[P], AggregateUserPlan[P]>
  }




  export type UserPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPlanWhereInput
    orderBy?: UserPlanOrderByWithAggregationInput | UserPlanOrderByWithAggregationInput[]
    by: UserPlanScalarFieldEnum[] | UserPlanScalarFieldEnum
    having?: UserPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPlanCountAggregateInputType | true
    _min?: UserPlanMinAggregateInputType
    _max?: UserPlanMaxAggregateInputType
  }

  export type UserPlanGroupByOutputType = {
    id: string
    userId: string
    planId: string
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    createdAt: Date
    updatedAt: Date
    lastCreditsGrantedAt: Date | null
    paypalSubscriptionId: string | null
    _count: UserPlanCountAggregateOutputType | null
    _min: UserPlanMinAggregateOutputType | null
    _max: UserPlanMaxAggregateOutputType | null
  }

  type GetUserPlanGroupByPayload<T extends UserPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPlanGroupByOutputType[P]>
            : GetScalarType<T[P], UserPlanGroupByOutputType[P]>
        }
      >
    >


  export type UserPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastCreditsGrantedAt?: boolean
    paypalSubscriptionId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlan"]>

  export type UserPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastCreditsGrantedAt?: boolean
    paypalSubscriptionId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlan"]>

  export type UserPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastCreditsGrantedAt?: boolean
    paypalSubscriptionId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlan"]>

  export type UserPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastCreditsGrantedAt?: boolean
    paypalSubscriptionId?: boolean
  }

  export type UserPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "status" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "canceledAt" | "createdAt" | "updatedAt" | "lastCreditsGrantedAt" | "paypalSubscriptionId", ExtArgs["result"]["userPlan"]>
  export type UserPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type UserPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type UserPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $UserPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      status: $Enums.SubscriptionStatus
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      createdAt: Date
      updatedAt: Date
      lastCreditsGrantedAt: Date | null
      paypalSubscriptionId: string | null
    }, ExtArgs["result"]["userPlan"]>
    composites: {}
  }

  type UserPlanGetPayload<S extends boolean | null | undefined | UserPlanDefaultArgs> = $Result.GetResult<Prisma.$UserPlanPayload, S>

  type UserPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPlanCountAggregateInputType | true
    }

  export interface UserPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPlan'], meta: { name: 'UserPlan' } }
    /**
     * Find zero or one UserPlan that matches the filter.
     * @param {UserPlanFindUniqueArgs} args - Arguments to find a UserPlan
     * @example
     * // Get one UserPlan
     * const userPlan = await prisma.userPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPlanFindUniqueArgs>(args: SelectSubset<T, UserPlanFindUniqueArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPlanFindUniqueOrThrowArgs} args - Arguments to find a UserPlan
     * @example
     * // Get one UserPlan
     * const userPlan = await prisma.userPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanFindFirstArgs} args - Arguments to find a UserPlan
     * @example
     * // Get one UserPlan
     * const userPlan = await prisma.userPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPlanFindFirstArgs>(args?: SelectSubset<T, UserPlanFindFirstArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanFindFirstOrThrowArgs} args - Arguments to find a UserPlan
     * @example
     * // Get one UserPlan
     * const userPlan = await prisma.userPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPlans
     * const userPlans = await prisma.userPlan.findMany()
     * 
     * // Get first 10 UserPlans
     * const userPlans = await prisma.userPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPlanWithIdOnly = await prisma.userPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPlanFindManyArgs>(args?: SelectSubset<T, UserPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPlan.
     * @param {UserPlanCreateArgs} args - Arguments to create a UserPlan.
     * @example
     * // Create one UserPlan
     * const UserPlan = await prisma.userPlan.create({
     *   data: {
     *     // ... data to create a UserPlan
     *   }
     * })
     * 
     */
    create<T extends UserPlanCreateArgs>(args: SelectSubset<T, UserPlanCreateArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPlans.
     * @param {UserPlanCreateManyArgs} args - Arguments to create many UserPlans.
     * @example
     * // Create many UserPlans
     * const userPlan = await prisma.userPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPlanCreateManyArgs>(args?: SelectSubset<T, UserPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPlans and returns the data saved in the database.
     * @param {UserPlanCreateManyAndReturnArgs} args - Arguments to create many UserPlans.
     * @example
     * // Create many UserPlans
     * const userPlan = await prisma.userPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPlans and only return the `id`
     * const userPlanWithIdOnly = await prisma.userPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPlan.
     * @param {UserPlanDeleteArgs} args - Arguments to delete one UserPlan.
     * @example
     * // Delete one UserPlan
     * const UserPlan = await prisma.userPlan.delete({
     *   where: {
     *     // ... filter to delete one UserPlan
     *   }
     * })
     * 
     */
    delete<T extends UserPlanDeleteArgs>(args: SelectSubset<T, UserPlanDeleteArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPlan.
     * @param {UserPlanUpdateArgs} args - Arguments to update one UserPlan.
     * @example
     * // Update one UserPlan
     * const userPlan = await prisma.userPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPlanUpdateArgs>(args: SelectSubset<T, UserPlanUpdateArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPlans.
     * @param {UserPlanDeleteManyArgs} args - Arguments to filter UserPlans to delete.
     * @example
     * // Delete a few UserPlans
     * const { count } = await prisma.userPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPlanDeleteManyArgs>(args?: SelectSubset<T, UserPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPlans
     * const userPlan = await prisma.userPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPlanUpdateManyArgs>(args: SelectSubset<T, UserPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPlans and returns the data updated in the database.
     * @param {UserPlanUpdateManyAndReturnArgs} args - Arguments to update many UserPlans.
     * @example
     * // Update many UserPlans
     * const userPlan = await prisma.userPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPlans and only return the `id`
     * const userPlanWithIdOnly = await prisma.userPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPlan.
     * @param {UserPlanUpsertArgs} args - Arguments to update or create a UserPlan.
     * @example
     * // Update or create a UserPlan
     * const userPlan = await prisma.userPlan.upsert({
     *   create: {
     *     // ... data to create a UserPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPlan we want to update
     *   }
     * })
     */
    upsert<T extends UserPlanUpsertArgs>(args: SelectSubset<T, UserPlanUpsertArgs<ExtArgs>>): Prisma__UserPlanClient<$Result.GetResult<Prisma.$UserPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanCountArgs} args - Arguments to filter UserPlans to count.
     * @example
     * // Count the number of UserPlans
     * const count = await prisma.userPlan.count({
     *   where: {
     *     // ... the filter for the UserPlans we want to count
     *   }
     * })
    **/
    count<T extends UserPlanCountArgs>(
      args?: Subset<T, UserPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPlanAggregateArgs>(args: Subset<T, UserPlanAggregateArgs>): Prisma.PrismaPromise<GetUserPlanAggregateType<T>>

    /**
     * Group by UserPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPlanGroupByArgs['orderBy'] }
        : { orderBy?: UserPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPlan model
   */
  readonly fields: UserPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPlan model
   */
  interface UserPlanFieldRefs {
    readonly id: FieldRef<"UserPlan", 'String'>
    readonly userId: FieldRef<"UserPlan", 'String'>
    readonly planId: FieldRef<"UserPlan", 'String'>
    readonly status: FieldRef<"UserPlan", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"UserPlan", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"UserPlan", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"UserPlan", 'Boolean'>
    readonly canceledAt: FieldRef<"UserPlan", 'DateTime'>
    readonly createdAt: FieldRef<"UserPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPlan", 'DateTime'>
    readonly lastCreditsGrantedAt: FieldRef<"UserPlan", 'DateTime'>
    readonly paypalSubscriptionId: FieldRef<"UserPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserPlan findUnique
   */
  export type UserPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter, which UserPlan to fetch.
     */
    where: UserPlanWhereUniqueInput
  }

  /**
   * UserPlan findUniqueOrThrow
   */
  export type UserPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter, which UserPlan to fetch.
     */
    where: UserPlanWhereUniqueInput
  }

  /**
   * UserPlan findFirst
   */
  export type UserPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter, which UserPlan to fetch.
     */
    where?: UserPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlans to fetch.
     */
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPlans.
     */
    cursor?: UserPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPlans.
     */
    distinct?: UserPlanScalarFieldEnum | UserPlanScalarFieldEnum[]
  }

  /**
   * UserPlan findFirstOrThrow
   */
  export type UserPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter, which UserPlan to fetch.
     */
    where?: UserPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlans to fetch.
     */
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPlans.
     */
    cursor?: UserPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPlans.
     */
    distinct?: UserPlanScalarFieldEnum | UserPlanScalarFieldEnum[]
  }

  /**
   * UserPlan findMany
   */
  export type UserPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter, which UserPlans to fetch.
     */
    where?: UserPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlans to fetch.
     */
    orderBy?: UserPlanOrderByWithRelationInput | UserPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPlans.
     */
    cursor?: UserPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlans.
     */
    skip?: number
    distinct?: UserPlanScalarFieldEnum | UserPlanScalarFieldEnum[]
  }

  /**
   * UserPlan create
   */
  export type UserPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPlan.
     */
    data: XOR<UserPlanCreateInput, UserPlanUncheckedCreateInput>
  }

  /**
   * UserPlan createMany
   */
  export type UserPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPlans.
     */
    data: UserPlanCreateManyInput | UserPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPlan createManyAndReturn
   */
  export type UserPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * The data used to create many UserPlans.
     */
    data: UserPlanCreateManyInput | UserPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPlan update
   */
  export type UserPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPlan.
     */
    data: XOR<UserPlanUpdateInput, UserPlanUncheckedUpdateInput>
    /**
     * Choose, which UserPlan to update.
     */
    where: UserPlanWhereUniqueInput
  }

  /**
   * UserPlan updateMany
   */
  export type UserPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPlans.
     */
    data: XOR<UserPlanUpdateManyMutationInput, UserPlanUncheckedUpdateManyInput>
    /**
     * Filter which UserPlans to update
     */
    where?: UserPlanWhereInput
    /**
     * Limit how many UserPlans to update.
     */
    limit?: number
  }

  /**
   * UserPlan updateManyAndReturn
   */
  export type UserPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * The data used to update UserPlans.
     */
    data: XOR<UserPlanUpdateManyMutationInput, UserPlanUncheckedUpdateManyInput>
    /**
     * Filter which UserPlans to update
     */
    where?: UserPlanWhereInput
    /**
     * Limit how many UserPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPlan upsert
   */
  export type UserPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPlan to update in case it exists.
     */
    where: UserPlanWhereUniqueInput
    /**
     * In case the UserPlan found by the `where` argument doesn't exist, create a new UserPlan with this data.
     */
    create: XOR<UserPlanCreateInput, UserPlanUncheckedCreateInput>
    /**
     * In case the UserPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPlanUpdateInput, UserPlanUncheckedUpdateInput>
  }

  /**
   * UserPlan delete
   */
  export type UserPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
    /**
     * Filter which UserPlan to delete.
     */
    where: UserPlanWhereUniqueInput
  }

  /**
   * UserPlan deleteMany
   */
  export type UserPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPlans to delete
     */
    where?: UserPlanWhereInput
    /**
     * Limit how many UserPlans to delete.
     */
    limit?: number
  }

  /**
   * UserPlan without action
   */
  export type UserPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlan
     */
    select?: UserPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlan
     */
    omit?: UserPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlanInclude<ExtArgs> | null
  }


  /**
   * Model UserPlusAccess
   */

  export type AggregateUserPlusAccess = {
    _count: UserPlusAccessCountAggregateOutputType | null
    _min: UserPlusAccessMinAggregateOutputType | null
    _max: UserPlusAccessMaxAggregateOutputType | null
  }

  export type UserPlusAccessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    grantedBy: string | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPlusAccessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    grantedBy: string | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPlusAccessCountAggregateOutputType = {
    id: number
    userId: number
    grantedBy: number
    reason: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPlusAccessMinAggregateInputType = {
    id?: true
    userId?: true
    grantedBy?: true
    reason?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPlusAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    grantedBy?: true
    reason?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPlusAccessCountAggregateInputType = {
    id?: true
    userId?: true
    grantedBy?: true
    reason?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPlusAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPlusAccess to aggregate.
     */
    where?: UserPlusAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlusAccesses to fetch.
     */
    orderBy?: UserPlusAccessOrderByWithRelationInput | UserPlusAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPlusAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlusAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlusAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPlusAccesses
    **/
    _count?: true | UserPlusAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPlusAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPlusAccessMaxAggregateInputType
  }

  export type GetUserPlusAccessAggregateType<T extends UserPlusAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPlusAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPlusAccess[P]>
      : GetScalarType<T[P], AggregateUserPlusAccess[P]>
  }




  export type UserPlusAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPlusAccessWhereInput
    orderBy?: UserPlusAccessOrderByWithAggregationInput | UserPlusAccessOrderByWithAggregationInput[]
    by: UserPlusAccessScalarFieldEnum[] | UserPlusAccessScalarFieldEnum
    having?: UserPlusAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPlusAccessCountAggregateInputType | true
    _min?: UserPlusAccessMinAggregateInputType
    _max?: UserPlusAccessMaxAggregateInputType
  }

  export type UserPlusAccessGroupByOutputType = {
    id: string
    userId: string
    grantedBy: string | null
    reason: string | null
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPlusAccessCountAggregateOutputType | null
    _min: UserPlusAccessMinAggregateOutputType | null
    _max: UserPlusAccessMaxAggregateOutputType | null
  }

  type GetUserPlusAccessGroupByPayload<T extends UserPlusAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPlusAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPlusAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPlusAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserPlusAccessGroupByOutputType[P]>
        }
      >
    >


  export type UserPlusAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    grantedBy?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlusAccess"]>

  export type UserPlusAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    grantedBy?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlusAccess"]>

  export type UserPlusAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    grantedBy?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPlusAccess"]>

  export type UserPlusAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    grantedBy?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPlusAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "grantedBy" | "reason" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["userPlusAccess"]>
  export type UserPlusAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPlusAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPlusAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPlusAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPlusAccess"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      grantedBy: string | null
      reason: string | null
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPlusAccess"]>
    composites: {}
  }

  type UserPlusAccessGetPayload<S extends boolean | null | undefined | UserPlusAccessDefaultArgs> = $Result.GetResult<Prisma.$UserPlusAccessPayload, S>

  type UserPlusAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPlusAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPlusAccessCountAggregateInputType | true
    }

  export interface UserPlusAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPlusAccess'], meta: { name: 'UserPlusAccess' } }
    /**
     * Find zero or one UserPlusAccess that matches the filter.
     * @param {UserPlusAccessFindUniqueArgs} args - Arguments to find a UserPlusAccess
     * @example
     * // Get one UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPlusAccessFindUniqueArgs>(args: SelectSubset<T, UserPlusAccessFindUniqueArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPlusAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPlusAccessFindUniqueOrThrowArgs} args - Arguments to find a UserPlusAccess
     * @example
     * // Get one UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPlusAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPlusAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPlusAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessFindFirstArgs} args - Arguments to find a UserPlusAccess
     * @example
     * // Get one UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPlusAccessFindFirstArgs>(args?: SelectSubset<T, UserPlusAccessFindFirstArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPlusAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessFindFirstOrThrowArgs} args - Arguments to find a UserPlusAccess
     * @example
     * // Get one UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPlusAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPlusAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPlusAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPlusAccesses
     * const userPlusAccesses = await prisma.userPlusAccess.findMany()
     * 
     * // Get first 10 UserPlusAccesses
     * const userPlusAccesses = await prisma.userPlusAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPlusAccessWithIdOnly = await prisma.userPlusAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPlusAccessFindManyArgs>(args?: SelectSubset<T, UserPlusAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPlusAccess.
     * @param {UserPlusAccessCreateArgs} args - Arguments to create a UserPlusAccess.
     * @example
     * // Create one UserPlusAccess
     * const UserPlusAccess = await prisma.userPlusAccess.create({
     *   data: {
     *     // ... data to create a UserPlusAccess
     *   }
     * })
     * 
     */
    create<T extends UserPlusAccessCreateArgs>(args: SelectSubset<T, UserPlusAccessCreateArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPlusAccesses.
     * @param {UserPlusAccessCreateManyArgs} args - Arguments to create many UserPlusAccesses.
     * @example
     * // Create many UserPlusAccesses
     * const userPlusAccess = await prisma.userPlusAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPlusAccessCreateManyArgs>(args?: SelectSubset<T, UserPlusAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPlusAccesses and returns the data saved in the database.
     * @param {UserPlusAccessCreateManyAndReturnArgs} args - Arguments to create many UserPlusAccesses.
     * @example
     * // Create many UserPlusAccesses
     * const userPlusAccess = await prisma.userPlusAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPlusAccesses and only return the `id`
     * const userPlusAccessWithIdOnly = await prisma.userPlusAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPlusAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPlusAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPlusAccess.
     * @param {UserPlusAccessDeleteArgs} args - Arguments to delete one UserPlusAccess.
     * @example
     * // Delete one UserPlusAccess
     * const UserPlusAccess = await prisma.userPlusAccess.delete({
     *   where: {
     *     // ... filter to delete one UserPlusAccess
     *   }
     * })
     * 
     */
    delete<T extends UserPlusAccessDeleteArgs>(args: SelectSubset<T, UserPlusAccessDeleteArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPlusAccess.
     * @param {UserPlusAccessUpdateArgs} args - Arguments to update one UserPlusAccess.
     * @example
     * // Update one UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPlusAccessUpdateArgs>(args: SelectSubset<T, UserPlusAccessUpdateArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPlusAccesses.
     * @param {UserPlusAccessDeleteManyArgs} args - Arguments to filter UserPlusAccesses to delete.
     * @example
     * // Delete a few UserPlusAccesses
     * const { count } = await prisma.userPlusAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPlusAccessDeleteManyArgs>(args?: SelectSubset<T, UserPlusAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPlusAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPlusAccesses
     * const userPlusAccess = await prisma.userPlusAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPlusAccessUpdateManyArgs>(args: SelectSubset<T, UserPlusAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPlusAccesses and returns the data updated in the database.
     * @param {UserPlusAccessUpdateManyAndReturnArgs} args - Arguments to update many UserPlusAccesses.
     * @example
     * // Update many UserPlusAccesses
     * const userPlusAccess = await prisma.userPlusAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPlusAccesses and only return the `id`
     * const userPlusAccessWithIdOnly = await prisma.userPlusAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPlusAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPlusAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPlusAccess.
     * @param {UserPlusAccessUpsertArgs} args - Arguments to update or create a UserPlusAccess.
     * @example
     * // Update or create a UserPlusAccess
     * const userPlusAccess = await prisma.userPlusAccess.upsert({
     *   create: {
     *     // ... data to create a UserPlusAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPlusAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserPlusAccessUpsertArgs>(args: SelectSubset<T, UserPlusAccessUpsertArgs<ExtArgs>>): Prisma__UserPlusAccessClient<$Result.GetResult<Prisma.$UserPlusAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPlusAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessCountArgs} args - Arguments to filter UserPlusAccesses to count.
     * @example
     * // Count the number of UserPlusAccesses
     * const count = await prisma.userPlusAccess.count({
     *   where: {
     *     // ... the filter for the UserPlusAccesses we want to count
     *   }
     * })
    **/
    count<T extends UserPlusAccessCountArgs>(
      args?: Subset<T, UserPlusAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPlusAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPlusAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPlusAccessAggregateArgs>(args: Subset<T, UserPlusAccessAggregateArgs>): Prisma.PrismaPromise<GetUserPlusAccessAggregateType<T>>

    /**
     * Group by UserPlusAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPlusAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPlusAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPlusAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserPlusAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPlusAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPlusAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPlusAccess model
   */
  readonly fields: UserPlusAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPlusAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPlusAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPlusAccess model
   */
  interface UserPlusAccessFieldRefs {
    readonly id: FieldRef<"UserPlusAccess", 'String'>
    readonly userId: FieldRef<"UserPlusAccess", 'String'>
    readonly grantedBy: FieldRef<"UserPlusAccess", 'String'>
    readonly reason: FieldRef<"UserPlusAccess", 'String'>
    readonly startDate: FieldRef<"UserPlusAccess", 'DateTime'>
    readonly endDate: FieldRef<"UserPlusAccess", 'DateTime'>
    readonly isActive: FieldRef<"UserPlusAccess", 'Boolean'>
    readonly createdAt: FieldRef<"UserPlusAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPlusAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPlusAccess findUnique
   */
  export type UserPlusAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserPlusAccess to fetch.
     */
    where: UserPlusAccessWhereUniqueInput
  }

  /**
   * UserPlusAccess findUniqueOrThrow
   */
  export type UserPlusAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserPlusAccess to fetch.
     */
    where: UserPlusAccessWhereUniqueInput
  }

  /**
   * UserPlusAccess findFirst
   */
  export type UserPlusAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserPlusAccess to fetch.
     */
    where?: UserPlusAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlusAccesses to fetch.
     */
    orderBy?: UserPlusAccessOrderByWithRelationInput | UserPlusAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPlusAccesses.
     */
    cursor?: UserPlusAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlusAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlusAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPlusAccesses.
     */
    distinct?: UserPlusAccessScalarFieldEnum | UserPlusAccessScalarFieldEnum[]
  }

  /**
   * UserPlusAccess findFirstOrThrow
   */
  export type UserPlusAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserPlusAccess to fetch.
     */
    where?: UserPlusAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlusAccesses to fetch.
     */
    orderBy?: UserPlusAccessOrderByWithRelationInput | UserPlusAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPlusAccesses.
     */
    cursor?: UserPlusAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlusAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlusAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPlusAccesses.
     */
    distinct?: UserPlusAccessScalarFieldEnum | UserPlusAccessScalarFieldEnum[]
  }

  /**
   * UserPlusAccess findMany
   */
  export type UserPlusAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserPlusAccesses to fetch.
     */
    where?: UserPlusAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPlusAccesses to fetch.
     */
    orderBy?: UserPlusAccessOrderByWithRelationInput | UserPlusAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPlusAccesses.
     */
    cursor?: UserPlusAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPlusAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPlusAccesses.
     */
    skip?: number
    distinct?: UserPlusAccessScalarFieldEnum | UserPlusAccessScalarFieldEnum[]
  }

  /**
   * UserPlusAccess create
   */
  export type UserPlusAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPlusAccess.
     */
    data: XOR<UserPlusAccessCreateInput, UserPlusAccessUncheckedCreateInput>
  }

  /**
   * UserPlusAccess createMany
   */
  export type UserPlusAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPlusAccesses.
     */
    data: UserPlusAccessCreateManyInput | UserPlusAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPlusAccess createManyAndReturn
   */
  export type UserPlusAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * The data used to create many UserPlusAccesses.
     */
    data: UserPlusAccessCreateManyInput | UserPlusAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPlusAccess update
   */
  export type UserPlusAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPlusAccess.
     */
    data: XOR<UserPlusAccessUpdateInput, UserPlusAccessUncheckedUpdateInput>
    /**
     * Choose, which UserPlusAccess to update.
     */
    where: UserPlusAccessWhereUniqueInput
  }

  /**
   * UserPlusAccess updateMany
   */
  export type UserPlusAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPlusAccesses.
     */
    data: XOR<UserPlusAccessUpdateManyMutationInput, UserPlusAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserPlusAccesses to update
     */
    where?: UserPlusAccessWhereInput
    /**
     * Limit how many UserPlusAccesses to update.
     */
    limit?: number
  }

  /**
   * UserPlusAccess updateManyAndReturn
   */
  export type UserPlusAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * The data used to update UserPlusAccesses.
     */
    data: XOR<UserPlusAccessUpdateManyMutationInput, UserPlusAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserPlusAccesses to update
     */
    where?: UserPlusAccessWhereInput
    /**
     * Limit how many UserPlusAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPlusAccess upsert
   */
  export type UserPlusAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPlusAccess to update in case it exists.
     */
    where: UserPlusAccessWhereUniqueInput
    /**
     * In case the UserPlusAccess found by the `where` argument doesn't exist, create a new UserPlusAccess with this data.
     */
    create: XOR<UserPlusAccessCreateInput, UserPlusAccessUncheckedCreateInput>
    /**
     * In case the UserPlusAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPlusAccessUpdateInput, UserPlusAccessUncheckedUpdateInput>
  }

  /**
   * UserPlusAccess delete
   */
  export type UserPlusAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
    /**
     * Filter which UserPlusAccess to delete.
     */
    where: UserPlusAccessWhereUniqueInput
  }

  /**
   * UserPlusAccess deleteMany
   */
  export type UserPlusAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPlusAccesses to delete
     */
    where?: UserPlusAccessWhereInput
    /**
     * Limit how many UserPlusAccesses to delete.
     */
    limit?: number
  }

  /**
   * UserPlusAccess without action
   */
  export type UserPlusAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPlusAccess
     */
    select?: UserPlusAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPlusAccess
     */
    omit?: UserPlusAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPlusAccessInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    username: 'username',
    email: 'email',
    displayName: 'displayName',
    fullName: 'fullName',
    avatarUrl: 'avatarUrl',
    avatarSource: 'avatarSource',
    avatarUpdatedAt: 'avatarUpdatedAt',
    birthDate: 'birthDate',
    gender: 'gender',
    preferredLanguage: 'preferredLanguage',
    role: 'role',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    maxAgeRating: 'maxAgeRating',
    blockedTags: 'blockedTags'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ContentClassificationScalarFieldEnum: {
    id: 'id',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    reason: 'reason',
    contentType: 'contentType',
    contentId: 'contentId',
    autoClassified: 'autoClassified',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentClassificationScalarFieldEnum = (typeof ContentClassificationScalarFieldEnum)[keyof typeof ContentClassificationScalarFieldEnum]


  export const LoraScalarFieldEnum: {
    id: 'id',
    civitaiModelId: 'civitaiModelId',
    civitaiVersionId: 'civitaiVersionId',
    name: 'name',
    modelType: 'modelType',
    baseModel: 'baseModel',
    downloadCount: 'downloadCount',
    modelUrl: 'modelUrl',
    tags: 'tags',
    trainedWords: 'trainedWords',
    nsfw: 'nsfw',
    filename: 'filename',
    filepathRelative: 'filepathRelative',
    firstImageUrl: 'firstImageUrl',
    imageUrls: 'imageUrls',
    category: 'category',
    term: 'term',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoraScalarFieldEnum = (typeof LoraScalarFieldEnum)[keyof typeof LoraScalarFieldEnum]


  export const AttireScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    gender: 'gender',
    promptHead: 'promptHead',
    promptBody: 'promptBody',
    promptFull: 'promptFull',
    previewImageUrl: 'previewImageUrl',
    originalLanguageCode: 'originalLanguageCode',
    visibility: 'visibility',
    userId: 'userId',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    contentVersion: 'contentVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttireScalarFieldEnum = (typeof AttireScalarFieldEnum)[keyof typeof AttireScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    originalLanguageCode: 'originalLanguageCode',
    weight: 'weight',
    searchable: 'searchable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    age: 'age',
    gender: 'gender',
    species: 'species',
    style: 'style',
    reference: 'reference',
    physicalCharacteristics: 'physicalCharacteristics',
    personality: 'personality',
    history: 'history',
    visibility: 'visibility',
    isSystemCharacter: 'isSystemCharacter',
    originalLanguageCode: 'originalLanguageCode',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    userId: 'userId',
    loraId: 'loraId',
    mainAttireId: 'mainAttireId',
    contentVersion: 'contentVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacterStickerScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    emotionTag: 'emotionTag',
    actionTag: 'actionTag',
    imageUrl: 'imageUrl',
    promptUsed: 'promptUsed',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterStickerScalarFieldEnum = (typeof CharacterStickerScalarFieldEnum)[keyof typeof CharacterStickerScalarFieldEnum]


  export const CharacterImageScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    type: 'type',
    url: 'url',
    key: 'key',
    width: 'width',
    height: 'height',
    sizeBytes: 'sizeBytes',
    contentType: 'contentType',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterImageScalarFieldEnum = (typeof CharacterImageScalarFieldEnum)[keyof typeof CharacterImageScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    synopsis: 'synopsis',
    initialText: 'initialText',
    coverImage: 'coverImage',
    objectives: 'objectives',
    authorId: 'authorId',
    ageRating: 'ageRating',
    contentTags: 'contentTags',
    visibility: 'visibility',
    contentVersion: 'contentVersion',
    originalLanguageCode: 'originalLanguageCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const AssistantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    instructions: 'instructions',
    defaultCharacterId: 'defaultCharacterId',
    visibility: 'visibility',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssistantScalarFieldEnum = (typeof AssistantScalarFieldEnum)[keyof typeof AssistantScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isTitleUserEdited: 'isTitleUserEdited',
    isTitleSystemEdited: 'isTitleSystemEdited',
    projectId: 'projectId',
    storyId: 'storyId',
    settings: 'settings',
    lastMessageAt: 'lastMessageAt',
    titleLastUpdatedAt: 'titleLastUpdatedAt',
    memoryLastUpdatedAt: 'memoryLastUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    isMultiUser: 'isMultiUser',
    maxUsers: 'maxUsers',
    ownerUserId: 'ownerUserId',
    allowUserInvites: 'allowUserInvites',
    requireApproval: 'requireApproval'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const UserConversationMembershipScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    role: 'role',
    canWrite: 'canWrite',
    canInvite: 'canInvite',
    canModerate: 'canModerate',
    joinedAt: 'joinedAt',
    invitedBy: 'invitedBy',
    isActive: 'isActive'
  };

  export type UserConversationMembershipScalarFieldEnum = (typeof UserConversationMembershipScalarFieldEnum)[keyof typeof UserConversationMembershipScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    actingCharacterId: 'actingCharacterId',
    actingAssistantId: 'actingAssistantId',
    representingCharacterId: 'representingCharacterId',
    configOverride: 'configOverride',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    senderType: 'senderType',
    content: 'content',
    attachments: 'attachments',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FavoriteCharacterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    characterId: 'characterId',
    createdAt: 'createdAt'
  };

  export type FavoriteCharacterScalarFieldEnum = (typeof FavoriteCharacterScalarFieldEnum)[keyof typeof FavoriteCharacterScalarFieldEnum]


  export const ContentTranslationScalarFieldEnum: {
    id: 'id',
    contentType: 'contentType',
    contentId: 'contentId',
    fieldName: 'fieldName',
    originalLanguageCode: 'originalLanguageCode',
    targetLanguageCode: 'targetLanguageCode',
    originalText: 'originalText',
    translatedText: 'translatedText',
    translationProvider: 'translationProvider',
    translationModel: 'translationModel',
    confidence: 'confidence',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    translationTimeMs: 'translationTimeMs',
    characterCount: 'characterCount',
    sourceVersion: 'sourceVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentTranslationScalarFieldEnum = (typeof ContentTranslationScalarFieldEnum)[keyof typeof ContentTranslationScalarFieldEnum]


  export const ConversationMemoryScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    summary: 'summary',
    keyEvents: 'keyEvents',
    messageCount: 'messageCount',
    startMessageId: 'startMessageId',
    endMessageId: 'endMessageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationMemoryScalarFieldEnum = (typeof ConversationMemoryScalarFieldEnum)[keyof typeof ConversationMemoryScalarFieldEnum]


  export const CreditTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionType: 'transactionType',
    amountCredits: 'amountCredits',
    balanceAfter: 'balanceAfter',
    notes: 'notes',
    relatedUsageLogId: 'relatedUsageLogId',
    relatedPlanId: 'relatedPlanId',
    timestamp: 'timestamp'
  };

  export type CreditTransactionScalarFieldEnum = (typeof CreditTransactionScalarFieldEnum)[keyof typeof CreditTransactionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    tier: 'tier',
    name: 'name',
    priceMonthly: 'priceMonthly',
    creditsPerMonth: 'creditsPerMonth',
    description: 'description',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paypalPlanId: 'paypalPlanId'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const ServiceCreditCostScalarFieldEnum: {
    id: 'id',
    serviceIdentifier: 'serviceIdentifier',
    creditsPerUnit: 'creditsPerUnit',
    unitDescription: 'unitDescription',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCreditCostScalarFieldEnum = (typeof ServiceCreditCostScalarFieldEnum)[keyof typeof ServiceCreditCostScalarFieldEnum]


  export const UsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    conversationId: 'conversationId',
    serviceType: 'serviceType',
    providerName: 'providerName',
    modelName: 'modelName',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    charactersProcessed: 'charactersProcessed',
    imagesProcessed: 'imagesProcessed',
    costUsd: 'costUsd',
    creditsConsumed: 'creditsConsumed',
    additionalMetadata: 'additionalMetadata',
    processed: 'processed',
    processedAt: 'processedAt',
    timestamp: 'timestamp'
  };

  export type UsageLogScalarFieldEnum = (typeof UsageLogScalarFieldEnum)[keyof typeof UsageLogScalarFieldEnum]


  export const UserMonthlyBalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    monthStartDate: 'monthStartDate',
    startingBalance: 'startingBalance',
    creditsGranted: 'creditsGranted',
    creditsSpent: 'creditsSpent',
    endingBalance: 'endingBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserMonthlyBalanceScalarFieldEnum = (typeof UserMonthlyBalanceScalarFieldEnum)[keyof typeof UserMonthlyBalanceScalarFieldEnum]


  export const UserPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastCreditsGrantedAt: 'lastCreditsGrantedAt',
    paypalSubscriptionId: 'paypalSubscriptionId'
  };

  export type UserPlanScalarFieldEnum = (typeof UserPlanScalarFieldEnum)[keyof typeof UserPlanScalarFieldEnum]


  export const UserPlusAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    grantedBy: 'grantedBy',
    reason: 'reason',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPlusAccessScalarFieldEnum = (typeof UserPlusAccessScalarFieldEnum)[keyof typeof UserPlusAccessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'AvatarSource'
   */
  export type EnumAvatarSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvatarSource'>
    


  /**
   * Reference to a field of type 'AvatarSource[]'
   */
  export type ListEnumAvatarSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvatarSource[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AgeRating'
   */
  export type EnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating'>
    


  /**
   * Reference to a field of type 'AgeRating[]'
   */
  export type ListEnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating[]'>
    


  /**
   * Reference to a field of type 'ContentTag[]'
   */
  export type ListEnumContentTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentTag[]'>
    


  /**
   * Reference to a field of type 'ContentTag'
   */
  export type EnumContentTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentTag'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'TagType'
   */
  export type EnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType'>
    


  /**
   * Reference to a field of type 'TagType[]'
   */
  export type ListEnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType[]'>
    


  /**
   * Reference to a field of type 'VisualStyle'
   */
  export type EnumVisualStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisualStyle'>
    


  /**
   * Reference to a field of type 'VisualStyle[]'
   */
  export type ListEnumVisualStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisualStyle[]'>
    


  /**
   * Reference to a field of type 'StickerStatus'
   */
  export type EnumStickerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickerStatus'>
    


  /**
   * Reference to a field of type 'StickerStatus[]'
   */
  export type ListEnumStickerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickerStatus[]'>
    


  /**
   * Reference to a field of type 'ImageType'
   */
  export type EnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType'>
    


  /**
   * Reference to a field of type 'ImageType[]'
   */
  export type ListEnumImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MembershipRole'
   */
  export type EnumMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipRole'>
    


  /**
   * Reference to a field of type 'MembershipRole[]'
   */
  export type ListEnumMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipRole[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TranslationStatus'
   */
  export type EnumTranslationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationStatus'>
    


  /**
   * Reference to a field of type 'TranslationStatus[]'
   */
  export type ListEnumTranslationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationStatus[]'>
    


  /**
   * Reference to a field of type 'CreditTransactionType'
   */
  export type EnumCreditTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditTransactionType'>
    


  /**
   * Reference to a field of type 'CreditTransactionType[]'
   */
  export type ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditTransactionType[]'>
    


  /**
   * Reference to a field of type 'PlanTier'
   */
  export type EnumPlanTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTier'>
    


  /**
   * Reference to a field of type 'PlanTier[]'
   */
  export type ListEnumPlanTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanTier[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    provider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    avatarSource?: EnumAvatarSourceFilter<"User"> | $Enums.AvatarSource
    avatarUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    lastLoginAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    maxAgeRating?: EnumAgeRatingFilter<"User"> | $Enums.AgeRating
    blockedTags?: EnumContentTagNullableListFilter<"User">
    createdCharacters?: CharacterListRelationFilter
    stories?: StoryListRelationFilter
    createdAttires?: AttireListRelationFilter
    assistants?: AssistantListRelationFilter
    conversations?: ConversationListRelationFilter
    conversationParticipations?: ConversationParticipantListRelationFilter
    ownedConversations?: ConversationListRelationFilter
    memberships?: UserConversationMembershipListRelationFilter
    sentInvites?: UserConversationMembershipListRelationFilter
    favoriteCharacters?: FavoriteCharacterListRelationFilter
    creditTransactions?: CreditTransactionListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    monthlyBalances?: UserMonthlyBalanceListRelationFilter
    userPlans?: UserPlanListRelationFilter
    plusAccessGrants?: UserPlusAccessListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    avatarSource?: SortOrder
    avatarUpdatedAt?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxAgeRating?: SortOrder
    blockedTags?: SortOrder
    createdCharacters?: CharacterOrderByRelationAggregateInput
    stories?: StoryOrderByRelationAggregateInput
    createdAttires?: AttireOrderByRelationAggregateInput
    assistants?: AssistantOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    conversationParticipations?: ConversationParticipantOrderByRelationAggregateInput
    ownedConversations?: ConversationOrderByRelationAggregateInput
    memberships?: UserConversationMembershipOrderByRelationAggregateInput
    sentInvites?: UserConversationMembershipOrderByRelationAggregateInput
    favoriteCharacters?: FavoriteCharacterOrderByRelationAggregateInput
    creditTransactions?: CreditTransactionOrderByRelationAggregateInput
    usageLogs?: UsageLogOrderByRelationAggregateInput
    monthlyBalances?: UserMonthlyBalanceOrderByRelationAggregateInput
    userPlans?: UserPlanOrderByRelationAggregateInput
    plusAccessGrants?: UserPlusAccessOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    provider_providerAccountId?: UserProviderProviderAccountIdCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    provider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    providerAccountId?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    avatarSource?: EnumAvatarSourceFilter<"User"> | $Enums.AvatarSource
    avatarUpdatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    lastLoginAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    maxAgeRating?: EnumAgeRatingFilter<"User"> | $Enums.AgeRating
    blockedTags?: EnumContentTagNullableListFilter<"User">
    createdCharacters?: CharacterListRelationFilter
    stories?: StoryListRelationFilter
    createdAttires?: AttireListRelationFilter
    assistants?: AssistantListRelationFilter
    conversations?: ConversationListRelationFilter
    conversationParticipations?: ConversationParticipantListRelationFilter
    ownedConversations?: ConversationListRelationFilter
    memberships?: UserConversationMembershipListRelationFilter
    sentInvites?: UserConversationMembershipListRelationFilter
    favoriteCharacters?: FavoriteCharacterListRelationFilter
    creditTransactions?: CreditTransactionListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    monthlyBalances?: UserMonthlyBalanceListRelationFilter
    userPlans?: UserPlanListRelationFilter
    plusAccessGrants?: UserPlusAccessListRelationFilter
  }, "id" | "username" | "email" | "provider_providerAccountId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    avatarSource?: SortOrder
    avatarUpdatedAt?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxAgeRating?: SortOrder
    blockedTags?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    provider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    providerAccountId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarSource?: EnumAvatarSourceWithAggregatesFilter<"User"> | $Enums.AvatarSource
    avatarUpdatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLanguage?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    lastLoginAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    maxAgeRating?: EnumAgeRatingWithAggregatesFilter<"User"> | $Enums.AgeRating
    blockedTags?: EnumContentTagNullableListFilter<"User">
  }

  export type ContentClassificationWhereInput = {
    AND?: ContentClassificationWhereInput | ContentClassificationWhereInput[]
    OR?: ContentClassificationWhereInput[]
    NOT?: ContentClassificationWhereInput | ContentClassificationWhereInput[]
    id?: StringFilter<"ContentClassification"> | string
    ageRating?: EnumAgeRatingFilter<"ContentClassification"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"ContentClassification">
    reason?: StringNullableFilter<"ContentClassification"> | string | null
    contentType?: StringFilter<"ContentClassification"> | string
    contentId?: StringFilter<"ContentClassification"> | string
    autoClassified?: BoolFilter<"ContentClassification"> | boolean
    reviewedBy?: StringNullableFilter<"ContentClassification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentClassification"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentClassification"> | Date | string
    updatedAt?: DateTimeFilter<"ContentClassification"> | Date | string
  }

  export type ContentClassificationOrderByWithRelationInput = {
    id?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    reason?: SortOrderInput | SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    autoClassified?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentType_contentId?: ContentClassificationContentTypeContentIdCompoundUniqueInput
    AND?: ContentClassificationWhereInput | ContentClassificationWhereInput[]
    OR?: ContentClassificationWhereInput[]
    NOT?: ContentClassificationWhereInput | ContentClassificationWhereInput[]
    ageRating?: EnumAgeRatingFilter<"ContentClassification"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"ContentClassification">
    reason?: StringNullableFilter<"ContentClassification"> | string | null
    contentType?: StringFilter<"ContentClassification"> | string
    contentId?: StringFilter<"ContentClassification"> | string
    autoClassified?: BoolFilter<"ContentClassification"> | boolean
    reviewedBy?: StringNullableFilter<"ContentClassification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentClassification"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentClassification"> | Date | string
    updatedAt?: DateTimeFilter<"ContentClassification"> | Date | string
  }, "id" | "contentType_contentId">

  export type ContentClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    reason?: SortOrderInput | SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    autoClassified?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentClassificationCountOrderByAggregateInput
    _max?: ContentClassificationMaxOrderByAggregateInput
    _min?: ContentClassificationMinOrderByAggregateInput
  }

  export type ContentClassificationScalarWhereWithAggregatesInput = {
    AND?: ContentClassificationScalarWhereWithAggregatesInput | ContentClassificationScalarWhereWithAggregatesInput[]
    OR?: ContentClassificationScalarWhereWithAggregatesInput[]
    NOT?: ContentClassificationScalarWhereWithAggregatesInput | ContentClassificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentClassification"> | string
    ageRating?: EnumAgeRatingWithAggregatesFilter<"ContentClassification"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"ContentClassification">
    reason?: StringNullableWithAggregatesFilter<"ContentClassification"> | string | null
    contentType?: StringWithAggregatesFilter<"ContentClassification"> | string
    contentId?: StringWithAggregatesFilter<"ContentClassification"> | string
    autoClassified?: BoolWithAggregatesFilter<"ContentClassification"> | boolean
    reviewedBy?: StringNullableWithAggregatesFilter<"ContentClassification"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ContentClassification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentClassification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentClassification"> | Date | string
  }

  export type LoraWhereInput = {
    AND?: LoraWhereInput | LoraWhereInput[]
    OR?: LoraWhereInput[]
    NOT?: LoraWhereInput | LoraWhereInput[]
    id?: StringFilter<"Lora"> | string
    civitaiModelId?: StringNullableFilter<"Lora"> | string | null
    civitaiVersionId?: StringNullableFilter<"Lora"> | string | null
    name?: StringFilter<"Lora"> | string
    modelType?: StringNullableFilter<"Lora"> | string | null
    baseModel?: StringNullableFilter<"Lora"> | string | null
    downloadCount?: IntNullableFilter<"Lora"> | number | null
    modelUrl?: StringNullableFilter<"Lora"> | string | null
    tags?: StringNullableListFilter<"Lora">
    trainedWords?: StringNullableListFilter<"Lora">
    nsfw?: BoolFilter<"Lora"> | boolean
    filename?: StringNullableFilter<"Lora"> | string | null
    filepathRelative?: StringNullableFilter<"Lora"> | string | null
    firstImageUrl?: StringNullableFilter<"Lora"> | string | null
    imageUrls?: StringNullableListFilter<"Lora">
    category?: StringNullableFilter<"Lora"> | string | null
    term?: StringNullableFilter<"Lora"> | string | null
    deleted?: BoolFilter<"Lora"> | boolean
    createdAt?: DateTimeFilter<"Lora"> | Date | string
    updatedAt?: DateTimeFilter<"Lora"> | Date | string
    characters?: CharacterListRelationFilter
  }

  export type LoraOrderByWithRelationInput = {
    id?: SortOrder
    civitaiModelId?: SortOrderInput | SortOrder
    civitaiVersionId?: SortOrderInput | SortOrder
    name?: SortOrder
    modelType?: SortOrderInput | SortOrder
    baseModel?: SortOrderInput | SortOrder
    downloadCount?: SortOrderInput | SortOrder
    modelUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    trainedWords?: SortOrder
    nsfw?: SortOrder
    filename?: SortOrderInput | SortOrder
    filepathRelative?: SortOrderInput | SortOrder
    firstImageUrl?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    category?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type LoraWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    civitaiVersionId?: string
    AND?: LoraWhereInput | LoraWhereInput[]
    OR?: LoraWhereInput[]
    NOT?: LoraWhereInput | LoraWhereInput[]
    civitaiModelId?: StringNullableFilter<"Lora"> | string | null
    name?: StringFilter<"Lora"> | string
    modelType?: StringNullableFilter<"Lora"> | string | null
    baseModel?: StringNullableFilter<"Lora"> | string | null
    downloadCount?: IntNullableFilter<"Lora"> | number | null
    modelUrl?: StringNullableFilter<"Lora"> | string | null
    tags?: StringNullableListFilter<"Lora">
    trainedWords?: StringNullableListFilter<"Lora">
    nsfw?: BoolFilter<"Lora"> | boolean
    filename?: StringNullableFilter<"Lora"> | string | null
    filepathRelative?: StringNullableFilter<"Lora"> | string | null
    firstImageUrl?: StringNullableFilter<"Lora"> | string | null
    imageUrls?: StringNullableListFilter<"Lora">
    category?: StringNullableFilter<"Lora"> | string | null
    term?: StringNullableFilter<"Lora"> | string | null
    deleted?: BoolFilter<"Lora"> | boolean
    createdAt?: DateTimeFilter<"Lora"> | Date | string
    updatedAt?: DateTimeFilter<"Lora"> | Date | string
    characters?: CharacterListRelationFilter
  }, "id" | "civitaiVersionId">

  export type LoraOrderByWithAggregationInput = {
    id?: SortOrder
    civitaiModelId?: SortOrderInput | SortOrder
    civitaiVersionId?: SortOrderInput | SortOrder
    name?: SortOrder
    modelType?: SortOrderInput | SortOrder
    baseModel?: SortOrderInput | SortOrder
    downloadCount?: SortOrderInput | SortOrder
    modelUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    trainedWords?: SortOrder
    nsfw?: SortOrder
    filename?: SortOrderInput | SortOrder
    filepathRelative?: SortOrderInput | SortOrder
    firstImageUrl?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    category?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoraCountOrderByAggregateInput
    _avg?: LoraAvgOrderByAggregateInput
    _max?: LoraMaxOrderByAggregateInput
    _min?: LoraMinOrderByAggregateInput
    _sum?: LoraSumOrderByAggregateInput
  }

  export type LoraScalarWhereWithAggregatesInput = {
    AND?: LoraScalarWhereWithAggregatesInput | LoraScalarWhereWithAggregatesInput[]
    OR?: LoraScalarWhereWithAggregatesInput[]
    NOT?: LoraScalarWhereWithAggregatesInput | LoraScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lora"> | string
    civitaiModelId?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    civitaiVersionId?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    name?: StringWithAggregatesFilter<"Lora"> | string
    modelType?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    baseModel?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    downloadCount?: IntNullableWithAggregatesFilter<"Lora"> | number | null
    modelUrl?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    tags?: StringNullableListFilter<"Lora">
    trainedWords?: StringNullableListFilter<"Lora">
    nsfw?: BoolWithAggregatesFilter<"Lora"> | boolean
    filename?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    filepathRelative?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    firstImageUrl?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    imageUrls?: StringNullableListFilter<"Lora">
    category?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    term?: StringNullableWithAggregatesFilter<"Lora"> | string | null
    deleted?: BoolWithAggregatesFilter<"Lora"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lora"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lora"> | Date | string
  }

  export type AttireWhereInput = {
    AND?: AttireWhereInput | AttireWhereInput[]
    OR?: AttireWhereInput[]
    NOT?: AttireWhereInput | AttireWhereInput[]
    id?: StringFilter<"Attire"> | string
    name?: StringFilter<"Attire"> | string
    description?: StringNullableFilter<"Attire"> | string | null
    gender?: StringNullableFilter<"Attire"> | string | null
    promptHead?: StringNullableFilter<"Attire"> | string | null
    promptBody?: StringNullableFilter<"Attire"> | string | null
    promptFull?: StringNullableFilter<"Attire"> | string | null
    previewImageUrl?: StringNullableFilter<"Attire"> | string | null
    originalLanguageCode?: StringNullableFilter<"Attire"> | string | null
    visibility?: EnumVisibilityFilter<"Attire"> | $Enums.Visibility
    userId?: StringFilter<"Attire"> | string
    ageRating?: EnumAgeRatingFilter<"Attire"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Attire">
    contentVersion?: IntFilter<"Attire"> | number
    createdAt?: DateTimeFilter<"Attire"> | Date | string
    updatedAt?: DateTimeFilter<"Attire"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    charactersUsingAsMain?: CharacterListRelationFilter
    characters?: CharacterListRelationFilter
  }

  export type AttireOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    promptHead?: SortOrderInput | SortOrder
    promptBody?: SortOrderInput | SortOrder
    promptFull?: SortOrderInput | SortOrder
    previewImageUrl?: SortOrderInput | SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    charactersUsingAsMain?: CharacterOrderByRelationAggregateInput
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type AttireWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttireWhereInput | AttireWhereInput[]
    OR?: AttireWhereInput[]
    NOT?: AttireWhereInput | AttireWhereInput[]
    name?: StringFilter<"Attire"> | string
    description?: StringNullableFilter<"Attire"> | string | null
    gender?: StringNullableFilter<"Attire"> | string | null
    promptHead?: StringNullableFilter<"Attire"> | string | null
    promptBody?: StringNullableFilter<"Attire"> | string | null
    promptFull?: StringNullableFilter<"Attire"> | string | null
    previewImageUrl?: StringNullableFilter<"Attire"> | string | null
    originalLanguageCode?: StringNullableFilter<"Attire"> | string | null
    visibility?: EnumVisibilityFilter<"Attire"> | $Enums.Visibility
    userId?: StringFilter<"Attire"> | string
    ageRating?: EnumAgeRatingFilter<"Attire"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Attire">
    contentVersion?: IntFilter<"Attire"> | number
    createdAt?: DateTimeFilter<"Attire"> | Date | string
    updatedAt?: DateTimeFilter<"Attire"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    charactersUsingAsMain?: CharacterListRelationFilter
    characters?: CharacterListRelationFilter
  }, "id">

  export type AttireOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    promptHead?: SortOrderInput | SortOrder
    promptBody?: SortOrderInput | SortOrder
    promptFull?: SortOrderInput | SortOrder
    previewImageUrl?: SortOrderInput | SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttireCountOrderByAggregateInput
    _avg?: AttireAvgOrderByAggregateInput
    _max?: AttireMaxOrderByAggregateInput
    _min?: AttireMinOrderByAggregateInput
    _sum?: AttireSumOrderByAggregateInput
  }

  export type AttireScalarWhereWithAggregatesInput = {
    AND?: AttireScalarWhereWithAggregatesInput | AttireScalarWhereWithAggregatesInput[]
    OR?: AttireScalarWhereWithAggregatesInput[]
    NOT?: AttireScalarWhereWithAggregatesInput | AttireScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attire"> | string
    name?: StringWithAggregatesFilter<"Attire"> | string
    description?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    promptHead?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    promptBody?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    promptFull?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    previewImageUrl?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    originalLanguageCode?: StringNullableWithAggregatesFilter<"Attire"> | string | null
    visibility?: EnumVisibilityWithAggregatesFilter<"Attire"> | $Enums.Visibility
    userId?: StringWithAggregatesFilter<"Attire"> | string
    ageRating?: EnumAgeRatingWithAggregatesFilter<"Attire"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Attire">
    contentVersion?: IntWithAggregatesFilter<"Attire"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Attire"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attire"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    ageRating?: EnumAgeRatingFilter<"Tag"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Tag">
    originalLanguageCode?: StringNullableFilter<"Tag"> | string | null
    weight?: IntFilter<"Tag"> | number
    searchable?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    characters?: CharacterListRelationFilter
    stories?: StoryListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    weight?: SortOrder
    searchable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
    stories?: StoryOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_type?: TagNameTypeCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    ageRating?: EnumAgeRatingFilter<"Tag"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Tag">
    originalLanguageCode?: StringNullableFilter<"Tag"> | string | null
    weight?: IntFilter<"Tag"> | number
    searchable?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    characters?: CharacterListRelationFilter
    stories?: StoryListRelationFilter
  }, "id" | "name_type">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    weight?: SortOrder
    searchable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    type?: EnumTagTypeWithAggregatesFilter<"Tag"> | $Enums.TagType
    ageRating?: EnumAgeRatingWithAggregatesFilter<"Tag"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Tag">
    originalLanguageCode?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    weight?: IntWithAggregatesFilter<"Tag"> | number
    searchable?: BoolWithAggregatesFilter<"Tag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    firstName?: StringFilter<"Character"> | string
    lastName?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    style?: EnumVisualStyleNullableFilter<"Character"> | $Enums.VisualStyle | null
    reference?: StringNullableFilter<"Character"> | string | null
    physicalCharacteristics?: StringNullableFilter<"Character"> | string | null
    personality?: StringNullableFilter<"Character"> | string | null
    history?: StringNullableFilter<"Character"> | string | null
    visibility?: EnumVisibilityFilter<"Character"> | $Enums.Visibility
    isSystemCharacter?: BoolFilter<"Character"> | boolean
    originalLanguageCode?: StringNullableFilter<"Character"> | string | null
    ageRating?: EnumAgeRatingFilter<"Character"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Character">
    userId?: StringFilter<"Character"> | string
    loraId?: StringNullableFilter<"Character"> | string | null
    mainAttireId?: StringNullableFilter<"Character"> | string | null
    contentVersion?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lora?: XOR<LoraNullableScalarRelationFilter, LoraWhereInput> | null
    mainAttire?: XOR<AttireNullableScalarRelationFilter, AttireWhereInput> | null
    stories?: StoryListRelationFilter
    attires?: AttireListRelationFilter
    tags?: TagListRelationFilter
    stickers?: CharacterStickerListRelationFilter
    images?: CharacterImageListRelationFilter
    assistantsUsingAsDefault?: AssistantListRelationFilter
    actingParticipations?: ConversationParticipantListRelationFilter
    representingParticipations?: ConversationParticipantListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    physicalCharacteristics?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isSystemCharacter?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    userId?: SortOrder
    loraId?: SortOrderInput | SortOrder
    mainAttireId?: SortOrderInput | SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    lora?: LoraOrderByWithRelationInput
    mainAttire?: AttireOrderByWithRelationInput
    stories?: StoryOrderByRelationAggregateInput
    attires?: AttireOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    stickers?: CharacterStickerOrderByRelationAggregateInput
    images?: CharacterImageOrderByRelationAggregateInput
    assistantsUsingAsDefault?: AssistantOrderByRelationAggregateInput
    actingParticipations?: ConversationParticipantOrderByRelationAggregateInput
    representingParticipations?: ConversationParticipantOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    firstName?: StringFilter<"Character"> | string
    lastName?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    style?: EnumVisualStyleNullableFilter<"Character"> | $Enums.VisualStyle | null
    reference?: StringNullableFilter<"Character"> | string | null
    physicalCharacteristics?: StringNullableFilter<"Character"> | string | null
    personality?: StringNullableFilter<"Character"> | string | null
    history?: StringNullableFilter<"Character"> | string | null
    visibility?: EnumVisibilityFilter<"Character"> | $Enums.Visibility
    isSystemCharacter?: BoolFilter<"Character"> | boolean
    originalLanguageCode?: StringNullableFilter<"Character"> | string | null
    ageRating?: EnumAgeRatingFilter<"Character"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Character">
    userId?: StringFilter<"Character"> | string
    loraId?: StringNullableFilter<"Character"> | string | null
    mainAttireId?: StringNullableFilter<"Character"> | string | null
    contentVersion?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lora?: XOR<LoraNullableScalarRelationFilter, LoraWhereInput> | null
    mainAttire?: XOR<AttireNullableScalarRelationFilter, AttireWhereInput> | null
    stories?: StoryListRelationFilter
    attires?: AttireListRelationFilter
    tags?: TagListRelationFilter
    stickers?: CharacterStickerListRelationFilter
    images?: CharacterImageListRelationFilter
    assistantsUsingAsDefault?: AssistantListRelationFilter
    actingParticipations?: ConversationParticipantListRelationFilter
    representingParticipations?: ConversationParticipantListRelationFilter
  }, "id">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    physicalCharacteristics?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isSystemCharacter?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    userId?: SortOrder
    loraId?: SortOrderInput | SortOrder
    mainAttireId?: SortOrderInput | SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    firstName?: StringWithAggregatesFilter<"Character"> | string
    lastName?: StringNullableWithAggregatesFilter<"Character"> | string | null
    age?: IntNullableWithAggregatesFilter<"Character"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Character"> | string | null
    species?: StringNullableWithAggregatesFilter<"Character"> | string | null
    style?: EnumVisualStyleNullableWithAggregatesFilter<"Character"> | $Enums.VisualStyle | null
    reference?: StringNullableWithAggregatesFilter<"Character"> | string | null
    physicalCharacteristics?: StringNullableWithAggregatesFilter<"Character"> | string | null
    personality?: StringNullableWithAggregatesFilter<"Character"> | string | null
    history?: StringNullableWithAggregatesFilter<"Character"> | string | null
    visibility?: EnumVisibilityWithAggregatesFilter<"Character"> | $Enums.Visibility
    isSystemCharacter?: BoolWithAggregatesFilter<"Character"> | boolean
    originalLanguageCode?: StringNullableWithAggregatesFilter<"Character"> | string | null
    ageRating?: EnumAgeRatingWithAggregatesFilter<"Character"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Character">
    userId?: StringWithAggregatesFilter<"Character"> | string
    loraId?: StringNullableWithAggregatesFilter<"Character"> | string | null
    mainAttireId?: StringNullableWithAggregatesFilter<"Character"> | string | null
    contentVersion?: IntWithAggregatesFilter<"Character"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type CharacterStickerWhereInput = {
    AND?: CharacterStickerWhereInput | CharacterStickerWhereInput[]
    OR?: CharacterStickerWhereInput[]
    NOT?: CharacterStickerWhereInput | CharacterStickerWhereInput[]
    id?: StringFilter<"CharacterSticker"> | string
    characterId?: StringFilter<"CharacterSticker"> | string
    emotionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    actionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    imageUrl?: StringNullableFilter<"CharacterSticker"> | string | null
    promptUsed?: StringNullableFilter<"CharacterSticker"> | string | null
    status?: EnumStickerStatusFilter<"CharacterSticker"> | $Enums.StickerStatus
    createdAt?: DateTimeFilter<"CharacterSticker"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSticker"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }

  export type CharacterStickerOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    emotionTag?: SortOrderInput | SortOrder
    actionTag?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    promptUsed?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterStickerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterStickerWhereInput | CharacterStickerWhereInput[]
    OR?: CharacterStickerWhereInput[]
    NOT?: CharacterStickerWhereInput | CharacterStickerWhereInput[]
    characterId?: StringFilter<"CharacterSticker"> | string
    emotionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    actionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    imageUrl?: StringNullableFilter<"CharacterSticker"> | string | null
    promptUsed?: StringNullableFilter<"CharacterSticker"> | string | null
    status?: EnumStickerStatusFilter<"CharacterSticker"> | $Enums.StickerStatus
    createdAt?: DateTimeFilter<"CharacterSticker"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSticker"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }, "id">

  export type CharacterStickerOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    emotionTag?: SortOrderInput | SortOrder
    actionTag?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    promptUsed?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterStickerCountOrderByAggregateInput
    _max?: CharacterStickerMaxOrderByAggregateInput
    _min?: CharacterStickerMinOrderByAggregateInput
  }

  export type CharacterStickerScalarWhereWithAggregatesInput = {
    AND?: CharacterStickerScalarWhereWithAggregatesInput | CharacterStickerScalarWhereWithAggregatesInput[]
    OR?: CharacterStickerScalarWhereWithAggregatesInput[]
    NOT?: CharacterStickerScalarWhereWithAggregatesInput | CharacterStickerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSticker"> | string
    characterId?: StringWithAggregatesFilter<"CharacterSticker"> | string
    emotionTag?: StringNullableWithAggregatesFilter<"CharacterSticker"> | string | null
    actionTag?: StringNullableWithAggregatesFilter<"CharacterSticker"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"CharacterSticker"> | string | null
    promptUsed?: StringNullableWithAggregatesFilter<"CharacterSticker"> | string | null
    status?: EnumStickerStatusWithAggregatesFilter<"CharacterSticker"> | $Enums.StickerStatus
    createdAt?: DateTimeWithAggregatesFilter<"CharacterSticker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterSticker"> | Date | string
  }

  export type CharacterImageWhereInput = {
    AND?: CharacterImageWhereInput | CharacterImageWhereInput[]
    OR?: CharacterImageWhereInput[]
    NOT?: CharacterImageWhereInput | CharacterImageWhereInput[]
    id?: StringFilter<"CharacterImage"> | string
    characterId?: StringFilter<"CharacterImage"> | string
    type?: EnumImageTypeFilter<"CharacterImage"> | $Enums.ImageType
    url?: StringFilter<"CharacterImage"> | string
    key?: StringNullableFilter<"CharacterImage"> | string | null
    width?: IntNullableFilter<"CharacterImage"> | number | null
    height?: IntNullableFilter<"CharacterImage"> | number | null
    sizeBytes?: IntNullableFilter<"CharacterImage"> | number | null
    contentType?: StringNullableFilter<"CharacterImage"> | string | null
    ageRating?: EnumAgeRatingFilter<"CharacterImage"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"CharacterImage">
    description?: StringNullableFilter<"CharacterImage"> | string | null
    isActive?: BoolFilter<"CharacterImage"> | boolean
    createdAt?: DateTimeFilter<"CharacterImage"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterImage"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }

  export type CharacterImageOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterImageWhereInput | CharacterImageWhereInput[]
    OR?: CharacterImageWhereInput[]
    NOT?: CharacterImageWhereInput | CharacterImageWhereInput[]
    characterId?: StringFilter<"CharacterImage"> | string
    type?: EnumImageTypeFilter<"CharacterImage"> | $Enums.ImageType
    url?: StringFilter<"CharacterImage"> | string
    key?: StringNullableFilter<"CharacterImage"> | string | null
    width?: IntNullableFilter<"CharacterImage"> | number | null
    height?: IntNullableFilter<"CharacterImage"> | number | null
    sizeBytes?: IntNullableFilter<"CharacterImage"> | number | null
    contentType?: StringNullableFilter<"CharacterImage"> | string | null
    ageRating?: EnumAgeRatingFilter<"CharacterImage"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"CharacterImage">
    description?: StringNullableFilter<"CharacterImage"> | string | null
    isActive?: BoolFilter<"CharacterImage"> | boolean
    createdAt?: DateTimeFilter<"CharacterImage"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterImage"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }, "id">

  export type CharacterImageOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterImageCountOrderByAggregateInput
    _avg?: CharacterImageAvgOrderByAggregateInput
    _max?: CharacterImageMaxOrderByAggregateInput
    _min?: CharacterImageMinOrderByAggregateInput
    _sum?: CharacterImageSumOrderByAggregateInput
  }

  export type CharacterImageScalarWhereWithAggregatesInput = {
    AND?: CharacterImageScalarWhereWithAggregatesInput | CharacterImageScalarWhereWithAggregatesInput[]
    OR?: CharacterImageScalarWhereWithAggregatesInput[]
    NOT?: CharacterImageScalarWhereWithAggregatesInput | CharacterImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterImage"> | string
    characterId?: StringWithAggregatesFilter<"CharacterImage"> | string
    type?: EnumImageTypeWithAggregatesFilter<"CharacterImage"> | $Enums.ImageType
    url?: StringWithAggregatesFilter<"CharacterImage"> | string
    key?: StringNullableWithAggregatesFilter<"CharacterImage"> | string | null
    width?: IntNullableWithAggregatesFilter<"CharacterImage"> | number | null
    height?: IntNullableWithAggregatesFilter<"CharacterImage"> | number | null
    sizeBytes?: IntNullableWithAggregatesFilter<"CharacterImage"> | number | null
    contentType?: StringNullableWithAggregatesFilter<"CharacterImage"> | string | null
    ageRating?: EnumAgeRatingWithAggregatesFilter<"CharacterImage"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"CharacterImage">
    description?: StringNullableWithAggregatesFilter<"CharacterImage"> | string | null
    isActive?: BoolWithAggregatesFilter<"CharacterImage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CharacterImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterImage"> | Date | string
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    title?: StringFilter<"Story"> | string
    synopsis?: StringNullableFilter<"Story"> | string | null
    initialText?: StringNullableFilter<"Story"> | string | null
    coverImage?: StringNullableFilter<"Story"> | string | null
    objectives?: JsonNullableFilter<"Story">
    authorId?: StringFilter<"Story"> | string
    ageRating?: EnumAgeRatingFilter<"Story"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Story">
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    contentVersion?: IntFilter<"Story"> | number
    originalLanguageCode?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    characters?: CharacterListRelationFilter
    tags?: TagListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    synopsis?: SortOrderInput | SortOrder
    initialText?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    authorId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    visibility?: SortOrder
    contentVersion?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    characters?: CharacterOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    title?: StringFilter<"Story"> | string
    synopsis?: StringNullableFilter<"Story"> | string | null
    initialText?: StringNullableFilter<"Story"> | string | null
    coverImage?: StringNullableFilter<"Story"> | string | null
    objectives?: JsonNullableFilter<"Story">
    authorId?: StringFilter<"Story"> | string
    ageRating?: EnumAgeRatingFilter<"Story"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Story">
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    contentVersion?: IntFilter<"Story"> | number
    originalLanguageCode?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    characters?: CharacterListRelationFilter
    tags?: TagListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    synopsis?: SortOrderInput | SortOrder
    initialText?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    authorId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    visibility?: SortOrder
    contentVersion?: SortOrder
    originalLanguageCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryCountOrderByAggregateInput
    _avg?: StoryAvgOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
    _sum?: StorySumOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    title?: StringWithAggregatesFilter<"Story"> | string
    synopsis?: StringNullableWithAggregatesFilter<"Story"> | string | null
    initialText?: StringNullableWithAggregatesFilter<"Story"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Story"> | string | null
    objectives?: JsonNullableWithAggregatesFilter<"Story">
    authorId?: StringWithAggregatesFilter<"Story"> | string
    ageRating?: EnumAgeRatingWithAggregatesFilter<"Story"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Story">
    visibility?: EnumVisibilityWithAggregatesFilter<"Story"> | $Enums.Visibility
    contentVersion?: IntWithAggregatesFilter<"Story"> | number
    originalLanguageCode?: StringNullableWithAggregatesFilter<"Story"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
  }

  export type AssistantWhereInput = {
    AND?: AssistantWhereInput | AssistantWhereInput[]
    OR?: AssistantWhereInput[]
    NOT?: AssistantWhereInput | AssistantWhereInput[]
    id?: StringFilter<"Assistant"> | string
    name?: StringFilter<"Assistant"> | string
    description?: StringNullableFilter<"Assistant"> | string | null
    instructions?: StringFilter<"Assistant"> | string
    defaultCharacterId?: StringNullableFilter<"Assistant"> | string | null
    visibility?: EnumVisibilityFilter<"Assistant"> | $Enums.Visibility
    userId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
    defaultCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participations?: ConversationParticipantListRelationFilter
  }

  export type AssistantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    instructions?: SortOrder
    defaultCharacterId?: SortOrderInput | SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultCharacter?: CharacterOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    participations?: ConversationParticipantOrderByRelationAggregateInput
  }

  export type AssistantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssistantWhereInput | AssistantWhereInput[]
    OR?: AssistantWhereInput[]
    NOT?: AssistantWhereInput | AssistantWhereInput[]
    name?: StringFilter<"Assistant"> | string
    description?: StringNullableFilter<"Assistant"> | string | null
    instructions?: StringFilter<"Assistant"> | string
    defaultCharacterId?: StringNullableFilter<"Assistant"> | string | null
    visibility?: EnumVisibilityFilter<"Assistant"> | $Enums.Visibility
    userId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
    defaultCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participations?: ConversationParticipantListRelationFilter
  }, "id">

  export type AssistantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    instructions?: SortOrder
    defaultCharacterId?: SortOrderInput | SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssistantCountOrderByAggregateInput
    _max?: AssistantMaxOrderByAggregateInput
    _min?: AssistantMinOrderByAggregateInput
  }

  export type AssistantScalarWhereWithAggregatesInput = {
    AND?: AssistantScalarWhereWithAggregatesInput | AssistantScalarWhereWithAggregatesInput[]
    OR?: AssistantScalarWhereWithAggregatesInput[]
    NOT?: AssistantScalarWhereWithAggregatesInput | AssistantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assistant"> | string
    name?: StringWithAggregatesFilter<"Assistant"> | string
    description?: StringNullableWithAggregatesFilter<"Assistant"> | string | null
    instructions?: StringWithAggregatesFilter<"Assistant"> | string
    defaultCharacterId?: StringNullableWithAggregatesFilter<"Assistant"> | string | null
    visibility?: EnumVisibilityWithAggregatesFilter<"Assistant"> | $Enums.Visibility
    userId?: StringWithAggregatesFilter<"Assistant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assistant"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    isTitleUserEdited?: BoolFilter<"Conversation"> | boolean
    isTitleSystemEdited?: BoolFilter<"Conversation"> | boolean
    projectId?: StringNullableFilter<"Conversation"> | string | null
    storyId?: StringNullableFilter<"Conversation"> | string | null
    settings?: JsonNullableFilter<"Conversation">
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    titleLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    memoryLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    isMultiUser?: BoolFilter<"Conversation"> | boolean
    maxUsers?: IntFilter<"Conversation"> | number
    ownerUserId?: StringNullableFilter<"Conversation"> | string | null
    allowUserInvites?: BoolFilter<"Conversation"> | boolean
    requireApproval?: BoolFilter<"Conversation"> | boolean
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    conversationOwner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
    memories?: ConversationMemoryListRelationFilter
    members?: UserConversationMembershipListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isTitleUserEdited?: SortOrder
    isTitleSystemEdited?: SortOrder
    projectId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    titleLastUpdatedAt?: SortOrderInput | SortOrder
    memoryLastUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    isMultiUser?: SortOrder
    maxUsers?: SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    allowUserInvites?: SortOrder
    requireApproval?: SortOrder
    story?: StoryOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    conversationOwner?: UserOrderByWithRelationInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    memories?: ConversationMemoryOrderByRelationAggregateInput
    members?: UserConversationMembershipOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    title?: StringFilter<"Conversation"> | string
    isTitleUserEdited?: BoolFilter<"Conversation"> | boolean
    isTitleSystemEdited?: BoolFilter<"Conversation"> | boolean
    projectId?: StringNullableFilter<"Conversation"> | string | null
    storyId?: StringNullableFilter<"Conversation"> | string | null
    settings?: JsonNullableFilter<"Conversation">
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    titleLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    memoryLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    isMultiUser?: BoolFilter<"Conversation"> | boolean
    maxUsers?: IntFilter<"Conversation"> | number
    ownerUserId?: StringNullableFilter<"Conversation"> | string | null
    allowUserInvites?: BoolFilter<"Conversation"> | boolean
    requireApproval?: BoolFilter<"Conversation"> | boolean
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    conversationOwner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
    memories?: ConversationMemoryListRelationFilter
    members?: UserConversationMembershipListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isTitleUserEdited?: SortOrder
    isTitleSystemEdited?: SortOrder
    projectId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    titleLastUpdatedAt?: SortOrderInput | SortOrder
    memoryLastUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    isMultiUser?: SortOrder
    maxUsers?: SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    allowUserInvites?: SortOrder
    requireApproval?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringWithAggregatesFilter<"Conversation"> | string
    isTitleUserEdited?: BoolWithAggregatesFilter<"Conversation"> | boolean
    isTitleSystemEdited?: BoolWithAggregatesFilter<"Conversation"> | boolean
    projectId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    storyId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Conversation">
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    titleLastUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    memoryLastUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    isMultiUser?: BoolWithAggregatesFilter<"Conversation"> | boolean
    maxUsers?: IntWithAggregatesFilter<"Conversation"> | number
    ownerUserId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    allowUserInvites?: BoolWithAggregatesFilter<"Conversation"> | boolean
    requireApproval?: BoolWithAggregatesFilter<"Conversation"> | boolean
  }

  export type UserConversationMembershipWhereInput = {
    AND?: UserConversationMembershipWhereInput | UserConversationMembershipWhereInput[]
    OR?: UserConversationMembershipWhereInput[]
    NOT?: UserConversationMembershipWhereInput | UserConversationMembershipWhereInput[]
    id?: StringFilter<"UserConversationMembership"> | string
    conversationId?: StringFilter<"UserConversationMembership"> | string
    userId?: StringFilter<"UserConversationMembership"> | string
    role?: EnumMembershipRoleFilter<"UserConversationMembership"> | $Enums.MembershipRole
    canWrite?: BoolFilter<"UserConversationMembership"> | boolean
    canInvite?: BoolFilter<"UserConversationMembership"> | boolean
    canModerate?: BoolFilter<"UserConversationMembership"> | boolean
    joinedAt?: DateTimeFilter<"UserConversationMembership"> | Date | string
    invitedBy?: StringNullableFilter<"UserConversationMembership"> | string | null
    isActive?: BoolFilter<"UserConversationMembership"> | boolean
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserConversationMembershipOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    canWrite?: SortOrder
    canInvite?: SortOrder
    canModerate?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
  }

  export type UserConversationMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_userId?: UserConversationMembershipConversationIdUserIdCompoundUniqueInput
    AND?: UserConversationMembershipWhereInput | UserConversationMembershipWhereInput[]
    OR?: UserConversationMembershipWhereInput[]
    NOT?: UserConversationMembershipWhereInput | UserConversationMembershipWhereInput[]
    conversationId?: StringFilter<"UserConversationMembership"> | string
    userId?: StringFilter<"UserConversationMembership"> | string
    role?: EnumMembershipRoleFilter<"UserConversationMembership"> | $Enums.MembershipRole
    canWrite?: BoolFilter<"UserConversationMembership"> | boolean
    canInvite?: BoolFilter<"UserConversationMembership"> | boolean
    canModerate?: BoolFilter<"UserConversationMembership"> | boolean
    joinedAt?: DateTimeFilter<"UserConversationMembership"> | Date | string
    invitedBy?: StringNullableFilter<"UserConversationMembership"> | string | null
    isActive?: BoolFilter<"UserConversationMembership"> | boolean
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "conversationId_userId">

  export type UserConversationMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    canWrite?: SortOrder
    canInvite?: SortOrder
    canModerate?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: UserConversationMembershipCountOrderByAggregateInput
    _max?: UserConversationMembershipMaxOrderByAggregateInput
    _min?: UserConversationMembershipMinOrderByAggregateInput
  }

  export type UserConversationMembershipScalarWhereWithAggregatesInput = {
    AND?: UserConversationMembershipScalarWhereWithAggregatesInput | UserConversationMembershipScalarWhereWithAggregatesInput[]
    OR?: UserConversationMembershipScalarWhereWithAggregatesInput[]
    NOT?: UserConversationMembershipScalarWhereWithAggregatesInput | UserConversationMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserConversationMembership"> | string
    conversationId?: StringWithAggregatesFilter<"UserConversationMembership"> | string
    userId?: StringWithAggregatesFilter<"UserConversationMembership"> | string
    role?: EnumMembershipRoleWithAggregatesFilter<"UserConversationMembership"> | $Enums.MembershipRole
    canWrite?: BoolWithAggregatesFilter<"UserConversationMembership"> | boolean
    canInvite?: BoolWithAggregatesFilter<"UserConversationMembership"> | boolean
    canModerate?: BoolWithAggregatesFilter<"UserConversationMembership"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"UserConversationMembership"> | Date | string
    invitedBy?: StringNullableWithAggregatesFilter<"UserConversationMembership"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserConversationMembership"> | boolean
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingAssistantId?: StringNullableFilter<"ConversationParticipant"> | string | null
    representingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    configOverride?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    actingCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    actingAssistant?: XOR<AssistantNullableScalarRelationFilter, AssistantWhereInput> | null
    representingCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    actingCharacterId?: SortOrderInput | SortOrder
    actingAssistantId?: SortOrderInput | SortOrder
    representingCharacterId?: SortOrderInput | SortOrder
    configOverride?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    actingCharacter?: CharacterOrderByWithRelationInput
    actingAssistant?: AssistantOrderByWithRelationInput
    representingCharacter?: CharacterOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingAssistantId?: StringNullableFilter<"ConversationParticipant"> | string | null
    representingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    configOverride?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    actingCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    actingAssistant?: XOR<AssistantNullableScalarRelationFilter, AssistantWhereInput> | null
    representingCharacter?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
  }, "id">

  export type ConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    actingCharacterId?: SortOrderInput | SortOrder
    actingAssistantId?: SortOrderInput | SortOrder
    representingCharacterId?: SortOrderInput | SortOrder
    configOverride?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    userId?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    actingCharacterId?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    actingAssistantId?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    representingCharacterId?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    configOverride?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    senderType?: EnumSenderTypeWithAggregatesFilter<"Message"> | $Enums.SenderType
    content?: StringWithAggregatesFilter<"Message"> | string
    attachments?: StringNullableWithAggregatesFilter<"Message"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FavoriteCharacterWhereInput = {
    AND?: FavoriteCharacterWhereInput | FavoriteCharacterWhereInput[]
    OR?: FavoriteCharacterWhereInput[]
    NOT?: FavoriteCharacterWhereInput | FavoriteCharacterWhereInput[]
    id?: StringFilter<"FavoriteCharacter"> | string
    userId?: StringFilter<"FavoriteCharacter"> | string
    characterId?: StringFilter<"FavoriteCharacter"> | string
    createdAt?: DateTimeFilter<"FavoriteCharacter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FavoriteCharacterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FavoriteCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_characterId?: FavoriteCharacterUserIdCharacterIdCompoundUniqueInput
    AND?: FavoriteCharacterWhereInput | FavoriteCharacterWhereInput[]
    OR?: FavoriteCharacterWhereInput[]
    NOT?: FavoriteCharacterWhereInput | FavoriteCharacterWhereInput[]
    userId?: StringFilter<"FavoriteCharacter"> | string
    characterId?: StringFilter<"FavoriteCharacter"> | string
    createdAt?: DateTimeFilter<"FavoriteCharacter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_characterId">

  export type FavoriteCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCharacterCountOrderByAggregateInput
    _max?: FavoriteCharacterMaxOrderByAggregateInput
    _min?: FavoriteCharacterMinOrderByAggregateInput
  }

  export type FavoriteCharacterScalarWhereWithAggregatesInput = {
    AND?: FavoriteCharacterScalarWhereWithAggregatesInput | FavoriteCharacterScalarWhereWithAggregatesInput[]
    OR?: FavoriteCharacterScalarWhereWithAggregatesInput[]
    NOT?: FavoriteCharacterScalarWhereWithAggregatesInput | FavoriteCharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FavoriteCharacter"> | string
    userId?: StringWithAggregatesFilter<"FavoriteCharacter"> | string
    characterId?: StringWithAggregatesFilter<"FavoriteCharacter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FavoriteCharacter"> | Date | string
  }

  export type ContentTranslationWhereInput = {
    AND?: ContentTranslationWhereInput | ContentTranslationWhereInput[]
    OR?: ContentTranslationWhereInput[]
    NOT?: ContentTranslationWhereInput | ContentTranslationWhereInput[]
    id?: StringFilter<"ContentTranslation"> | string
    contentType?: StringFilter<"ContentTranslation"> | string
    contentId?: StringFilter<"ContentTranslation"> | string
    fieldName?: StringFilter<"ContentTranslation"> | string
    originalLanguageCode?: StringFilter<"ContentTranslation"> | string
    targetLanguageCode?: StringFilter<"ContentTranslation"> | string
    originalText?: StringFilter<"ContentTranslation"> | string
    translatedText?: StringFilter<"ContentTranslation"> | string
    translationProvider?: StringNullableFilter<"ContentTranslation"> | string | null
    translationModel?: StringNullableFilter<"ContentTranslation"> | string | null
    confidence?: FloatNullableFilter<"ContentTranslation"> | number | null
    status?: EnumTranslationStatusFilter<"ContentTranslation"> | $Enums.TranslationStatus
    reviewedBy?: StringNullableFilter<"ContentTranslation"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentTranslation"> | Date | string | null
    translationTimeMs?: IntNullableFilter<"ContentTranslation"> | number | null
    characterCount?: IntNullableFilter<"ContentTranslation"> | number | null
    sourceVersion?: IntFilter<"ContentTranslation"> | number
    createdAt?: DateTimeFilter<"ContentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ContentTranslation"> | Date | string
  }

  export type ContentTranslationOrderByWithRelationInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    fieldName?: SortOrder
    originalLanguageCode?: SortOrder
    targetLanguageCode?: SortOrder
    originalText?: SortOrder
    translatedText?: SortOrder
    translationProvider?: SortOrderInput | SortOrder
    translationModel?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    translationTimeMs?: SortOrderInput | SortOrder
    characterCount?: SortOrderInput | SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentType_contentId_fieldName_targetLanguageCode?: ContentTranslationContentTypeContentIdFieldNameTargetLanguageCodeCompoundUniqueInput
    AND?: ContentTranslationWhereInput | ContentTranslationWhereInput[]
    OR?: ContentTranslationWhereInput[]
    NOT?: ContentTranslationWhereInput | ContentTranslationWhereInput[]
    contentType?: StringFilter<"ContentTranslation"> | string
    contentId?: StringFilter<"ContentTranslation"> | string
    fieldName?: StringFilter<"ContentTranslation"> | string
    originalLanguageCode?: StringFilter<"ContentTranslation"> | string
    targetLanguageCode?: StringFilter<"ContentTranslation"> | string
    originalText?: StringFilter<"ContentTranslation"> | string
    translatedText?: StringFilter<"ContentTranslation"> | string
    translationProvider?: StringNullableFilter<"ContentTranslation"> | string | null
    translationModel?: StringNullableFilter<"ContentTranslation"> | string | null
    confidence?: FloatNullableFilter<"ContentTranslation"> | number | null
    status?: EnumTranslationStatusFilter<"ContentTranslation"> | $Enums.TranslationStatus
    reviewedBy?: StringNullableFilter<"ContentTranslation"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ContentTranslation"> | Date | string | null
    translationTimeMs?: IntNullableFilter<"ContentTranslation"> | number | null
    characterCount?: IntNullableFilter<"ContentTranslation"> | number | null
    sourceVersion?: IntFilter<"ContentTranslation"> | number
    createdAt?: DateTimeFilter<"ContentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ContentTranslation"> | Date | string
  }, "id" | "contentType_contentId_fieldName_targetLanguageCode">

  export type ContentTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    fieldName?: SortOrder
    originalLanguageCode?: SortOrder
    targetLanguageCode?: SortOrder
    originalText?: SortOrder
    translatedText?: SortOrder
    translationProvider?: SortOrderInput | SortOrder
    translationModel?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    translationTimeMs?: SortOrderInput | SortOrder
    characterCount?: SortOrderInput | SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentTranslationCountOrderByAggregateInput
    _avg?: ContentTranslationAvgOrderByAggregateInput
    _max?: ContentTranslationMaxOrderByAggregateInput
    _min?: ContentTranslationMinOrderByAggregateInput
    _sum?: ContentTranslationSumOrderByAggregateInput
  }

  export type ContentTranslationScalarWhereWithAggregatesInput = {
    AND?: ContentTranslationScalarWhereWithAggregatesInput | ContentTranslationScalarWhereWithAggregatesInput[]
    OR?: ContentTranslationScalarWhereWithAggregatesInput[]
    NOT?: ContentTranslationScalarWhereWithAggregatesInput | ContentTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentTranslation"> | string
    contentType?: StringWithAggregatesFilter<"ContentTranslation"> | string
    contentId?: StringWithAggregatesFilter<"ContentTranslation"> | string
    fieldName?: StringWithAggregatesFilter<"ContentTranslation"> | string
    originalLanguageCode?: StringWithAggregatesFilter<"ContentTranslation"> | string
    targetLanguageCode?: StringWithAggregatesFilter<"ContentTranslation"> | string
    originalText?: StringWithAggregatesFilter<"ContentTranslation"> | string
    translatedText?: StringWithAggregatesFilter<"ContentTranslation"> | string
    translationProvider?: StringNullableWithAggregatesFilter<"ContentTranslation"> | string | null
    translationModel?: StringNullableWithAggregatesFilter<"ContentTranslation"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"ContentTranslation"> | number | null
    status?: EnumTranslationStatusWithAggregatesFilter<"ContentTranslation"> | $Enums.TranslationStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"ContentTranslation"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ContentTranslation"> | Date | string | null
    translationTimeMs?: IntNullableWithAggregatesFilter<"ContentTranslation"> | number | null
    characterCount?: IntNullableWithAggregatesFilter<"ContentTranslation"> | number | null
    sourceVersion?: IntWithAggregatesFilter<"ContentTranslation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContentTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentTranslation"> | Date | string
  }

  export type ConversationMemoryWhereInput = {
    AND?: ConversationMemoryWhereInput | ConversationMemoryWhereInput[]
    OR?: ConversationMemoryWhereInput[]
    NOT?: ConversationMemoryWhereInput | ConversationMemoryWhereInput[]
    id?: StringFilter<"ConversationMemory"> | string
    conversationId?: StringFilter<"ConversationMemory"> | string
    summary?: StringFilter<"ConversationMemory"> | string
    keyEvents?: JsonFilter<"ConversationMemory">
    messageCount?: IntFilter<"ConversationMemory"> | number
    startMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    endMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    createdAt?: DateTimeFilter<"ConversationMemory"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationMemory"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationMemoryOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    summary?: SortOrder
    keyEvents?: SortOrder
    messageCount?: SortOrder
    startMessageId?: SortOrderInput | SortOrder
    endMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationMemoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationMemoryWhereInput | ConversationMemoryWhereInput[]
    OR?: ConversationMemoryWhereInput[]
    NOT?: ConversationMemoryWhereInput | ConversationMemoryWhereInput[]
    conversationId?: StringFilter<"ConversationMemory"> | string
    summary?: StringFilter<"ConversationMemory"> | string
    keyEvents?: JsonFilter<"ConversationMemory">
    messageCount?: IntFilter<"ConversationMemory"> | number
    startMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    endMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    createdAt?: DateTimeFilter<"ConversationMemory"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationMemory"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type ConversationMemoryOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    summary?: SortOrder
    keyEvents?: SortOrder
    messageCount?: SortOrder
    startMessageId?: SortOrderInput | SortOrder
    endMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationMemoryCountOrderByAggregateInput
    _avg?: ConversationMemoryAvgOrderByAggregateInput
    _max?: ConversationMemoryMaxOrderByAggregateInput
    _min?: ConversationMemoryMinOrderByAggregateInput
    _sum?: ConversationMemorySumOrderByAggregateInput
  }

  export type ConversationMemoryScalarWhereWithAggregatesInput = {
    AND?: ConversationMemoryScalarWhereWithAggregatesInput | ConversationMemoryScalarWhereWithAggregatesInput[]
    OR?: ConversationMemoryScalarWhereWithAggregatesInput[]
    NOT?: ConversationMemoryScalarWhereWithAggregatesInput | ConversationMemoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationMemory"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationMemory"> | string
    summary?: StringWithAggregatesFilter<"ConversationMemory"> | string
    keyEvents?: JsonWithAggregatesFilter<"ConversationMemory">
    messageCount?: IntWithAggregatesFilter<"ConversationMemory"> | number
    startMessageId?: StringNullableWithAggregatesFilter<"ConversationMemory"> | string | null
    endMessageId?: StringNullableWithAggregatesFilter<"ConversationMemory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConversationMemory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConversationMemory"> | Date | string
  }

  export type CreditTransactionWhereInput = {
    AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    OR?: CreditTransactionWhereInput[]
    NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    id?: StringFilter<"CreditTransaction"> | string
    userId?: StringFilter<"CreditTransaction"> | string
    transactionType?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    amountCredits?: FloatFilter<"CreditTransaction"> | number
    balanceAfter?: FloatNullableFilter<"CreditTransaction"> | number | null
    notes?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedUsageLogId?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedPlanId?: StringNullableFilter<"CreditTransaction"> | string | null
    timestamp?: DateTimeFilter<"CreditTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CreditTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amountCredits?: SortOrder
    balanceAfter?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    relatedUsageLogId?: SortOrderInput | SortOrder
    relatedPlanId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CreditTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    OR?: CreditTransactionWhereInput[]
    NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    userId?: StringFilter<"CreditTransaction"> | string
    transactionType?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    amountCredits?: FloatFilter<"CreditTransaction"> | number
    balanceAfter?: FloatNullableFilter<"CreditTransaction"> | number | null
    notes?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedUsageLogId?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedPlanId?: StringNullableFilter<"CreditTransaction"> | string | null
    timestamp?: DateTimeFilter<"CreditTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CreditTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amountCredits?: SortOrder
    balanceAfter?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    relatedUsageLogId?: SortOrderInput | SortOrder
    relatedPlanId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: CreditTransactionCountOrderByAggregateInput
    _avg?: CreditTransactionAvgOrderByAggregateInput
    _max?: CreditTransactionMaxOrderByAggregateInput
    _min?: CreditTransactionMinOrderByAggregateInput
    _sum?: CreditTransactionSumOrderByAggregateInput
  }

  export type CreditTransactionScalarWhereWithAggregatesInput = {
    AND?: CreditTransactionScalarWhereWithAggregatesInput | CreditTransactionScalarWhereWithAggregatesInput[]
    OR?: CreditTransactionScalarWhereWithAggregatesInput[]
    NOT?: CreditTransactionScalarWhereWithAggregatesInput | CreditTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTransaction"> | string
    userId?: StringWithAggregatesFilter<"CreditTransaction"> | string
    transactionType?: EnumCreditTransactionTypeWithAggregatesFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    amountCredits?: FloatWithAggregatesFilter<"CreditTransaction"> | number
    balanceAfter?: FloatNullableWithAggregatesFilter<"CreditTransaction"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CreditTransaction"> | string | null
    relatedUsageLogId?: StringNullableWithAggregatesFilter<"CreditTransaction"> | string | null
    relatedPlanId?: StringNullableWithAggregatesFilter<"CreditTransaction"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"CreditTransaction"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    tier?: EnumPlanTierFilter<"Plan"> | $Enums.PlanTier
    name?: StringFilter<"Plan"> | string
    priceMonthly?: FloatFilter<"Plan"> | number
    creditsPerMonth?: IntFilter<"Plan"> | number
    description?: StringNullableFilter<"Plan"> | string | null
    features?: JsonNullableFilter<"Plan">
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    paypalPlanId?: StringNullableFilter<"Plan"> | string | null
    userPlans?: UserPlanListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    tier?: SortOrder
    name?: SortOrder
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
    description?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paypalPlanId?: SortOrderInput | SortOrder
    userPlans?: UserPlanOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tier?: $Enums.PlanTier
    paypalPlanId?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    priceMonthly?: FloatFilter<"Plan"> | number
    creditsPerMonth?: IntFilter<"Plan"> | number
    description?: StringNullableFilter<"Plan"> | string | null
    features?: JsonNullableFilter<"Plan">
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    userPlans?: UserPlanListRelationFilter
  }, "id" | "tier" | "paypalPlanId">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    tier?: SortOrder
    name?: SortOrder
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
    description?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paypalPlanId?: SortOrderInput | SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    tier?: EnumPlanTierWithAggregatesFilter<"Plan"> | $Enums.PlanTier
    name?: StringWithAggregatesFilter<"Plan"> | string
    priceMonthly?: FloatWithAggregatesFilter<"Plan"> | number
    creditsPerMonth?: IntWithAggregatesFilter<"Plan"> | number
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    features?: JsonNullableWithAggregatesFilter<"Plan">
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    paypalPlanId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
  }

  export type ServiceCreditCostWhereInput = {
    AND?: ServiceCreditCostWhereInput | ServiceCreditCostWhereInput[]
    OR?: ServiceCreditCostWhereInput[]
    NOT?: ServiceCreditCostWhereInput | ServiceCreditCostWhereInput[]
    id?: StringFilter<"ServiceCreditCost"> | string
    serviceIdentifier?: StringFilter<"ServiceCreditCost"> | string
    creditsPerUnit?: FloatFilter<"ServiceCreditCost"> | number
    unitDescription?: StringFilter<"ServiceCreditCost"> | string
    isActive?: BoolFilter<"ServiceCreditCost"> | boolean
    createdAt?: DateTimeFilter<"ServiceCreditCost"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCreditCost"> | Date | string
  }

  export type ServiceCreditCostOrderByWithRelationInput = {
    id?: SortOrder
    serviceIdentifier?: SortOrder
    creditsPerUnit?: SortOrder
    unitDescription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCreditCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceIdentifier?: string
    AND?: ServiceCreditCostWhereInput | ServiceCreditCostWhereInput[]
    OR?: ServiceCreditCostWhereInput[]
    NOT?: ServiceCreditCostWhereInput | ServiceCreditCostWhereInput[]
    creditsPerUnit?: FloatFilter<"ServiceCreditCost"> | number
    unitDescription?: StringFilter<"ServiceCreditCost"> | string
    isActive?: BoolFilter<"ServiceCreditCost"> | boolean
    createdAt?: DateTimeFilter<"ServiceCreditCost"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCreditCost"> | Date | string
  }, "id" | "serviceIdentifier">

  export type ServiceCreditCostOrderByWithAggregationInput = {
    id?: SortOrder
    serviceIdentifier?: SortOrder
    creditsPerUnit?: SortOrder
    unitDescription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCreditCostCountOrderByAggregateInput
    _avg?: ServiceCreditCostAvgOrderByAggregateInput
    _max?: ServiceCreditCostMaxOrderByAggregateInput
    _min?: ServiceCreditCostMinOrderByAggregateInput
    _sum?: ServiceCreditCostSumOrderByAggregateInput
  }

  export type ServiceCreditCostScalarWhereWithAggregatesInput = {
    AND?: ServiceCreditCostScalarWhereWithAggregatesInput | ServiceCreditCostScalarWhereWithAggregatesInput[]
    OR?: ServiceCreditCostScalarWhereWithAggregatesInput[]
    NOT?: ServiceCreditCostScalarWhereWithAggregatesInput | ServiceCreditCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCreditCost"> | string
    serviceIdentifier?: StringWithAggregatesFilter<"ServiceCreditCost"> | string
    creditsPerUnit?: FloatWithAggregatesFilter<"ServiceCreditCost"> | number
    unitDescription?: StringWithAggregatesFilter<"ServiceCreditCost"> | string
    isActive?: BoolWithAggregatesFilter<"ServiceCreditCost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCreditCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCreditCost"> | Date | string
  }

  export type UsageLogWhereInput = {
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringFilter<"UsageLog"> | string
    conversationId?: StringNullableFilter<"UsageLog"> | string | null
    serviceType?: StringFilter<"UsageLog"> | string
    providerName?: StringNullableFilter<"UsageLog"> | string | null
    modelName?: StringNullableFilter<"UsageLog"> | string | null
    inputTokens?: IntNullableFilter<"UsageLog"> | number | null
    outputTokens?: IntNullableFilter<"UsageLog"> | number | null
    charactersProcessed?: IntNullableFilter<"UsageLog"> | number | null
    imagesProcessed?: IntNullableFilter<"UsageLog"> | number | null
    costUsd?: FloatNullableFilter<"UsageLog"> | number | null
    creditsConsumed?: FloatNullableFilter<"UsageLog"> | number | null
    additionalMetadata?: JsonNullableFilter<"UsageLog">
    processed?: BoolFilter<"UsageLog"> | boolean
    processedAt?: DateTimeNullableFilter<"UsageLog"> | Date | string | null
    timestamp?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    serviceType?: SortOrder
    providerName?: SortOrderInput | SortOrder
    modelName?: SortOrderInput | SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    charactersProcessed?: SortOrderInput | SortOrder
    imagesProcessed?: SortOrderInput | SortOrder
    costUsd?: SortOrderInput | SortOrder
    creditsConsumed?: SortOrderInput | SortOrder
    additionalMetadata?: SortOrderInput | SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    userId?: StringFilter<"UsageLog"> | string
    conversationId?: StringNullableFilter<"UsageLog"> | string | null
    serviceType?: StringFilter<"UsageLog"> | string
    providerName?: StringNullableFilter<"UsageLog"> | string | null
    modelName?: StringNullableFilter<"UsageLog"> | string | null
    inputTokens?: IntNullableFilter<"UsageLog"> | number | null
    outputTokens?: IntNullableFilter<"UsageLog"> | number | null
    charactersProcessed?: IntNullableFilter<"UsageLog"> | number | null
    imagesProcessed?: IntNullableFilter<"UsageLog"> | number | null
    costUsd?: FloatNullableFilter<"UsageLog"> | number | null
    creditsConsumed?: FloatNullableFilter<"UsageLog"> | number | null
    additionalMetadata?: JsonNullableFilter<"UsageLog">
    processed?: BoolFilter<"UsageLog"> | boolean
    processedAt?: DateTimeNullableFilter<"UsageLog"> | Date | string | null
    timestamp?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    serviceType?: SortOrder
    providerName?: SortOrderInput | SortOrder
    modelName?: SortOrderInput | SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    charactersProcessed?: SortOrderInput | SortOrder
    imagesProcessed?: SortOrderInput | SortOrder
    costUsd?: SortOrderInput | SortOrder
    creditsConsumed?: SortOrderInput | SortOrder
    additionalMetadata?: SortOrderInput | SortOrder
    processed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: UsageLogCountOrderByAggregateInput
    _avg?: UsageLogAvgOrderByAggregateInput
    _max?: UsageLogMaxOrderByAggregateInput
    _min?: UsageLogMinOrderByAggregateInput
    _sum?: UsageLogSumOrderByAggregateInput
  }

  export type UsageLogScalarWhereWithAggregatesInput = {
    AND?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    OR?: UsageLogScalarWhereWithAggregatesInput[]
    NOT?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageLog"> | string
    userId?: StringWithAggregatesFilter<"UsageLog"> | string
    conversationId?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    serviceType?: StringWithAggregatesFilter<"UsageLog"> | string
    providerName?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    modelName?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    inputTokens?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    outputTokens?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    charactersProcessed?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    imagesProcessed?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    costUsd?: FloatNullableWithAggregatesFilter<"UsageLog"> | number | null
    creditsConsumed?: FloatNullableWithAggregatesFilter<"UsageLog"> | number | null
    additionalMetadata?: JsonNullableWithAggregatesFilter<"UsageLog">
    processed?: BoolWithAggregatesFilter<"UsageLog"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"UsageLog"> | Date | string | null
    timestamp?: DateTimeWithAggregatesFilter<"UsageLog"> | Date | string
  }

  export type UserMonthlyBalanceWhereInput = {
    AND?: UserMonthlyBalanceWhereInput | UserMonthlyBalanceWhereInput[]
    OR?: UserMonthlyBalanceWhereInput[]
    NOT?: UserMonthlyBalanceWhereInput | UserMonthlyBalanceWhereInput[]
    id?: StringFilter<"UserMonthlyBalance"> | string
    userId?: StringFilter<"UserMonthlyBalance"> | string
    monthStartDate?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    startingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    creditsGranted?: FloatFilter<"UserMonthlyBalance"> | number
    creditsSpent?: FloatFilter<"UserMonthlyBalance"> | number
    endingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    createdAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserMonthlyBalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthStartDate?: SortOrder
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMonthlyBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_monthStartDate?: UserMonthlyBalanceUserIdMonthStartDateCompoundUniqueInput
    AND?: UserMonthlyBalanceWhereInput | UserMonthlyBalanceWhereInput[]
    OR?: UserMonthlyBalanceWhereInput[]
    NOT?: UserMonthlyBalanceWhereInput | UserMonthlyBalanceWhereInput[]
    userId?: StringFilter<"UserMonthlyBalance"> | string
    monthStartDate?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    startingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    creditsGranted?: FloatFilter<"UserMonthlyBalance"> | number
    creditsSpent?: FloatFilter<"UserMonthlyBalance"> | number
    endingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    createdAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_monthStartDate">

  export type UserMonthlyBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthStartDate?: SortOrder
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserMonthlyBalanceCountOrderByAggregateInput
    _avg?: UserMonthlyBalanceAvgOrderByAggregateInput
    _max?: UserMonthlyBalanceMaxOrderByAggregateInput
    _min?: UserMonthlyBalanceMinOrderByAggregateInput
    _sum?: UserMonthlyBalanceSumOrderByAggregateInput
  }

  export type UserMonthlyBalanceScalarWhereWithAggregatesInput = {
    AND?: UserMonthlyBalanceScalarWhereWithAggregatesInput | UserMonthlyBalanceScalarWhereWithAggregatesInput[]
    OR?: UserMonthlyBalanceScalarWhereWithAggregatesInput[]
    NOT?: UserMonthlyBalanceScalarWhereWithAggregatesInput | UserMonthlyBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMonthlyBalance"> | string
    userId?: StringWithAggregatesFilter<"UserMonthlyBalance"> | string
    monthStartDate?: DateTimeWithAggregatesFilter<"UserMonthlyBalance"> | Date | string
    startingBalance?: FloatWithAggregatesFilter<"UserMonthlyBalance"> | number
    creditsGranted?: FloatWithAggregatesFilter<"UserMonthlyBalance"> | number
    creditsSpent?: FloatWithAggregatesFilter<"UserMonthlyBalance"> | number
    endingBalance?: FloatWithAggregatesFilter<"UserMonthlyBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserMonthlyBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserMonthlyBalance"> | Date | string
  }

  export type UserPlanWhereInput = {
    AND?: UserPlanWhereInput | UserPlanWhereInput[]
    OR?: UserPlanWhereInput[]
    NOT?: UserPlanWhereInput | UserPlanWhereInput[]
    id?: StringFilter<"UserPlan"> | string
    userId?: StringFilter<"UserPlan"> | string
    planId?: StringFilter<"UserPlan"> | string
    status?: EnumSubscriptionStatusFilter<"UserPlan"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"UserPlan"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"UserPlan"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"UserPlan"> | boolean
    canceledAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPlan"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlan"> | Date | string
    lastCreditsGrantedAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    paypalSubscriptionId?: StringNullableFilter<"UserPlan"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type UserPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastCreditsGrantedAt?: SortOrderInput | SortOrder
    paypalSubscriptionId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
  }

  export type UserPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paypalSubscriptionId?: string
    AND?: UserPlanWhereInput | UserPlanWhereInput[]
    OR?: UserPlanWhereInput[]
    NOT?: UserPlanWhereInput | UserPlanWhereInput[]
    userId?: StringFilter<"UserPlan"> | string
    planId?: StringFilter<"UserPlan"> | string
    status?: EnumSubscriptionStatusFilter<"UserPlan"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"UserPlan"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"UserPlan"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"UserPlan"> | boolean
    canceledAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPlan"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlan"> | Date | string
    lastCreditsGrantedAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id" | "paypalSubscriptionId">

  export type UserPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastCreditsGrantedAt?: SortOrderInput | SortOrder
    paypalSubscriptionId?: SortOrderInput | SortOrder
    _count?: UserPlanCountOrderByAggregateInput
    _max?: UserPlanMaxOrderByAggregateInput
    _min?: UserPlanMinOrderByAggregateInput
  }

  export type UserPlanScalarWhereWithAggregatesInput = {
    AND?: UserPlanScalarWhereWithAggregatesInput | UserPlanScalarWhereWithAggregatesInput[]
    OR?: UserPlanScalarWhereWithAggregatesInput[]
    NOT?: UserPlanScalarWhereWithAggregatesInput | UserPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPlan"> | string
    userId?: StringWithAggregatesFilter<"UserPlan"> | string
    planId?: StringWithAggregatesFilter<"UserPlan"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserPlan"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeWithAggregatesFilter<"UserPlan"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"UserPlan"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"UserPlan"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"UserPlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPlan"> | Date | string
    lastCreditsGrantedAt?: DateTimeNullableWithAggregatesFilter<"UserPlan"> | Date | string | null
    paypalSubscriptionId?: StringNullableWithAggregatesFilter<"UserPlan"> | string | null
  }

  export type UserPlusAccessWhereInput = {
    AND?: UserPlusAccessWhereInput | UserPlusAccessWhereInput[]
    OR?: UserPlusAccessWhereInput[]
    NOT?: UserPlusAccessWhereInput | UserPlusAccessWhereInput[]
    id?: StringFilter<"UserPlusAccess"> | string
    userId?: StringFilter<"UserPlusAccess"> | string
    grantedBy?: StringNullableFilter<"UserPlusAccess"> | string | null
    reason?: StringNullableFilter<"UserPlusAccess"> | string | null
    startDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    endDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    isActive?: BoolFilter<"UserPlusAccess"> | boolean
    createdAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPlusAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPlusAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPlusAccessWhereInput | UserPlusAccessWhereInput[]
    OR?: UserPlusAccessWhereInput[]
    NOT?: UserPlusAccessWhereInput | UserPlusAccessWhereInput[]
    userId?: StringFilter<"UserPlusAccess"> | string
    grantedBy?: StringNullableFilter<"UserPlusAccess"> | string | null
    reason?: StringNullableFilter<"UserPlusAccess"> | string | null
    startDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    endDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    isActive?: BoolFilter<"UserPlusAccess"> | boolean
    createdAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPlusAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPlusAccessCountOrderByAggregateInput
    _max?: UserPlusAccessMaxOrderByAggregateInput
    _min?: UserPlusAccessMinOrderByAggregateInput
  }

  export type UserPlusAccessScalarWhereWithAggregatesInput = {
    AND?: UserPlusAccessScalarWhereWithAggregatesInput | UserPlusAccessScalarWhereWithAggregatesInput[]
    OR?: UserPlusAccessScalarWhereWithAggregatesInput[]
    NOT?: UserPlusAccessScalarWhereWithAggregatesInput | UserPlusAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPlusAccess"> | string
    userId?: StringWithAggregatesFilter<"UserPlusAccess"> | string
    grantedBy?: StringNullableWithAggregatesFilter<"UserPlusAccess"> | string | null
    reason?: StringNullableWithAggregatesFilter<"UserPlusAccess"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"UserPlusAccess"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"UserPlusAccess"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserPlusAccess"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPlusAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPlusAccess"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
  }

  export type ContentClassificationCreateInput = {
    id?: string
    ageRating: $Enums.AgeRating
    contentTags?: ContentClassificationCreatecontentTagsInput | $Enums.ContentTag[]
    reason?: string | null
    contentType: string
    contentId: string
    autoClassified?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentClassificationUncheckedCreateInput = {
    id?: string
    ageRating: $Enums.AgeRating
    contentTags?: ContentClassificationCreatecontentTagsInput | $Enums.ContentTag[]
    reason?: string | null
    contentType: string
    contentId: string
    autoClassified?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: ContentClassificationUpdatecontentTagsInput | $Enums.ContentTag[]
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    autoClassified?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: ContentClassificationUpdatecontentTagsInput | $Enums.ContentTag[]
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    autoClassified?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentClassificationCreateManyInput = {
    id?: string
    ageRating: $Enums.AgeRating
    contentTags?: ContentClassificationCreatecontentTagsInput | $Enums.ContentTag[]
    reason?: string | null
    contentType: string
    contentId: string
    autoClassified?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: ContentClassificationUpdatecontentTagsInput | $Enums.ContentTag[]
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    autoClassified?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: ContentClassificationUpdatecontentTagsInput | $Enums.ContentTag[]
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    autoClassified?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoraCreateInput = {
    id?: string
    civitaiModelId?: string | null
    civitaiVersionId?: string | null
    name: string
    modelType?: string | null
    baseModel?: string | null
    downloadCount?: number | null
    modelUrl?: string | null
    tags?: LoraCreatetagsInput | string[]
    trainedWords?: LoraCreatetrainedWordsInput | string[]
    nsfw?: boolean
    filename?: string | null
    filepathRelative?: string | null
    firstImageUrl?: string | null
    imageUrls?: LoraCreateimageUrlsInput | string[]
    category?: string | null
    term?: string | null
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutLoraInput
  }

  export type LoraUncheckedCreateInput = {
    id?: string
    civitaiModelId?: string | null
    civitaiVersionId?: string | null
    name: string
    modelType?: string | null
    baseModel?: string | null
    downloadCount?: number | null
    modelUrl?: string | null
    tags?: LoraCreatetagsInput | string[]
    trainedWords?: LoraCreatetrainedWordsInput | string[]
    nsfw?: boolean
    filename?: string | null
    filepathRelative?: string | null
    firstImageUrl?: string | null
    imageUrls?: LoraCreateimageUrlsInput | string[]
    category?: string | null
    term?: string | null
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutLoraInput
  }

  export type LoraUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutLoraNestedInput
  }

  export type LoraUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutLoraNestedInput
  }

  export type LoraCreateManyInput = {
    id?: string
    civitaiModelId?: string | null
    civitaiVersionId?: string | null
    name: string
    modelType?: string | null
    baseModel?: string | null
    downloadCount?: number | null
    modelUrl?: string | null
    tags?: LoraCreatetagsInput | string[]
    trainedWords?: LoraCreatetrainedWordsInput | string[]
    nsfw?: boolean
    filename?: string | null
    filepathRelative?: string | null
    firstImageUrl?: string | null
    imageUrls?: LoraCreateimageUrlsInput | string[]
    category?: string | null
    term?: string | null
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoraUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoraUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttireCreateInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCreatedAttiresInput
    charactersUsingAsMain?: CharacterCreateNestedManyWithoutMainAttireInput
    characters?: CharacterCreateNestedManyWithoutAttiresInput
  }

  export type AttireUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    userId: string
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    charactersUsingAsMain?: CharacterUncheckedCreateNestedManyWithoutMainAttireInput
    characters?: CharacterUncheckedCreateNestedManyWithoutAttiresInput
  }

  export type AttireUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCreatedAttiresNestedInput
    charactersUsingAsMain?: CharacterUpdateManyWithoutMainAttireNestedInput
    characters?: CharacterUpdateManyWithoutAttiresNestedInput
  }

  export type AttireUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charactersUsingAsMain?: CharacterUncheckedUpdateManyWithoutMainAttireNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutAttiresNestedInput
  }

  export type AttireCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    userId: string
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttireUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttireUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutTagsInput
    stories?: StoryCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutTagsInput
    stories?: StoryUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutTagsNestedInput
    stories?: StoryUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutTagsNestedInput
    stories?: StoryUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerCreateInput = {
    id?: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutStickersInput
  }

  export type CharacterStickerUncheckedCreateInput = {
    id?: string
    characterId: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterStickerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutStickersNestedInput
  }

  export type CharacterStickerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerCreateManyInput = {
    id?: string
    characterId: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterStickerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageCreateInput = {
    id?: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutImagesInput
  }

  export type CharacterImageUncheckedCreateInput = {
    id?: string
    characterId: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutImagesNestedInput
  }

  export type CharacterImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageCreateManyInput = {
    id?: string
    characterId: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCreateInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutStoriesInput
    characters?: CharacterCreateNestedManyWithoutStoriesInput
    tags?: TagCreateNestedManyWithoutStoriesInput
    conversations?: ConversationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutStoriesInput
    tags?: TagUncheckedCreateNestedManyWithoutStoriesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    characters?: CharacterUpdateManyWithoutStoriesNestedInput
    tags?: TagUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutStoriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantCreateInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultCharacter?: CharacterCreateNestedOneWithoutAssistantsUsingAsDefaultInput
    creator: UserCreateNestedOneWithoutAssistantsInput
    participations?: ConversationParticipantCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    defaultCharacterId?: string | null
    visibility?: $Enums.Visibility
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultCharacter?: CharacterUpdateOneWithoutAssistantsUsingAsDefaultNestedInput
    creator?: UserUpdateOneRequiredWithoutAssistantsNestedInput
    participations?: ConversationParticipantUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    defaultCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: ConversationParticipantUncheckedUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    defaultCharacterId?: string | null
    visibility?: $Enums.Visibility
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    defaultCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipCreateInput = {
    id?: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
    conversation: ConversationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembershipsInput
    inviter?: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type UserConversationMembershipUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type UserConversationMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    inviter?: UserUpdateOneWithoutSentInvitesNestedInput
  }

  export type UserConversationMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type UserConversationMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantCreateInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user?: UserCreateNestedOneWithoutConversationParticipationsInput
    actingCharacter?: CharacterCreateNestedOneWithoutActingParticipationsInput
    actingAssistant?: AssistantCreateNestedOneWithoutParticipationsInput
    representingCharacter?: CharacterCreateNestedOneWithoutRepresentingParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneWithoutConversationParticipationsNestedInput
    actingCharacter?: CharacterUpdateOneWithoutActingParticipationsNestedInput
    actingAssistant?: AssistantUpdateOneWithoutParticipationsNestedInput
    representingCharacter?: CharacterUpdateOneWithoutRepresentingParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCharacterCreateInput = {
    id?: string
    characterId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteCharactersInput
  }

  export type FavoriteCharacterUncheckedCreateInput = {
    id?: string
    userId: string
    characterId: string
    createdAt?: Date | string
  }

  export type FavoriteCharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteCharactersNestedInput
  }

  export type FavoriteCharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCharacterCreateManyInput = {
    id?: string
    userId: string
    characterId: string
    createdAt?: Date | string
  }

  export type FavoriteCharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentTranslationCreateInput = {
    id?: string
    contentType: string
    contentId: string
    fieldName: string
    originalLanguageCode: string
    targetLanguageCode: string
    originalText: string
    translatedText: string
    translationProvider?: string | null
    translationModel?: string | null
    confidence?: number | null
    status?: $Enums.TranslationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    translationTimeMs?: number | null
    characterCount?: number | null
    sourceVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentTranslationUncheckedCreateInput = {
    id?: string
    contentType: string
    contentId: string
    fieldName: string
    originalLanguageCode: string
    targetLanguageCode: string
    originalText: string
    translatedText: string
    translationProvider?: string | null
    translationModel?: string | null
    confidence?: number | null
    status?: $Enums.TranslationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    translationTimeMs?: number | null
    characterCount?: number | null
    sourceVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    originalLanguageCode?: StringFieldUpdateOperationsInput | string
    targetLanguageCode?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    translatedText?: StringFieldUpdateOperationsInput | string
    translationProvider?: NullableStringFieldUpdateOperationsInput | string | null
    translationModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translationTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    characterCount?: NullableIntFieldUpdateOperationsInput | number | null
    sourceVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    originalLanguageCode?: StringFieldUpdateOperationsInput | string
    targetLanguageCode?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    translatedText?: StringFieldUpdateOperationsInput | string
    translationProvider?: NullableStringFieldUpdateOperationsInput | string | null
    translationModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translationTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    characterCount?: NullableIntFieldUpdateOperationsInput | number | null
    sourceVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentTranslationCreateManyInput = {
    id?: string
    contentType: string
    contentId: string
    fieldName: string
    originalLanguageCode: string
    targetLanguageCode: string
    originalText: string
    translatedText: string
    translationProvider?: string | null
    translationModel?: string | null
    confidence?: number | null
    status?: $Enums.TranslationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    translationTimeMs?: number | null
    characterCount?: number | null
    sourceVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    originalLanguageCode?: StringFieldUpdateOperationsInput | string
    targetLanguageCode?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    translatedText?: StringFieldUpdateOperationsInput | string
    translationProvider?: NullableStringFieldUpdateOperationsInput | string | null
    translationModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translationTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    characterCount?: NullableIntFieldUpdateOperationsInput | number | null
    sourceVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    originalLanguageCode?: StringFieldUpdateOperationsInput | string
    targetLanguageCode?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    translatedText?: StringFieldUpdateOperationsInput | string
    translationProvider?: NullableStringFieldUpdateOperationsInput | string | null
    translationModel?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translationTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    characterCount?: NullableIntFieldUpdateOperationsInput | number | null
    sourceVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryCreateInput = {
    id?: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMemoriesInput
  }

  export type ConversationMemoryUncheckedCreateInput = {
    id?: string
    conversationId: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationMemoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMemoriesNestedInput
  }

  export type ConversationMemoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryCreateManyInput = {
    id?: string
    conversationId: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationMemoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionCreateInput = {
    id?: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutCreditTransactionsInput
  }

  export type CreditTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
  }

  export type CreditTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreditTransactionsNestedInput
  }

  export type CreditTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionCreateManyInput = {
    id?: string
    userId: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
  }

  export type CreditTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paypalPlanId?: string | null
    userPlans?: UserPlanCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paypalPlanId?: string | null
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    userPlans?: UserPlanUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    userPlans?: UserPlanUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paypalPlanId?: string | null
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreditCostCreateInput = {
    id?: string
    serviceIdentifier: string
    creditsPerUnit: number
    unitDescription: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreditCostUncheckedCreateInput = {
    id?: string
    serviceIdentifier: string
    creditsPerUnit: number
    unitDescription: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreditCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceIdentifier?: StringFieldUpdateOperationsInput | string
    creditsPerUnit?: FloatFieldUpdateOperationsInput | number
    unitDescription?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreditCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceIdentifier?: StringFieldUpdateOperationsInput | string
    creditsPerUnit?: FloatFieldUpdateOperationsInput | number
    unitDescription?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreditCostCreateManyInput = {
    id?: string
    serviceIdentifier: string
    creditsPerUnit: number
    unitDescription: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreditCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceIdentifier?: StringFieldUpdateOperationsInput | string
    creditsPerUnit?: FloatFieldUpdateOperationsInput | number
    unitDescription?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreditCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceIdentifier?: StringFieldUpdateOperationsInput | string
    creditsPerUnit?: FloatFieldUpdateOperationsInput | number
    unitDescription?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateInput = {
    id?: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateInput = {
    id?: string
    userId: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type UsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateManyInput = {
    id?: string
    userId: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type UsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceCreateInput = {
    id?: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMonthlyBalancesInput
  }

  export type UserMonthlyBalanceUncheckedCreateInput = {
    id?: string
    userId: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonthlyBalancesNestedInput
  }

  export type UserMonthlyBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceCreateManyInput = {
    id?: string
    userId: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlanCreateInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
    user: UserCreateNestedOneWithoutUserPlansInput
    plan: PlanCreateNestedOneWithoutUserPlansInput
  }

  export type UserPlanUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserPlansNestedInput
    plan?: PlanUpdateOneRequiredWithoutUserPlansNestedInput
  }

  export type UserPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlanCreateManyInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlusAccessCreateInput = {
    id?: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlusAccessGrantsInput
  }

  export type UserPlusAccessUncheckedCreateInput = {
    id?: string
    userId: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPlusAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlusAccessGrantsNestedInput
  }

  export type UserPlusAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlusAccessCreateManyInput = {
    id?: string
    userId: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPlusAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlusAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAvatarSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarSource | EnumAvatarSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarSourceFilter<$PrismaModel> | $Enums.AvatarSource
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type EnumContentTagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentTag[] | ListEnumContentTagFieldRefInput<$PrismaModel> | null
    has?: $Enums.ContentTag | EnumContentTagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ContentTag[] | ListEnumContentTagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ContentTag[] | ListEnumContentTagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type StoryListRelationFilter = {
    every?: StoryWhereInput
    some?: StoryWhereInput
    none?: StoryWhereInput
  }

  export type AttireListRelationFilter = {
    every?: AttireWhereInput
    some?: AttireWhereInput
    none?: AttireWhereInput
  }

  export type AssistantListRelationFilter = {
    every?: AssistantWhereInput
    some?: AssistantWhereInput
    none?: AssistantWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type UserConversationMembershipListRelationFilter = {
    every?: UserConversationMembershipWhereInput
    some?: UserConversationMembershipWhereInput
    none?: UserConversationMembershipWhereInput
  }

  export type FavoriteCharacterListRelationFilter = {
    every?: FavoriteCharacterWhereInput
    some?: FavoriteCharacterWhereInput
    none?: FavoriteCharacterWhereInput
  }

  export type CreditTransactionListRelationFilter = {
    every?: CreditTransactionWhereInput
    some?: CreditTransactionWhereInput
    none?: CreditTransactionWhereInput
  }

  export type UsageLogListRelationFilter = {
    every?: UsageLogWhereInput
    some?: UsageLogWhereInput
    none?: UsageLogWhereInput
  }

  export type UserMonthlyBalanceListRelationFilter = {
    every?: UserMonthlyBalanceWhereInput
    some?: UserMonthlyBalanceWhereInput
    none?: UserMonthlyBalanceWhereInput
  }

  export type UserPlanListRelationFilter = {
    every?: UserPlanWhereInput
    some?: UserPlanWhereInput
    none?: UserPlanWhereInput
  }

  export type UserPlusAccessListRelationFilter = {
    every?: UserPlusAccessWhereInput
    some?: UserPlusAccessWhereInput
    none?: UserPlusAccessWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssistantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserConversationMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteCharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMonthlyBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPlusAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProviderProviderAccountIdCompoundUniqueInput = {
    provider: $Enums.AuthProvider
    providerAccountId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    avatarSource?: SortOrder
    avatarUpdatedAt?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    preferredLanguage?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxAgeRating?: SortOrder
    blockedTags?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    avatarSource?: SortOrder
    avatarUpdatedAt?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    preferredLanguage?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxAgeRating?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    username?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    avatarSource?: SortOrder
    avatarUpdatedAt?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    preferredLanguage?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxAgeRating?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAvatarSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarSource | EnumAvatarSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarSourceWithAggregatesFilter<$PrismaModel> | $Enums.AvatarSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvatarSourceFilter<$PrismaModel>
    _max?: NestedEnumAvatarSourceFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContentClassificationContentTypeContentIdCompoundUniqueInput = {
    contentType: string
    contentId: string
  }

  export type ContentClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    reason?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    autoClassified?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    ageRating?: SortOrder
    reason?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    autoClassified?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    ageRating?: SortOrder
    reason?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    autoClassified?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LoraCountOrderByAggregateInput = {
    id?: SortOrder
    civitaiModelId?: SortOrder
    civitaiVersionId?: SortOrder
    name?: SortOrder
    modelType?: SortOrder
    baseModel?: SortOrder
    downloadCount?: SortOrder
    modelUrl?: SortOrder
    tags?: SortOrder
    trainedWords?: SortOrder
    nsfw?: SortOrder
    filename?: SortOrder
    filepathRelative?: SortOrder
    firstImageUrl?: SortOrder
    imageUrls?: SortOrder
    category?: SortOrder
    term?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoraAvgOrderByAggregateInput = {
    downloadCount?: SortOrder
  }

  export type LoraMaxOrderByAggregateInput = {
    id?: SortOrder
    civitaiModelId?: SortOrder
    civitaiVersionId?: SortOrder
    name?: SortOrder
    modelType?: SortOrder
    baseModel?: SortOrder
    downloadCount?: SortOrder
    modelUrl?: SortOrder
    nsfw?: SortOrder
    filename?: SortOrder
    filepathRelative?: SortOrder
    firstImageUrl?: SortOrder
    category?: SortOrder
    term?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoraMinOrderByAggregateInput = {
    id?: SortOrder
    civitaiModelId?: SortOrder
    civitaiVersionId?: SortOrder
    name?: SortOrder
    modelType?: SortOrder
    baseModel?: SortOrder
    downloadCount?: SortOrder
    modelUrl?: SortOrder
    nsfw?: SortOrder
    filename?: SortOrder
    filepathRelative?: SortOrder
    firstImageUrl?: SortOrder
    category?: SortOrder
    term?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoraSumOrderByAggregateInput = {
    downloadCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AttireCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    promptHead?: SortOrder
    promptBody?: SortOrder
    promptFull?: SortOrder
    previewImageUrl?: SortOrder
    originalLanguageCode?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttireAvgOrderByAggregateInput = {
    contentVersion?: SortOrder
  }

  export type AttireMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    promptHead?: SortOrder
    promptBody?: SortOrder
    promptFull?: SortOrder
    previewImageUrl?: SortOrder
    originalLanguageCode?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    ageRating?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttireMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    promptHead?: SortOrder
    promptBody?: SortOrder
    promptFull?: SortOrder
    previewImageUrl?: SortOrder
    originalLanguageCode?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    ageRating?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttireSumOrderByAggregateInput = {
    contentVersion?: SortOrder
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type TagNameTypeCompoundUniqueInput = {
    name: string
    type: $Enums.TagType
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    originalLanguageCode?: SortOrder
    weight?: SortOrder
    searchable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    ageRating?: SortOrder
    originalLanguageCode?: SortOrder
    weight?: SortOrder
    searchable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    ageRating?: SortOrder
    originalLanguageCode?: SortOrder
    weight?: SortOrder
    searchable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type EnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type EnumVisualStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VisualStyle | EnumVisualStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisualStyleNullableFilter<$PrismaModel> | $Enums.VisualStyle | null
  }

  export type LoraNullableScalarRelationFilter = {
    is?: LoraWhereInput | null
    isNot?: LoraWhereInput | null
  }

  export type AttireNullableScalarRelationFilter = {
    is?: AttireWhereInput | null
    isNot?: AttireWhereInput | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CharacterStickerListRelationFilter = {
    every?: CharacterStickerWhereInput
    some?: CharacterStickerWhereInput
    none?: CharacterStickerWhereInput
  }

  export type CharacterImageListRelationFilter = {
    every?: CharacterImageWhereInput
    some?: CharacterImageWhereInput
    none?: CharacterImageWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterStickerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    style?: SortOrder
    reference?: SortOrder
    physicalCharacteristics?: SortOrder
    personality?: SortOrder
    history?: SortOrder
    visibility?: SortOrder
    isSystemCharacter?: SortOrder
    originalLanguageCode?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    userId?: SortOrder
    loraId?: SortOrder
    mainAttireId?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    age?: SortOrder
    contentVersion?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    style?: SortOrder
    reference?: SortOrder
    physicalCharacteristics?: SortOrder
    personality?: SortOrder
    history?: SortOrder
    visibility?: SortOrder
    isSystemCharacter?: SortOrder
    originalLanguageCode?: SortOrder
    ageRating?: SortOrder
    userId?: SortOrder
    loraId?: SortOrder
    mainAttireId?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    style?: SortOrder
    reference?: SortOrder
    physicalCharacteristics?: SortOrder
    personality?: SortOrder
    history?: SortOrder
    visibility?: SortOrder
    isSystemCharacter?: SortOrder
    originalLanguageCode?: SortOrder
    ageRating?: SortOrder
    userId?: SortOrder
    loraId?: SortOrder
    mainAttireId?: SortOrder
    contentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    age?: SortOrder
    contentVersion?: SortOrder
  }

  export type EnumVisualStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisualStyle | EnumVisualStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisualStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.VisualStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVisualStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumVisualStyleNullableFilter<$PrismaModel>
  }

  export type EnumStickerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StickerStatus | EnumStickerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStickerStatusFilter<$PrismaModel> | $Enums.StickerStatus
  }

  export type CharacterScalarRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CharacterStickerCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    emotionTag?: SortOrder
    actionTag?: SortOrder
    imageUrl?: SortOrder
    promptUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterStickerMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    emotionTag?: SortOrder
    actionTag?: SortOrder
    imageUrl?: SortOrder
    promptUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterStickerMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    emotionTag?: SortOrder
    actionTag?: SortOrder
    imageUrl?: SortOrder
    promptUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStickerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickerStatus | EnumStickerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStickerStatusWithAggregatesFilter<$PrismaModel> | $Enums.StickerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickerStatusFilter<$PrismaModel>
    _max?: NestedEnumStickerStatusFilter<$PrismaModel>
  }

  export type EnumImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeFilter<$PrismaModel> | $Enums.ImageType
  }

  export type CharacterImageCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    contentType?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterImageAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type CharacterImageMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    contentType?: SortOrder
    ageRating?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterImageMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    key?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    contentType?: SortOrder
    ageRating?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterImageSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type EnumImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageTypeFilter<$PrismaModel>
    _max?: NestedEnumImageTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    initialText?: SortOrder
    coverImage?: SortOrder
    objectives?: SortOrder
    authorId?: SortOrder
    ageRating?: SortOrder
    contentTags?: SortOrder
    visibility?: SortOrder
    contentVersion?: SortOrder
    originalLanguageCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryAvgOrderByAggregateInput = {
    contentVersion?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    initialText?: SortOrder
    coverImage?: SortOrder
    authorId?: SortOrder
    ageRating?: SortOrder
    visibility?: SortOrder
    contentVersion?: SortOrder
    originalLanguageCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    synopsis?: SortOrder
    initialText?: SortOrder
    coverImage?: SortOrder
    authorId?: SortOrder
    ageRating?: SortOrder
    visibility?: SortOrder
    contentVersion?: SortOrder
    originalLanguageCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorySumOrderByAggregateInput = {
    contentVersion?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CharacterNullableScalarRelationFilter = {
    is?: CharacterWhereInput | null
    isNot?: CharacterWhereInput | null
  }

  export type AssistantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    defaultCharacterId?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssistantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    defaultCharacterId?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssistantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    defaultCharacterId?: SortOrder
    visibility?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryNullableScalarRelationFilter = {
    is?: StoryWhereInput | null
    isNot?: StoryWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationMemoryListRelationFilter = {
    every?: ConversationMemoryWhereInput
    some?: ConversationMemoryWhereInput
    none?: ConversationMemoryWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationMemoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isTitleUserEdited?: SortOrder
    isTitleSystemEdited?: SortOrder
    projectId?: SortOrder
    storyId?: SortOrder
    settings?: SortOrder
    lastMessageAt?: SortOrder
    titleLastUpdatedAt?: SortOrder
    memoryLastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    isMultiUser?: SortOrder
    maxUsers?: SortOrder
    ownerUserId?: SortOrder
    allowUserInvites?: SortOrder
    requireApproval?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    maxUsers?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isTitleUserEdited?: SortOrder
    isTitleSystemEdited?: SortOrder
    projectId?: SortOrder
    storyId?: SortOrder
    lastMessageAt?: SortOrder
    titleLastUpdatedAt?: SortOrder
    memoryLastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    isMultiUser?: SortOrder
    maxUsers?: SortOrder
    ownerUserId?: SortOrder
    allowUserInvites?: SortOrder
    requireApproval?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isTitleUserEdited?: SortOrder
    isTitleSystemEdited?: SortOrder
    projectId?: SortOrder
    storyId?: SortOrder
    lastMessageAt?: SortOrder
    titleLastUpdatedAt?: SortOrder
    memoryLastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    isMultiUser?: SortOrder
    maxUsers?: SortOrder
    ownerUserId?: SortOrder
    allowUserInvites?: SortOrder
    requireApproval?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    maxUsers?: SortOrder
  }

  export type EnumMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleFilter<$PrismaModel> | $Enums.MembershipRole
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type UserConversationMembershipConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type UserConversationMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    canWrite?: SortOrder
    canInvite?: SortOrder
    canModerate?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    isActive?: SortOrder
  }

  export type UserConversationMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    canWrite?: SortOrder
    canInvite?: SortOrder
    canModerate?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    isActive?: SortOrder
  }

  export type UserConversationMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    canWrite?: SortOrder
    canInvite?: SortOrder
    canModerate?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    isActive?: SortOrder
  }

  export type EnumMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.MembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumMembershipRoleFilter<$PrismaModel>
  }

  export type AssistantNullableScalarRelationFilter = {
    is?: AssistantWhereInput | null
    isNot?: AssistantWhereInput | null
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    actingCharacterId?: SortOrder
    actingAssistantId?: SortOrder
    representingCharacterId?: SortOrder
    configOverride?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    actingCharacterId?: SortOrder
    actingAssistantId?: SortOrder
    representingCharacterId?: SortOrder
    configOverride?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    actingCharacterId?: SortOrder
    actingAssistantId?: SortOrder
    representingCharacterId?: SortOrder
    configOverride?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type FavoriteCharacterUserIdCharacterIdCompoundUniqueInput = {
    userId: string
    characterId: string
  }

  export type FavoriteCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTranslationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusFilter<$PrismaModel> | $Enums.TranslationStatus
  }

  export type ContentTranslationContentTypeContentIdFieldNameTargetLanguageCodeCompoundUniqueInput = {
    contentType: string
    contentId: string
    fieldName: string
    targetLanguageCode: string
  }

  export type ContentTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    fieldName?: SortOrder
    originalLanguageCode?: SortOrder
    targetLanguageCode?: SortOrder
    originalText?: SortOrder
    translatedText?: SortOrder
    translationProvider?: SortOrder
    translationModel?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    translationTimeMs?: SortOrder
    characterCount?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTranslationAvgOrderByAggregateInput = {
    confidence?: SortOrder
    translationTimeMs?: SortOrder
    characterCount?: SortOrder
    sourceVersion?: SortOrder
  }

  export type ContentTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    fieldName?: SortOrder
    originalLanguageCode?: SortOrder
    targetLanguageCode?: SortOrder
    originalText?: SortOrder
    translatedText?: SortOrder
    translationProvider?: SortOrder
    translationModel?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    translationTimeMs?: SortOrder
    characterCount?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    contentId?: SortOrder
    fieldName?: SortOrder
    originalLanguageCode?: SortOrder
    targetLanguageCode?: SortOrder
    originalText?: SortOrder
    translatedText?: SortOrder
    translationProvider?: SortOrder
    translationModel?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    translationTimeMs?: SortOrder
    characterCount?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentTranslationSumOrderByAggregateInput = {
    confidence?: SortOrder
    translationTimeMs?: SortOrder
    characterCount?: SortOrder
    sourceVersion?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTranslationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranslationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationStatusFilter<$PrismaModel>
    _max?: NestedEnumTranslationStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConversationMemoryCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    summary?: SortOrder
    keyEvents?: SortOrder
    messageCount?: SortOrder
    startMessageId?: SortOrder
    endMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMemoryAvgOrderByAggregateInput = {
    messageCount?: SortOrder
  }

  export type ConversationMemoryMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    summary?: SortOrder
    messageCount?: SortOrder
    startMessageId?: SortOrder
    endMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMemoryMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    summary?: SortOrder
    messageCount?: SortOrder
    startMessageId?: SortOrder
    endMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMemorySumOrderByAggregateInput = {
    messageCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumCreditTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeFilter<$PrismaModel> | $Enums.CreditTransactionType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CreditTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amountCredits?: SortOrder
    balanceAfter?: SortOrder
    notes?: SortOrder
    relatedUsageLogId?: SortOrder
    relatedPlanId?: SortOrder
    timestamp?: SortOrder
  }

  export type CreditTransactionAvgOrderByAggregateInput = {
    amountCredits?: SortOrder
    balanceAfter?: SortOrder
  }

  export type CreditTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amountCredits?: SortOrder
    balanceAfter?: SortOrder
    notes?: SortOrder
    relatedUsageLogId?: SortOrder
    relatedPlanId?: SortOrder
    timestamp?: SortOrder
  }

  export type CreditTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amountCredits?: SortOrder
    balanceAfter?: SortOrder
    notes?: SortOrder
    relatedUsageLogId?: SortOrder
    relatedPlanId?: SortOrder
    timestamp?: SortOrder
  }

  export type CreditTransactionSumOrderByAggregateInput = {
    amountCredits?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreditTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPlanTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierFilter<$PrismaModel> | $Enums.PlanTier
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    tier?: SortOrder
    name?: SortOrder
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
    description?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paypalPlanId?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    tier?: SortOrder
    name?: SortOrder
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paypalPlanId?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    tier?: SortOrder
    name?: SortOrder
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paypalPlanId?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    creditsPerMonth?: SortOrder
  }

  export type EnumPlanTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierWithAggregatesFilter<$PrismaModel> | $Enums.PlanTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTierFilter<$PrismaModel>
    _max?: NestedEnumPlanTierFilter<$PrismaModel>
  }

  export type ServiceCreditCostCountOrderByAggregateInput = {
    id?: SortOrder
    serviceIdentifier?: SortOrder
    creditsPerUnit?: SortOrder
    unitDescription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCreditCostAvgOrderByAggregateInput = {
    creditsPerUnit?: SortOrder
  }

  export type ServiceCreditCostMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceIdentifier?: SortOrder
    creditsPerUnit?: SortOrder
    unitDescription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCreditCostMinOrderByAggregateInput = {
    id?: SortOrder
    serviceIdentifier?: SortOrder
    creditsPerUnit?: SortOrder
    unitDescription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCreditCostSumOrderByAggregateInput = {
    creditsPerUnit?: SortOrder
  }

  export type UsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    serviceType?: SortOrder
    providerName?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    charactersProcessed?: SortOrder
    imagesProcessed?: SortOrder
    costUsd?: SortOrder
    creditsConsumed?: SortOrder
    additionalMetadata?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageLogAvgOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    charactersProcessed?: SortOrder
    imagesProcessed?: SortOrder
    costUsd?: SortOrder
    creditsConsumed?: SortOrder
  }

  export type UsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    serviceType?: SortOrder
    providerName?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    charactersProcessed?: SortOrder
    imagesProcessed?: SortOrder
    costUsd?: SortOrder
    creditsConsumed?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    serviceType?: SortOrder
    providerName?: SortOrder
    modelName?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    charactersProcessed?: SortOrder
    imagesProcessed?: SortOrder
    costUsd?: SortOrder
    creditsConsumed?: SortOrder
    processed?: SortOrder
    processedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type UsageLogSumOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    charactersProcessed?: SortOrder
    imagesProcessed?: SortOrder
    costUsd?: SortOrder
    creditsConsumed?: SortOrder
  }

  export type UserMonthlyBalanceUserIdMonthStartDateCompoundUniqueInput = {
    userId: string
    monthStartDate: Date | string
  }

  export type UserMonthlyBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthStartDate?: SortOrder
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyBalanceAvgOrderByAggregateInput = {
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
  }

  export type UserMonthlyBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthStartDate?: SortOrder
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthStartDate?: SortOrder
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyBalanceSumOrderByAggregateInput = {
    startingBalance?: SortOrder
    creditsGranted?: SortOrder
    creditsSpent?: SortOrder
    endingBalance?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type UserPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastCreditsGrantedAt?: SortOrder
    paypalSubscriptionId?: SortOrder
  }

  export type UserPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastCreditsGrantedAt?: SortOrder
    paypalSubscriptionId?: SortOrder
  }

  export type UserPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastCreditsGrantedAt?: SortOrder
    paypalSubscriptionId?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type UserPlusAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPlusAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPlusAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    grantedBy?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateblockedTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type CharacterCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput> | CharacterCreateWithoutCreatorInput[] | CharacterUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCreatorInput | CharacterCreateOrConnectWithoutCreatorInput[]
    createMany?: CharacterCreateManyCreatorInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StoryCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type AttireCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput> | AttireCreateWithoutOwnerInput[] | AttireUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutOwnerInput | AttireCreateOrConnectWithoutOwnerInput[]
    createMany?: AttireCreateManyOwnerInputEnvelope
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
  }

  export type AssistantCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput> | AssistantCreateWithoutCreatorInput[] | AssistantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutCreatorInput | AssistantCreateOrConnectWithoutCreatorInput[]
    createMany?: AssistantCreateManyCreatorInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput> | ConversationCreateWithoutOwnerInput[] | ConversationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOwnerInput | ConversationCreateOrConnectWithoutOwnerInput[]
    createMany?: ConversationCreateManyOwnerInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutConversationOwnerInput = {
    create?: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput> | ConversationCreateWithoutConversationOwnerInput[] | ConversationUncheckedCreateWithoutConversationOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationOwnerInput | ConversationCreateOrConnectWithoutConversationOwnerInput[]
    createMany?: ConversationCreateManyConversationOwnerInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type UserConversationMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput> | UserConversationMembershipCreateWithoutUserInput[] | UserConversationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutUserInput | UserConversationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: UserConversationMembershipCreateManyUserInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type UserConversationMembershipCreateNestedManyWithoutInviterInput = {
    create?: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput> | UserConversationMembershipCreateWithoutInviterInput[] | UserConversationMembershipUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutInviterInput | UserConversationMembershipCreateOrConnectWithoutInviterInput[]
    createMany?: UserConversationMembershipCreateManyInviterInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type FavoriteCharacterCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput> | FavoriteCharacterCreateWithoutUserInput[] | FavoriteCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCharacterCreateOrConnectWithoutUserInput | FavoriteCharacterCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCharacterCreateManyUserInputEnvelope
    connect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
  }

  export type CreditTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
  }

  export type UsageLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type UserMonthlyBalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput> | UserMonthlyBalanceCreateWithoutUserInput[] | UserMonthlyBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyBalanceCreateOrConnectWithoutUserInput | UserMonthlyBalanceCreateOrConnectWithoutUserInput[]
    createMany?: UserMonthlyBalanceCreateManyUserInputEnvelope
    connect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
  }

  export type UserPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput> | UserPlanCreateWithoutUserInput[] | UserPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutUserInput | UserPlanCreateOrConnectWithoutUserInput[]
    createMany?: UserPlanCreateManyUserInputEnvelope
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
  }

  export type UserPlusAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput> | UserPlusAccessCreateWithoutUserInput[] | UserPlusAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlusAccessCreateOrConnectWithoutUserInput | UserPlusAccessCreateOrConnectWithoutUserInput[]
    createMany?: UserPlusAccessCreateManyUserInputEnvelope
    connect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput> | CharacterCreateWithoutCreatorInput[] | CharacterUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCreatorInput | CharacterCreateOrConnectWithoutCreatorInput[]
    createMany?: CharacterCreateManyCreatorInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type AttireUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput> | AttireCreateWithoutOwnerInput[] | AttireUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutOwnerInput | AttireCreateOrConnectWithoutOwnerInput[]
    createMany?: AttireCreateManyOwnerInputEnvelope
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
  }

  export type AssistantUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput> | AssistantCreateWithoutCreatorInput[] | AssistantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutCreatorInput | AssistantCreateOrConnectWithoutCreatorInput[]
    createMany?: AssistantCreateManyCreatorInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput> | ConversationCreateWithoutOwnerInput[] | ConversationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOwnerInput | ConversationCreateOrConnectWithoutOwnerInput[]
    createMany?: ConversationCreateManyOwnerInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput = {
    create?: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput> | ConversationCreateWithoutConversationOwnerInput[] | ConversationUncheckedCreateWithoutConversationOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationOwnerInput | ConversationCreateOrConnectWithoutConversationOwnerInput[]
    createMany?: ConversationCreateManyConversationOwnerInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput> | UserConversationMembershipCreateWithoutUserInput[] | UserConversationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutUserInput | UserConversationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: UserConversationMembershipCreateManyUserInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput> | UserConversationMembershipCreateWithoutInviterInput[] | UserConversationMembershipUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutInviterInput | UserConversationMembershipCreateOrConnectWithoutInviterInput[]
    createMany?: UserConversationMembershipCreateManyInviterInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput> | FavoriteCharacterCreateWithoutUserInput[] | FavoriteCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCharacterCreateOrConnectWithoutUserInput | FavoriteCharacterCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCharacterCreateManyUserInputEnvelope
    connect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
  }

  export type CreditTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
  }

  export type UsageLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput> | UserMonthlyBalanceCreateWithoutUserInput[] | UserMonthlyBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyBalanceCreateOrConnectWithoutUserInput | UserMonthlyBalanceCreateOrConnectWithoutUserInput[]
    createMany?: UserMonthlyBalanceCreateManyUserInputEnvelope
    connect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
  }

  export type UserPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput> | UserPlanCreateWithoutUserInput[] | UserPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutUserInput | UserPlanCreateOrConnectWithoutUserInput[]
    createMany?: UserPlanCreateManyUserInputEnvelope
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
  }

  export type UserPlusAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput> | UserPlusAccessCreateWithoutUserInput[] | UserPlusAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlusAccessCreateOrConnectWithoutUserInput | UserPlusAccessCreateOrConnectWithoutUserInput[]
    createMany?: UserPlusAccessCreateManyUserInputEnvelope
    connect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAvatarSourceFieldUpdateOperationsInput = {
    set?: $Enums.AvatarSource
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumAgeRatingFieldUpdateOperationsInput = {
    set?: $Enums.AgeRating
  }

  export type UserUpdateblockedTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type CharacterUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput> | CharacterCreateWithoutCreatorInput[] | CharacterUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCreatorInput | CharacterCreateOrConnectWithoutCreatorInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutCreatorInput | CharacterUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CharacterCreateManyCreatorInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutCreatorInput | CharacterUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutCreatorInput | CharacterUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type StoryUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutAuthorInput | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutAuthorInput | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutAuthorInput | StoryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type AttireUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput> | AttireCreateWithoutOwnerInput[] | AttireUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutOwnerInput | AttireCreateOrConnectWithoutOwnerInput[]
    upsert?: AttireUpsertWithWhereUniqueWithoutOwnerInput | AttireUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AttireCreateManyOwnerInputEnvelope
    set?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    disconnect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    delete?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    update?: AttireUpdateWithWhereUniqueWithoutOwnerInput | AttireUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AttireUpdateManyWithWhereWithoutOwnerInput | AttireUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AttireScalarWhereInput | AttireScalarWhereInput[]
  }

  export type AssistantUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput> | AssistantCreateWithoutCreatorInput[] | AssistantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutCreatorInput | AssistantCreateOrConnectWithoutCreatorInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutCreatorInput | AssistantUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AssistantCreateManyCreatorInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutCreatorInput | AssistantUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutCreatorInput | AssistantUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput> | ConversationCreateWithoutOwnerInput[] | ConversationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOwnerInput | ConversationCreateOrConnectWithoutOwnerInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutOwnerInput | ConversationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ConversationCreateManyOwnerInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutOwnerInput | ConversationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutOwnerInput | ConversationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutConversationOwnerNestedInput = {
    create?: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput> | ConversationCreateWithoutConversationOwnerInput[] | ConversationUncheckedCreateWithoutConversationOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationOwnerInput | ConversationCreateOrConnectWithoutConversationOwnerInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutConversationOwnerInput | ConversationUpsertWithWhereUniqueWithoutConversationOwnerInput[]
    createMany?: ConversationCreateManyConversationOwnerInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutConversationOwnerInput | ConversationUpdateWithWhereUniqueWithoutConversationOwnerInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutConversationOwnerInput | ConversationUpdateManyWithWhereWithoutConversationOwnerInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type UserConversationMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput> | UserConversationMembershipCreateWithoutUserInput[] | UserConversationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutUserInput | UserConversationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutUserInput | UserConversationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConversationMembershipCreateManyUserInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutUserInput | UserConversationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutUserInput | UserConversationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type UserConversationMembershipUpdateManyWithoutInviterNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput> | UserConversationMembershipCreateWithoutInviterInput[] | UserConversationMembershipUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutInviterInput | UserConversationMembershipCreateOrConnectWithoutInviterInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutInviterInput | UserConversationMembershipUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: UserConversationMembershipCreateManyInviterInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutInviterInput | UserConversationMembershipUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutInviterInput | UserConversationMembershipUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type FavoriteCharacterUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput> | FavoriteCharacterCreateWithoutUserInput[] | FavoriteCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCharacterCreateOrConnectWithoutUserInput | FavoriteCharacterCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteCharacterUpsertWithWhereUniqueWithoutUserInput | FavoriteCharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCharacterCreateManyUserInputEnvelope
    set?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    disconnect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    delete?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    connect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    update?: FavoriteCharacterUpdateWithWhereUniqueWithoutUserInput | FavoriteCharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteCharacterUpdateManyWithWhereWithoutUserInput | FavoriteCharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteCharacterScalarWhereInput | FavoriteCharacterScalarWhereInput[]
  }

  export type CreditTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CreditTransactionUpsertWithWhereUniqueWithoutUserInput | CreditTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    set?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    disconnect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    delete?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    update?: CreditTransactionUpdateWithWhereUniqueWithoutUserInput | CreditTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditTransactionUpdateManyWithWhereWithoutUserInput | CreditTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
  }

  export type UsageLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type UserMonthlyBalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput> | UserMonthlyBalanceCreateWithoutUserInput[] | UserMonthlyBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyBalanceCreateOrConnectWithoutUserInput | UserMonthlyBalanceCreateOrConnectWithoutUserInput[]
    upsert?: UserMonthlyBalanceUpsertWithWhereUniqueWithoutUserInput | UserMonthlyBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMonthlyBalanceCreateManyUserInputEnvelope
    set?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    disconnect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    delete?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    connect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    update?: UserMonthlyBalanceUpdateWithWhereUniqueWithoutUserInput | UserMonthlyBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMonthlyBalanceUpdateManyWithWhereWithoutUserInput | UserMonthlyBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMonthlyBalanceScalarWhereInput | UserMonthlyBalanceScalarWhereInput[]
  }

  export type UserPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput> | UserPlanCreateWithoutUserInput[] | UserPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutUserInput | UserPlanCreateOrConnectWithoutUserInput[]
    upsert?: UserPlanUpsertWithWhereUniqueWithoutUserInput | UserPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPlanCreateManyUserInputEnvelope
    set?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    disconnect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    delete?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    update?: UserPlanUpdateWithWhereUniqueWithoutUserInput | UserPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPlanUpdateManyWithWhereWithoutUserInput | UserPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
  }

  export type UserPlusAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput> | UserPlusAccessCreateWithoutUserInput[] | UserPlusAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlusAccessCreateOrConnectWithoutUserInput | UserPlusAccessCreateOrConnectWithoutUserInput[]
    upsert?: UserPlusAccessUpsertWithWhereUniqueWithoutUserInput | UserPlusAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPlusAccessCreateManyUserInputEnvelope
    set?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    disconnect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    delete?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    connect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    update?: UserPlusAccessUpdateWithWhereUniqueWithoutUserInput | UserPlusAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPlusAccessUpdateManyWithWhereWithoutUserInput | UserPlusAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPlusAccessScalarWhereInput | UserPlusAccessScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput> | CharacterCreateWithoutCreatorInput[] | CharacterUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCreatorInput | CharacterCreateOrConnectWithoutCreatorInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutCreatorInput | CharacterUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CharacterCreateManyCreatorInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutCreatorInput | CharacterUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutCreatorInput | CharacterUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutAuthorInput | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutAuthorInput | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutAuthorInput | StoryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type AttireUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput> | AttireCreateWithoutOwnerInput[] | AttireUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutOwnerInput | AttireCreateOrConnectWithoutOwnerInput[]
    upsert?: AttireUpsertWithWhereUniqueWithoutOwnerInput | AttireUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AttireCreateManyOwnerInputEnvelope
    set?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    disconnect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    delete?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    update?: AttireUpdateWithWhereUniqueWithoutOwnerInput | AttireUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AttireUpdateManyWithWhereWithoutOwnerInput | AttireUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AttireScalarWhereInput | AttireScalarWhereInput[]
  }

  export type AssistantUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput> | AssistantCreateWithoutCreatorInput[] | AssistantUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutCreatorInput | AssistantCreateOrConnectWithoutCreatorInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutCreatorInput | AssistantUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AssistantCreateManyCreatorInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutCreatorInput | AssistantUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutCreatorInput | AssistantUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput> | ConversationCreateWithoutOwnerInput[] | ConversationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOwnerInput | ConversationCreateOrConnectWithoutOwnerInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutOwnerInput | ConversationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ConversationCreateManyOwnerInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutOwnerInput | ConversationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutOwnerInput | ConversationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput = {
    create?: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput> | ConversationCreateWithoutConversationOwnerInput[] | ConversationUncheckedCreateWithoutConversationOwnerInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationOwnerInput | ConversationCreateOrConnectWithoutConversationOwnerInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutConversationOwnerInput | ConversationUpsertWithWhereUniqueWithoutConversationOwnerInput[]
    createMany?: ConversationCreateManyConversationOwnerInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutConversationOwnerInput | ConversationUpdateWithWhereUniqueWithoutConversationOwnerInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutConversationOwnerInput | ConversationUpdateManyWithWhereWithoutConversationOwnerInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput> | UserConversationMembershipCreateWithoutUserInput[] | UserConversationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutUserInput | UserConversationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutUserInput | UserConversationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConversationMembershipCreateManyUserInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutUserInput | UserConversationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutUserInput | UserConversationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput> | UserConversationMembershipCreateWithoutInviterInput[] | UserConversationMembershipUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutInviterInput | UserConversationMembershipCreateOrConnectWithoutInviterInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutInviterInput | UserConversationMembershipUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: UserConversationMembershipCreateManyInviterInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutInviterInput | UserConversationMembershipUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutInviterInput | UserConversationMembershipUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput> | FavoriteCharacterCreateWithoutUserInput[] | FavoriteCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCharacterCreateOrConnectWithoutUserInput | FavoriteCharacterCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteCharacterUpsertWithWhereUniqueWithoutUserInput | FavoriteCharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCharacterCreateManyUserInputEnvelope
    set?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    disconnect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    delete?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    connect?: FavoriteCharacterWhereUniqueInput | FavoriteCharacterWhereUniqueInput[]
    update?: FavoriteCharacterUpdateWithWhereUniqueWithoutUserInput | FavoriteCharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteCharacterUpdateManyWithWhereWithoutUserInput | FavoriteCharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteCharacterScalarWhereInput | FavoriteCharacterScalarWhereInput[]
  }

  export type CreditTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CreditTransactionUpsertWithWhereUniqueWithoutUserInput | CreditTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    set?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    disconnect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    delete?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    update?: CreditTransactionUpdateWithWhereUniqueWithoutUserInput | CreditTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditTransactionUpdateManyWithWhereWithoutUserInput | CreditTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
  }

  export type UsageLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput> | UserMonthlyBalanceCreateWithoutUserInput[] | UserMonthlyBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyBalanceCreateOrConnectWithoutUserInput | UserMonthlyBalanceCreateOrConnectWithoutUserInput[]
    upsert?: UserMonthlyBalanceUpsertWithWhereUniqueWithoutUserInput | UserMonthlyBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMonthlyBalanceCreateManyUserInputEnvelope
    set?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    disconnect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    delete?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    connect?: UserMonthlyBalanceWhereUniqueInput | UserMonthlyBalanceWhereUniqueInput[]
    update?: UserMonthlyBalanceUpdateWithWhereUniqueWithoutUserInput | UserMonthlyBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMonthlyBalanceUpdateManyWithWhereWithoutUserInput | UserMonthlyBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMonthlyBalanceScalarWhereInput | UserMonthlyBalanceScalarWhereInput[]
  }

  export type UserPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput> | UserPlanCreateWithoutUserInput[] | UserPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutUserInput | UserPlanCreateOrConnectWithoutUserInput[]
    upsert?: UserPlanUpsertWithWhereUniqueWithoutUserInput | UserPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPlanCreateManyUserInputEnvelope
    set?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    disconnect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    delete?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    update?: UserPlanUpdateWithWhereUniqueWithoutUserInput | UserPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPlanUpdateManyWithWhereWithoutUserInput | UserPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
  }

  export type UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput> | UserPlusAccessCreateWithoutUserInput[] | UserPlusAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPlusAccessCreateOrConnectWithoutUserInput | UserPlusAccessCreateOrConnectWithoutUserInput[]
    upsert?: UserPlusAccessUpsertWithWhereUniqueWithoutUserInput | UserPlusAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPlusAccessCreateManyUserInputEnvelope
    set?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    disconnect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    delete?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    connect?: UserPlusAccessWhereUniqueInput | UserPlusAccessWhereUniqueInput[]
    update?: UserPlusAccessUpdateWithWhereUniqueWithoutUserInput | UserPlusAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPlusAccessUpdateManyWithWhereWithoutUserInput | UserPlusAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPlusAccessScalarWhereInput | UserPlusAccessScalarWhereInput[]
  }

  export type ContentClassificationCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type ContentClassificationUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LoraCreatetagsInput = {
    set: string[]
  }

  export type LoraCreatetrainedWordsInput = {
    set: string[]
  }

  export type LoraCreateimageUrlsInput = {
    set: string[]
  }

  export type CharacterCreateNestedManyWithoutLoraInput = {
    create?: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput> | CharacterCreateWithoutLoraInput[] | CharacterUncheckedCreateWithoutLoraInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutLoraInput | CharacterCreateOrConnectWithoutLoraInput[]
    createMany?: CharacterCreateManyLoraInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutLoraInput = {
    create?: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput> | CharacterCreateWithoutLoraInput[] | CharacterUncheckedCreateWithoutLoraInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutLoraInput | CharacterCreateOrConnectWithoutLoraInput[]
    createMany?: CharacterCreateManyLoraInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LoraUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LoraUpdatetrainedWordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LoraUpdateimageUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateManyWithoutLoraNestedInput = {
    create?: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput> | CharacterCreateWithoutLoraInput[] | CharacterUncheckedCreateWithoutLoraInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutLoraInput | CharacterCreateOrConnectWithoutLoraInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutLoraInput | CharacterUpsertWithWhereUniqueWithoutLoraInput[]
    createMany?: CharacterCreateManyLoraInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutLoraInput | CharacterUpdateWithWhereUniqueWithoutLoraInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutLoraInput | CharacterUpdateManyWithWhereWithoutLoraInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutLoraNestedInput = {
    create?: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput> | CharacterCreateWithoutLoraInput[] | CharacterUncheckedCreateWithoutLoraInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutLoraInput | CharacterCreateOrConnectWithoutLoraInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutLoraInput | CharacterUpsertWithWhereUniqueWithoutLoraInput[]
    createMany?: CharacterCreateManyLoraInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutLoraInput | CharacterUpdateWithWhereUniqueWithoutLoraInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutLoraInput | CharacterUpdateManyWithWhereWithoutLoraInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type AttireCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type UserCreateNestedOneWithoutCreatedAttiresInput = {
    create?: XOR<UserCreateWithoutCreatedAttiresInput, UserUncheckedCreateWithoutCreatedAttiresInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAttiresInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterCreateNestedManyWithoutMainAttireInput = {
    create?: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput> | CharacterCreateWithoutMainAttireInput[] | CharacterUncheckedCreateWithoutMainAttireInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutMainAttireInput | CharacterCreateOrConnectWithoutMainAttireInput[]
    createMany?: CharacterCreateManyMainAttireInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterCreateNestedManyWithoutAttiresInput = {
    create?: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput> | CharacterCreateWithoutAttiresInput[] | CharacterUncheckedCreateWithoutAttiresInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAttiresInput | CharacterCreateOrConnectWithoutAttiresInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutMainAttireInput = {
    create?: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput> | CharacterCreateWithoutMainAttireInput[] | CharacterUncheckedCreateWithoutMainAttireInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutMainAttireInput | CharacterCreateOrConnectWithoutMainAttireInput[]
    createMany?: CharacterCreateManyMainAttireInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutAttiresInput = {
    create?: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput> | CharacterCreateWithoutAttiresInput[] | CharacterUncheckedCreateWithoutAttiresInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAttiresInput | CharacterCreateOrConnectWithoutAttiresInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type AttireUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedAttiresNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAttiresInput, UserUncheckedCreateWithoutCreatedAttiresInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAttiresInput
    upsert?: UserUpsertWithoutCreatedAttiresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAttiresInput, UserUpdateWithoutCreatedAttiresInput>, UserUncheckedUpdateWithoutCreatedAttiresInput>
  }

  export type CharacterUpdateManyWithoutMainAttireNestedInput = {
    create?: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput> | CharacterCreateWithoutMainAttireInput[] | CharacterUncheckedCreateWithoutMainAttireInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutMainAttireInput | CharacterCreateOrConnectWithoutMainAttireInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutMainAttireInput | CharacterUpsertWithWhereUniqueWithoutMainAttireInput[]
    createMany?: CharacterCreateManyMainAttireInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutMainAttireInput | CharacterUpdateWithWhereUniqueWithoutMainAttireInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutMainAttireInput | CharacterUpdateManyWithWhereWithoutMainAttireInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUpdateManyWithoutAttiresNestedInput = {
    create?: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput> | CharacterCreateWithoutAttiresInput[] | CharacterUncheckedCreateWithoutAttiresInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAttiresInput | CharacterCreateOrConnectWithoutAttiresInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAttiresInput | CharacterUpsertWithWhereUniqueWithoutAttiresInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAttiresInput | CharacterUpdateWithWhereUniqueWithoutAttiresInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAttiresInput | CharacterUpdateManyWithWhereWithoutAttiresInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutMainAttireNestedInput = {
    create?: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput> | CharacterCreateWithoutMainAttireInput[] | CharacterUncheckedCreateWithoutMainAttireInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutMainAttireInput | CharacterCreateOrConnectWithoutMainAttireInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutMainAttireInput | CharacterUpsertWithWhereUniqueWithoutMainAttireInput[]
    createMany?: CharacterCreateManyMainAttireInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutMainAttireInput | CharacterUpdateWithWhereUniqueWithoutMainAttireInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutMainAttireInput | CharacterUpdateManyWithWhereWithoutMainAttireInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutAttiresNestedInput = {
    create?: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput> | CharacterCreateWithoutAttiresInput[] | CharacterUncheckedCreateWithoutAttiresInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAttiresInput | CharacterCreateOrConnectWithoutAttiresInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAttiresInput | CharacterUpsertWithWhereUniqueWithoutAttiresInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAttiresInput | CharacterUpdateWithWhereUniqueWithoutAttiresInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAttiresInput | CharacterUpdateManyWithWhereWithoutAttiresInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type TagCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type CharacterCreateNestedManyWithoutTagsInput = {
    create?: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput> | CharacterCreateWithoutTagsInput[] | CharacterUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTagsInput | CharacterCreateOrConnectWithoutTagsInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StoryCreateNestedManyWithoutTagsInput = {
    create?: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput> | StoryCreateWithoutTagsInput[] | StoryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutTagsInput | StoryCreateOrConnectWithoutTagsInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput> | CharacterCreateWithoutTagsInput[] | CharacterUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTagsInput | CharacterCreateOrConnectWithoutTagsInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput> | StoryCreateWithoutTagsInput[] | StoryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutTagsInput | StoryCreateOrConnectWithoutTagsInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type EnumTagTypeFieldUpdateOperationsInput = {
    set?: $Enums.TagType
  }

  export type TagUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type CharacterUpdateManyWithoutTagsNestedInput = {
    create?: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput> | CharacterCreateWithoutTagsInput[] | CharacterUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTagsInput | CharacterCreateOrConnectWithoutTagsInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutTagsInput | CharacterUpsertWithWhereUniqueWithoutTagsInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutTagsInput | CharacterUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutTagsInput | CharacterUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type StoryUpdateManyWithoutTagsNestedInput = {
    create?: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput> | StoryCreateWithoutTagsInput[] | StoryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutTagsInput | StoryCreateOrConnectWithoutTagsInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutTagsInput | StoryUpsertWithWhereUniqueWithoutTagsInput[]
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutTagsInput | StoryUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutTagsInput | StoryUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput> | CharacterCreateWithoutTagsInput[] | CharacterUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTagsInput | CharacterCreateOrConnectWithoutTagsInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutTagsInput | CharacterUpsertWithWhereUniqueWithoutTagsInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutTagsInput | CharacterUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutTagsInput | CharacterUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput> | StoryCreateWithoutTagsInput[] | StoryUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutTagsInput | StoryCreateOrConnectWithoutTagsInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutTagsInput | StoryUpsertWithWhereUniqueWithoutTagsInput[]
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutTagsInput | StoryUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutTagsInput | StoryUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type CharacterCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type UserCreateNestedOneWithoutCreatedCharactersInput = {
    create?: XOR<UserCreateWithoutCreatedCharactersInput, UserUncheckedCreateWithoutCreatedCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type LoraCreateNestedOneWithoutCharactersInput = {
    create?: XOR<LoraCreateWithoutCharactersInput, LoraUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: LoraCreateOrConnectWithoutCharactersInput
    connect?: LoraWhereUniqueInput
  }

  export type AttireCreateNestedOneWithoutCharactersUsingAsMainInput = {
    create?: XOR<AttireCreateWithoutCharactersUsingAsMainInput, AttireUncheckedCreateWithoutCharactersUsingAsMainInput>
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersUsingAsMainInput
    connect?: AttireWhereUniqueInput
  }

  export type StoryCreateNestedManyWithoutCharactersInput = {
    create?: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput> | StoryCreateWithoutCharactersInput[] | StoryUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutCharactersInput | StoryCreateOrConnectWithoutCharactersInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type AttireCreateNestedManyWithoutCharactersInput = {
    create?: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput> | AttireCreateWithoutCharactersInput[] | AttireUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersInput | AttireCreateOrConnectWithoutCharactersInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutCharactersInput = {
    create?: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput> | TagCreateWithoutCharactersInput[] | TagUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCharactersInput | TagCreateOrConnectWithoutCharactersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CharacterStickerCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput> | CharacterStickerCreateWithoutCharacterInput[] | CharacterStickerUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterStickerCreateOrConnectWithoutCharacterInput | CharacterStickerCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterStickerCreateManyCharacterInputEnvelope
    connect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
  }

  export type CharacterImageCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput> | CharacterImageCreateWithoutCharacterInput[] | CharacterImageUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterImageCreateOrConnectWithoutCharacterInput | CharacterImageCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterImageCreateManyCharacterInputEnvelope
    connect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
  }

  export type AssistantCreateNestedManyWithoutDefaultCharacterInput = {
    create?: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput> | AssistantCreateWithoutDefaultCharacterInput[] | AssistantUncheckedCreateWithoutDefaultCharacterInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutDefaultCharacterInput | AssistantCreateOrConnectWithoutDefaultCharacterInput[]
    createMany?: AssistantCreateManyDefaultCharacterInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutActingCharacterInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput> | ConversationParticipantCreateWithoutActingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutActingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingCharacterInput | ConversationParticipantCreateOrConnectWithoutActingCharacterInput[]
    createMany?: ConversationParticipantCreateManyActingCharacterInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput = {
    create?: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput> | ConversationParticipantCreateWithoutRepresentingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput | ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput[]
    createMany?: ConversationParticipantCreateManyRepresentingCharacterInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput> | StoryCreateWithoutCharactersInput[] | StoryUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutCharactersInput | StoryCreateOrConnectWithoutCharactersInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type AttireUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput> | AttireCreateWithoutCharactersInput[] | AttireUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersInput | AttireCreateOrConnectWithoutCharactersInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput> | TagCreateWithoutCharactersInput[] | TagUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCharactersInput | TagCreateOrConnectWithoutCharactersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput> | CharacterStickerCreateWithoutCharacterInput[] | CharacterStickerUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterStickerCreateOrConnectWithoutCharacterInput | CharacterStickerCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterStickerCreateManyCharacterInputEnvelope
    connect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
  }

  export type CharacterImageUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput> | CharacterImageCreateWithoutCharacterInput[] | CharacterImageUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterImageCreateOrConnectWithoutCharacterInput | CharacterImageCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterImageCreateManyCharacterInputEnvelope
    connect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
  }

  export type AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput = {
    create?: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput> | AssistantCreateWithoutDefaultCharacterInput[] | AssistantUncheckedCreateWithoutDefaultCharacterInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutDefaultCharacterInput | AssistantCreateOrConnectWithoutDefaultCharacterInput[]
    createMany?: AssistantCreateManyDefaultCharacterInputEnvelope
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput> | ConversationParticipantCreateWithoutActingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutActingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingCharacterInput | ConversationParticipantCreateOrConnectWithoutActingCharacterInput[]
    createMany?: ConversationParticipantCreateManyActingCharacterInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput = {
    create?: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput> | ConversationParticipantCreateWithoutRepresentingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput | ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput[]
    createMany?: ConversationParticipantCreateManyRepresentingCharacterInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type NullableEnumVisualStyleFieldUpdateOperationsInput = {
    set?: $Enums.VisualStyle | null
  }

  export type CharacterUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type UserUpdateOneRequiredWithoutCreatedCharactersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCharactersInput, UserUncheckedCreateWithoutCreatedCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCharactersInput
    upsert?: UserUpsertWithoutCreatedCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCharactersInput, UserUpdateWithoutCreatedCharactersInput>, UserUncheckedUpdateWithoutCreatedCharactersInput>
  }

  export type LoraUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<LoraCreateWithoutCharactersInput, LoraUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: LoraCreateOrConnectWithoutCharactersInput
    upsert?: LoraUpsertWithoutCharactersInput
    disconnect?: LoraWhereInput | boolean
    delete?: LoraWhereInput | boolean
    connect?: LoraWhereUniqueInput
    update?: XOR<XOR<LoraUpdateToOneWithWhereWithoutCharactersInput, LoraUpdateWithoutCharactersInput>, LoraUncheckedUpdateWithoutCharactersInput>
  }

  export type AttireUpdateOneWithoutCharactersUsingAsMainNestedInput = {
    create?: XOR<AttireCreateWithoutCharactersUsingAsMainInput, AttireUncheckedCreateWithoutCharactersUsingAsMainInput>
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersUsingAsMainInput
    upsert?: AttireUpsertWithoutCharactersUsingAsMainInput
    disconnect?: AttireWhereInput | boolean
    delete?: AttireWhereInput | boolean
    connect?: AttireWhereUniqueInput
    update?: XOR<XOR<AttireUpdateToOneWithWhereWithoutCharactersUsingAsMainInput, AttireUpdateWithoutCharactersUsingAsMainInput>, AttireUncheckedUpdateWithoutCharactersUsingAsMainInput>
  }

  export type StoryUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput> | StoryCreateWithoutCharactersInput[] | StoryUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutCharactersInput | StoryCreateOrConnectWithoutCharactersInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutCharactersInput | StoryUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutCharactersInput | StoryUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutCharactersInput | StoryUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type AttireUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput> | AttireCreateWithoutCharactersInput[] | AttireUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersInput | AttireCreateOrConnectWithoutCharactersInput[]
    upsert?: AttireUpsertWithWhereUniqueWithoutCharactersInput | AttireUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    disconnect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    delete?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    update?: AttireUpdateWithWhereUniqueWithoutCharactersInput | AttireUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: AttireUpdateManyWithWhereWithoutCharactersInput | AttireUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: AttireScalarWhereInput | AttireScalarWhereInput[]
  }

  export type TagUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput> | TagCreateWithoutCharactersInput[] | TagUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCharactersInput | TagCreateOrConnectWithoutCharactersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCharactersInput | TagUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCharactersInput | TagUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCharactersInput | TagUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CharacterStickerUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput> | CharacterStickerCreateWithoutCharacterInput[] | CharacterStickerUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterStickerCreateOrConnectWithoutCharacterInput | CharacterStickerCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterStickerUpsertWithWhereUniqueWithoutCharacterInput | CharacterStickerUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterStickerCreateManyCharacterInputEnvelope
    set?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    disconnect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    delete?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    connect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    update?: CharacterStickerUpdateWithWhereUniqueWithoutCharacterInput | CharacterStickerUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterStickerUpdateManyWithWhereWithoutCharacterInput | CharacterStickerUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterStickerScalarWhereInput | CharacterStickerScalarWhereInput[]
  }

  export type CharacterImageUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput> | CharacterImageCreateWithoutCharacterInput[] | CharacterImageUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterImageCreateOrConnectWithoutCharacterInput | CharacterImageCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterImageUpsertWithWhereUniqueWithoutCharacterInput | CharacterImageUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterImageCreateManyCharacterInputEnvelope
    set?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    disconnect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    delete?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    connect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    update?: CharacterImageUpdateWithWhereUniqueWithoutCharacterInput | CharacterImageUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterImageUpdateManyWithWhereWithoutCharacterInput | CharacterImageUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterImageScalarWhereInput | CharacterImageScalarWhereInput[]
  }

  export type AssistantUpdateManyWithoutDefaultCharacterNestedInput = {
    create?: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput> | AssistantCreateWithoutDefaultCharacterInput[] | AssistantUncheckedCreateWithoutDefaultCharacterInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutDefaultCharacterInput | AssistantCreateOrConnectWithoutDefaultCharacterInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutDefaultCharacterInput | AssistantUpsertWithWhereUniqueWithoutDefaultCharacterInput[]
    createMany?: AssistantCreateManyDefaultCharacterInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutDefaultCharacterInput | AssistantUpdateWithWhereUniqueWithoutDefaultCharacterInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutDefaultCharacterInput | AssistantUpdateManyWithWhereWithoutDefaultCharacterInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutActingCharacterNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput> | ConversationParticipantCreateWithoutActingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutActingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingCharacterInput | ConversationParticipantCreateOrConnectWithoutActingCharacterInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutActingCharacterInput | ConversationParticipantUpsertWithWhereUniqueWithoutActingCharacterInput[]
    createMany?: ConversationParticipantCreateManyActingCharacterInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutActingCharacterInput | ConversationParticipantUpdateWithWhereUniqueWithoutActingCharacterInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutActingCharacterInput | ConversationParticipantUpdateManyWithWhereWithoutActingCharacterInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput> | ConversationParticipantCreateWithoutRepresentingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput | ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutRepresentingCharacterInput | ConversationParticipantUpsertWithWhereUniqueWithoutRepresentingCharacterInput[]
    createMany?: ConversationParticipantCreateManyRepresentingCharacterInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutRepresentingCharacterInput | ConversationParticipantUpdateWithWhereUniqueWithoutRepresentingCharacterInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutRepresentingCharacterInput | ConversationParticipantUpdateManyWithWhereWithoutRepresentingCharacterInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput> | StoryCreateWithoutCharactersInput[] | StoryUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutCharactersInput | StoryCreateOrConnectWithoutCharactersInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutCharactersInput | StoryUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutCharactersInput | StoryUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutCharactersInput | StoryUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type AttireUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput> | AttireCreateWithoutCharactersInput[] | AttireUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: AttireCreateOrConnectWithoutCharactersInput | AttireCreateOrConnectWithoutCharactersInput[]
    upsert?: AttireUpsertWithWhereUniqueWithoutCharactersInput | AttireUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    disconnect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    delete?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    connect?: AttireWhereUniqueInput | AttireWhereUniqueInput[]
    update?: AttireUpdateWithWhereUniqueWithoutCharactersInput | AttireUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: AttireUpdateManyWithWhereWithoutCharactersInput | AttireUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: AttireScalarWhereInput | AttireScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput> | TagCreateWithoutCharactersInput[] | TagUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCharactersInput | TagCreateOrConnectWithoutCharactersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCharactersInput | TagUpsertWithWhereUniqueWithoutCharactersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCharactersInput | TagUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCharactersInput | TagUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput> | CharacterStickerCreateWithoutCharacterInput[] | CharacterStickerUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterStickerCreateOrConnectWithoutCharacterInput | CharacterStickerCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterStickerUpsertWithWhereUniqueWithoutCharacterInput | CharacterStickerUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterStickerCreateManyCharacterInputEnvelope
    set?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    disconnect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    delete?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    connect?: CharacterStickerWhereUniqueInput | CharacterStickerWhereUniqueInput[]
    update?: CharacterStickerUpdateWithWhereUniqueWithoutCharacterInput | CharacterStickerUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterStickerUpdateManyWithWhereWithoutCharacterInput | CharacterStickerUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterStickerScalarWhereInput | CharacterStickerScalarWhereInput[]
  }

  export type CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput> | CharacterImageCreateWithoutCharacterInput[] | CharacterImageUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterImageCreateOrConnectWithoutCharacterInput | CharacterImageCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterImageUpsertWithWhereUniqueWithoutCharacterInput | CharacterImageUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterImageCreateManyCharacterInputEnvelope
    set?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    disconnect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    delete?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    connect?: CharacterImageWhereUniqueInput | CharacterImageWhereUniqueInput[]
    update?: CharacterImageUpdateWithWhereUniqueWithoutCharacterInput | CharacterImageUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterImageUpdateManyWithWhereWithoutCharacterInput | CharacterImageUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterImageScalarWhereInput | CharacterImageScalarWhereInput[]
  }

  export type AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput = {
    create?: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput> | AssistantCreateWithoutDefaultCharacterInput[] | AssistantUncheckedCreateWithoutDefaultCharacterInput[]
    connectOrCreate?: AssistantCreateOrConnectWithoutDefaultCharacterInput | AssistantCreateOrConnectWithoutDefaultCharacterInput[]
    upsert?: AssistantUpsertWithWhereUniqueWithoutDefaultCharacterInput | AssistantUpsertWithWhereUniqueWithoutDefaultCharacterInput[]
    createMany?: AssistantCreateManyDefaultCharacterInputEnvelope
    set?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    disconnect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    delete?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    connect?: AssistantWhereUniqueInput | AssistantWhereUniqueInput[]
    update?: AssistantUpdateWithWhereUniqueWithoutDefaultCharacterInput | AssistantUpdateWithWhereUniqueWithoutDefaultCharacterInput[]
    updateMany?: AssistantUpdateManyWithWhereWithoutDefaultCharacterInput | AssistantUpdateManyWithWhereWithoutDefaultCharacterInput[]
    deleteMany?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput> | ConversationParticipantCreateWithoutActingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutActingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingCharacterInput | ConversationParticipantCreateOrConnectWithoutActingCharacterInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutActingCharacterInput | ConversationParticipantUpsertWithWhereUniqueWithoutActingCharacterInput[]
    createMany?: ConversationParticipantCreateManyActingCharacterInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutActingCharacterInput | ConversationParticipantUpdateWithWhereUniqueWithoutActingCharacterInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutActingCharacterInput | ConversationParticipantUpdateManyWithWhereWithoutActingCharacterInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput> | ConversationParticipantCreateWithoutRepresentingCharacterInput[] | ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput | ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutRepresentingCharacterInput | ConversationParticipantUpsertWithWhereUniqueWithoutRepresentingCharacterInput[]
    createMany?: ConversationParticipantCreateManyRepresentingCharacterInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutRepresentingCharacterInput | ConversationParticipantUpdateWithWhereUniqueWithoutRepresentingCharacterInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutRepresentingCharacterInput | ConversationParticipantUpdateManyWithWhereWithoutRepresentingCharacterInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutStickersInput = {
    create?: XOR<CharacterCreateWithoutStickersInput, CharacterUncheckedCreateWithoutStickersInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutStickersInput
    connect?: CharacterWhereUniqueInput
  }

  export type EnumStickerStatusFieldUpdateOperationsInput = {
    set?: $Enums.StickerStatus
  }

  export type CharacterUpdateOneRequiredWithoutStickersNestedInput = {
    create?: XOR<CharacterCreateWithoutStickersInput, CharacterUncheckedCreateWithoutStickersInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutStickersInput
    upsert?: CharacterUpsertWithoutStickersInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutStickersInput, CharacterUpdateWithoutStickersInput>, CharacterUncheckedUpdateWithoutStickersInput>
  }

  export type CharacterImageCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type CharacterCreateNestedOneWithoutImagesInput = {
    create?: XOR<CharacterCreateWithoutImagesInput, CharacterUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutImagesInput
    connect?: CharacterWhereUniqueInput
  }

  export type EnumImageTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImageType
  }

  export type CharacterImageUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type CharacterUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<CharacterCreateWithoutImagesInput, CharacterUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutImagesInput
    upsert?: CharacterUpsertWithoutImagesInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutImagesInput, CharacterUpdateWithoutImagesInput>, CharacterUncheckedUpdateWithoutImagesInput>
  }

  export type StoryCreatecontentTagsInput = {
    set: $Enums.ContentTag[]
  }

  export type UserCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterCreateNestedManyWithoutStoriesInput = {
    create?: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput> | CharacterCreateWithoutStoriesInput[] | CharacterUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStoriesInput | CharacterCreateOrConnectWithoutStoriesInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutStoriesInput = {
    create?: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput> | TagCreateWithoutStoriesInput[] | TagUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutStoriesInput | TagCreateOrConnectWithoutStoriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutStoryInput = {
    create?: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput> | ConversationCreateWithoutStoryInput[] | ConversationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutStoryInput | ConversationCreateOrConnectWithoutStoryInput[]
    createMany?: ConversationCreateManyStoryInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutStoriesInput = {
    create?: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput> | CharacterCreateWithoutStoriesInput[] | CharacterUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStoriesInput | CharacterCreateOrConnectWithoutStoriesInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutStoriesInput = {
    create?: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput> | TagCreateWithoutStoriesInput[] | TagUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutStoriesInput | TagCreateOrConnectWithoutStoriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput> | ConversationCreateWithoutStoryInput[] | ConversationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutStoryInput | ConversationCreateOrConnectWithoutStoryInput[]
    createMany?: ConversationCreateManyStoryInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type StoryUpdatecontentTagsInput = {
    set?: $Enums.ContentTag[]
    push?: $Enums.ContentTag | $Enums.ContentTag[]
  }

  export type UserUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    upsert?: UserUpsertWithoutStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoriesInput, UserUpdateWithoutStoriesInput>, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type CharacterUpdateManyWithoutStoriesNestedInput = {
    create?: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput> | CharacterCreateWithoutStoriesInput[] | CharacterUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStoriesInput | CharacterCreateOrConnectWithoutStoriesInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutStoriesInput | CharacterUpsertWithWhereUniqueWithoutStoriesInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutStoriesInput | CharacterUpdateWithWhereUniqueWithoutStoriesInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutStoriesInput | CharacterUpdateManyWithWhereWithoutStoriesInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type TagUpdateManyWithoutStoriesNestedInput = {
    create?: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput> | TagCreateWithoutStoriesInput[] | TagUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutStoriesInput | TagCreateOrConnectWithoutStoriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutStoriesInput | TagUpsertWithWhereUniqueWithoutStoriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutStoriesInput | TagUpdateWithWhereUniqueWithoutStoriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutStoriesInput | TagUpdateManyWithWhereWithoutStoriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutStoryNestedInput = {
    create?: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput> | ConversationCreateWithoutStoryInput[] | ConversationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutStoryInput | ConversationCreateOrConnectWithoutStoryInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutStoryInput | ConversationUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: ConversationCreateManyStoryInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutStoryInput | ConversationUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutStoryInput | ConversationUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutStoriesNestedInput = {
    create?: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput> | CharacterCreateWithoutStoriesInput[] | CharacterUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStoriesInput | CharacterCreateOrConnectWithoutStoriesInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutStoriesInput | CharacterUpsertWithWhereUniqueWithoutStoriesInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutStoriesInput | CharacterUpdateWithWhereUniqueWithoutStoriesInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutStoriesInput | CharacterUpdateManyWithWhereWithoutStoriesInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutStoriesNestedInput = {
    create?: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput> | TagCreateWithoutStoriesInput[] | TagUncheckedCreateWithoutStoriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutStoriesInput | TagCreateOrConnectWithoutStoriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutStoriesInput | TagUpsertWithWhereUniqueWithoutStoriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutStoriesInput | TagUpdateWithWhereUniqueWithoutStoriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutStoriesInput | TagUpdateManyWithWhereWithoutStoriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput> | ConversationCreateWithoutStoryInput[] | ConversationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutStoryInput | ConversationCreateOrConnectWithoutStoryInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutStoryInput | ConversationUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: ConversationCreateManyStoryInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutStoryInput | ConversationUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutStoryInput | ConversationUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutAssistantsUsingAsDefaultInput = {
    create?: XOR<CharacterCreateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedCreateWithoutAssistantsUsingAsDefaultInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutAssistantsUsingAsDefaultInput
    connect?: CharacterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<UserCreateWithoutAssistantsInput, UserUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssistantsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutActingAssistantInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput> | ConversationParticipantCreateWithoutActingAssistantInput[] | ConversationParticipantUncheckedCreateWithoutActingAssistantInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingAssistantInput | ConversationParticipantCreateOrConnectWithoutActingAssistantInput[]
    createMany?: ConversationParticipantCreateManyActingAssistantInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutActingAssistantInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput> | ConversationParticipantCreateWithoutActingAssistantInput[] | ConversationParticipantUncheckedCreateWithoutActingAssistantInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingAssistantInput | ConversationParticipantCreateOrConnectWithoutActingAssistantInput[]
    createMany?: ConversationParticipantCreateManyActingAssistantInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type CharacterUpdateOneWithoutAssistantsUsingAsDefaultNestedInput = {
    create?: XOR<CharacterCreateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedCreateWithoutAssistantsUsingAsDefaultInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutAssistantsUsingAsDefaultInput
    upsert?: CharacterUpsertWithoutAssistantsUsingAsDefaultInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutAssistantsUsingAsDefaultInput, CharacterUpdateWithoutAssistantsUsingAsDefaultInput>, CharacterUncheckedUpdateWithoutAssistantsUsingAsDefaultInput>
  }

  export type UserUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<UserCreateWithoutAssistantsInput, UserUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssistantsInput
    upsert?: UserUpsertWithoutAssistantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssistantsInput, UserUpdateWithoutAssistantsInput>, UserUncheckedUpdateWithoutAssistantsInput>
  }

  export type ConversationParticipantUpdateManyWithoutActingAssistantNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput> | ConversationParticipantCreateWithoutActingAssistantInput[] | ConversationParticipantUncheckedCreateWithoutActingAssistantInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingAssistantInput | ConversationParticipantCreateOrConnectWithoutActingAssistantInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutActingAssistantInput | ConversationParticipantUpsertWithWhereUniqueWithoutActingAssistantInput[]
    createMany?: ConversationParticipantCreateManyActingAssistantInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutActingAssistantInput | ConversationParticipantUpdateWithWhereUniqueWithoutActingAssistantInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutActingAssistantInput | ConversationParticipantUpdateManyWithWhereWithoutActingAssistantInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutActingAssistantNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput> | ConversationParticipantCreateWithoutActingAssistantInput[] | ConversationParticipantUncheckedCreateWithoutActingAssistantInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutActingAssistantInput | ConversationParticipantCreateOrConnectWithoutActingAssistantInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutActingAssistantInput | ConversationParticipantUpsertWithWhereUniqueWithoutActingAssistantInput[]
    createMany?: ConversationParticipantCreateManyActingAssistantInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutActingAssistantInput | ConversationParticipantUpdateWithWhereUniqueWithoutActingAssistantInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutActingAssistantInput | ConversationParticipantUpdateManyWithWhereWithoutActingAssistantInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type StoryCreateNestedOneWithoutConversationsInput = {
    create?: XOR<StoryCreateWithoutConversationsInput, StoryUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutConversationsInput
    connect?: StoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedConversationsInput = {
    create?: XOR<UserCreateWithoutOwnedConversationsInput, UserUncheckedCreateWithoutOwnedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemoryCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput> | ConversationMemoryCreateWithoutConversationInput[] | ConversationMemoryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemoryCreateOrConnectWithoutConversationInput | ConversationMemoryCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMemoryCreateManyConversationInputEnvelope
    connect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
  }

  export type UserConversationMembershipCreateNestedManyWithoutConversationInput = {
    create?: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput> | UserConversationMembershipCreateWithoutConversationInput[] | UserConversationMembershipUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutConversationInput | UserConversationMembershipCreateOrConnectWithoutConversationInput[]
    createMany?: UserConversationMembershipCreateManyConversationInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput> | ConversationMemoryCreateWithoutConversationInput[] | ConversationMemoryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemoryCreateOrConnectWithoutConversationInput | ConversationMemoryCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMemoryCreateManyConversationInputEnvelope
    connect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
  }

  export type UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput> | UserConversationMembershipCreateWithoutConversationInput[] | UserConversationMembershipUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutConversationInput | UserConversationMembershipCreateOrConnectWithoutConversationInput[]
    createMany?: UserConversationMembershipCreateManyConversationInputEnvelope
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
  }

  export type StoryUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<StoryCreateWithoutConversationsInput, StoryUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutConversationsInput
    upsert?: StoryUpsertWithoutConversationsInput
    disconnect?: StoryWhereInput | boolean
    delete?: StoryWhereInput | boolean
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutConversationsInput, StoryUpdateWithoutConversationsInput>, StoryUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneWithoutOwnedConversationsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedConversationsInput, UserUncheckedCreateWithoutOwnedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedConversationsInput
    upsert?: UserUpsertWithoutOwnedConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedConversationsInput, UserUpdateWithoutOwnedConversationsInput>, UserUncheckedUpdateWithoutOwnedConversationsInput>
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationMemoryUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput> | ConversationMemoryCreateWithoutConversationInput[] | ConversationMemoryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemoryCreateOrConnectWithoutConversationInput | ConversationMemoryCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMemoryUpsertWithWhereUniqueWithoutConversationInput | ConversationMemoryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMemoryCreateManyConversationInputEnvelope
    set?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    disconnect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    delete?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    connect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    update?: ConversationMemoryUpdateWithWhereUniqueWithoutConversationInput | ConversationMemoryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMemoryUpdateManyWithWhereWithoutConversationInput | ConversationMemoryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMemoryScalarWhereInput | ConversationMemoryScalarWhereInput[]
  }

  export type UserConversationMembershipUpdateManyWithoutConversationNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput> | UserConversationMembershipCreateWithoutConversationInput[] | UserConversationMembershipUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutConversationInput | UserConversationMembershipCreateOrConnectWithoutConversationInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutConversationInput | UserConversationMembershipUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: UserConversationMembershipCreateManyConversationInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutConversationInput | UserConversationMembershipUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutConversationInput | UserConversationMembershipUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput> | ConversationMemoryCreateWithoutConversationInput[] | ConversationMemoryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemoryCreateOrConnectWithoutConversationInput | ConversationMemoryCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMemoryUpsertWithWhereUniqueWithoutConversationInput | ConversationMemoryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMemoryCreateManyConversationInputEnvelope
    set?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    disconnect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    delete?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    connect?: ConversationMemoryWhereUniqueInput | ConversationMemoryWhereUniqueInput[]
    update?: ConversationMemoryUpdateWithWhereUniqueWithoutConversationInput | ConversationMemoryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMemoryUpdateManyWithWhereWithoutConversationInput | ConversationMemoryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMemoryScalarWhereInput | ConversationMemoryScalarWhereInput[]
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput> | UserConversationMembershipCreateWithoutConversationInput[] | UserConversationMembershipUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: UserConversationMembershipCreateOrConnectWithoutConversationInput | UserConversationMembershipCreateOrConnectWithoutConversationInput[]
    upsert?: UserConversationMembershipUpsertWithWhereUniqueWithoutConversationInput | UserConversationMembershipUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: UserConversationMembershipCreateManyConversationInputEnvelope
    set?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    disconnect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    delete?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    connect?: UserConversationMembershipWhereUniqueInput | UserConversationMembershipWhereUniqueInput[]
    update?: UserConversationMembershipUpdateWithWhereUniqueWithoutConversationInput | UserConversationMembershipUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: UserConversationMembershipUpdateManyWithWhereWithoutConversationInput | UserConversationMembershipUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMembersInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitesInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMembershipRoleFieldUpdateOperationsInput = {
    set?: $Enums.MembershipRole
  }

  export type ConversationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput
    upsert?: ConversationUpsertWithoutMembersInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMembersInput, ConversationUpdateWithoutMembersInput>, ConversationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneWithoutSentInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    upsert?: UserUpsertWithoutSentInvitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitesInput, UserUpdateWithoutSentInvitesInput>, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationParticipationsInput = {
    create?: XOR<UserCreateWithoutConversationParticipationsInput, UserUncheckedCreateWithoutConversationParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterCreateNestedOneWithoutActingParticipationsInput = {
    create?: XOR<CharacterCreateWithoutActingParticipationsInput, CharacterUncheckedCreateWithoutActingParticipationsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutActingParticipationsInput
    connect?: CharacterWhereUniqueInput
  }

  export type AssistantCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<AssistantCreateWithoutParticipationsInput, AssistantUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutParticipationsInput
    connect?: AssistantWhereUniqueInput
  }

  export type CharacterCreateNestedOneWithoutRepresentingParticipationsInput = {
    create?: XOR<CharacterCreateWithoutRepresentingParticipationsInput, CharacterUncheckedCreateWithoutRepresentingParticipationsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutRepresentingParticipationsInput
    connect?: CharacterWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneWithoutConversationParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationParticipationsInput, UserUncheckedCreateWithoutConversationParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationParticipationsInput
    upsert?: UserUpsertWithoutConversationParticipationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationParticipationsInput, UserUpdateWithoutConversationParticipationsInput>, UserUncheckedUpdateWithoutConversationParticipationsInput>
  }

  export type CharacterUpdateOneWithoutActingParticipationsNestedInput = {
    create?: XOR<CharacterCreateWithoutActingParticipationsInput, CharacterUncheckedCreateWithoutActingParticipationsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutActingParticipationsInput
    upsert?: CharacterUpsertWithoutActingParticipationsInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutActingParticipationsInput, CharacterUpdateWithoutActingParticipationsInput>, CharacterUncheckedUpdateWithoutActingParticipationsInput>
  }

  export type AssistantUpdateOneWithoutParticipationsNestedInput = {
    create?: XOR<AssistantCreateWithoutParticipationsInput, AssistantUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: AssistantCreateOrConnectWithoutParticipationsInput
    upsert?: AssistantUpsertWithoutParticipationsInput
    disconnect?: AssistantWhereInput | boolean
    delete?: AssistantWhereInput | boolean
    connect?: AssistantWhereUniqueInput
    update?: XOR<XOR<AssistantUpdateToOneWithWhereWithoutParticipationsInput, AssistantUpdateWithoutParticipationsInput>, AssistantUncheckedUpdateWithoutParticipationsInput>
  }

  export type CharacterUpdateOneWithoutRepresentingParticipationsNestedInput = {
    create?: XOR<CharacterCreateWithoutRepresentingParticipationsInput, CharacterUncheckedCreateWithoutRepresentingParticipationsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutRepresentingParticipationsInput
    upsert?: CharacterUpsertWithoutRepresentingParticipationsInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutRepresentingParticipationsInput, CharacterUpdateWithoutRepresentingParticipationsInput>, CharacterUncheckedUpdateWithoutRepresentingParticipationsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutFavoriteCharactersInput = {
    create?: XOR<UserCreateWithoutFavoriteCharactersInput, UserUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoriteCharactersNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteCharactersInput, UserUncheckedCreateWithoutFavoriteCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteCharactersInput
    upsert?: UserUpsertWithoutFavoriteCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteCharactersInput, UserUpdateWithoutFavoriteCharactersInput>, UserUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTranslationStatusFieldUpdateOperationsInput = {
    set?: $Enums.TranslationStatus
  }

  export type ConversationCreateNestedOneWithoutMemoriesInput = {
    create?: XOR<ConversationCreateWithoutMemoriesInput, ConversationUncheckedCreateWithoutMemoriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMemoriesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMemoriesNestedInput = {
    create?: XOR<ConversationCreateWithoutMemoriesInput, ConversationUncheckedCreateWithoutMemoriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMemoriesInput
    upsert?: ConversationUpsertWithoutMemoriesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMemoriesInput, ConversationUpdateWithoutMemoriesInput>, ConversationUncheckedUpdateWithoutMemoriesInput>
  }

  export type UserCreateNestedOneWithoutCreditTransactionsInput = {
    create?: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCreditTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreditTransactionType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreditTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditTransactionsInput
    upsert?: UserUpsertWithoutCreditTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditTransactionsInput, UserUpdateWithoutCreditTransactionsInput>, UserUncheckedUpdateWithoutCreditTransactionsInput>
  }

  export type UserPlanCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput> | UserPlanCreateWithoutPlanInput[] | UserPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutPlanInput | UserPlanCreateOrConnectWithoutPlanInput[]
    createMany?: UserPlanCreateManyPlanInputEnvelope
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
  }

  export type UserPlanUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput> | UserPlanCreateWithoutPlanInput[] | UserPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutPlanInput | UserPlanCreateOrConnectWithoutPlanInput[]
    createMany?: UserPlanCreateManyPlanInputEnvelope
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
  }

  export type EnumPlanTierFieldUpdateOperationsInput = {
    set?: $Enums.PlanTier
  }

  export type UserPlanUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput> | UserPlanCreateWithoutPlanInput[] | UserPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutPlanInput | UserPlanCreateOrConnectWithoutPlanInput[]
    upsert?: UserPlanUpsertWithWhereUniqueWithoutPlanInput | UserPlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserPlanCreateManyPlanInputEnvelope
    set?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    disconnect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    delete?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    update?: UserPlanUpdateWithWhereUniqueWithoutPlanInput | UserPlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserPlanUpdateManyWithWhereWithoutPlanInput | UserPlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
  }

  export type UserPlanUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput> | UserPlanCreateWithoutPlanInput[] | UserPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserPlanCreateOrConnectWithoutPlanInput | UserPlanCreateOrConnectWithoutPlanInput[]
    upsert?: UserPlanUpsertWithWhereUniqueWithoutPlanInput | UserPlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserPlanCreateManyPlanInputEnvelope
    set?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    disconnect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    delete?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    connect?: UserPlanWhereUniqueInput | UserPlanWhereUniqueInput[]
    update?: UserPlanUpdateWithWhereUniqueWithoutPlanInput | UserPlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserPlanUpdateManyWithWhereWithoutPlanInput | UserPlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    upsert?: UserUpsertWithoutUsageLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageLogsInput, UserUpdateWithoutUsageLogsInput>, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserCreateNestedOneWithoutMonthlyBalancesInput = {
    create?: XOR<UserCreateWithoutMonthlyBalancesInput, UserUncheckedCreateWithoutMonthlyBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlyBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMonthlyBalancesNestedInput = {
    create?: XOR<UserCreateWithoutMonthlyBalancesInput, UserUncheckedCreateWithoutMonthlyBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlyBalancesInput
    upsert?: UserUpsertWithoutMonthlyBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMonthlyBalancesInput, UserUpdateWithoutMonthlyBalancesInput>, UserUncheckedUpdateWithoutMonthlyBalancesInput>
  }

  export type UserCreateNestedOneWithoutUserPlansInput = {
    create?: XOR<UserCreateWithoutUserPlansInput, UserUncheckedCreateWithoutUserPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPlansInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutUserPlansInput = {
    create?: XOR<PlanCreateWithoutUserPlansInput, PlanUncheckedCreateWithoutUserPlansInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUserPlansInput
    connect?: PlanWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutUserPlansNestedInput = {
    create?: XOR<UserCreateWithoutUserPlansInput, UserUncheckedCreateWithoutUserPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPlansInput
    upsert?: UserUpsertWithoutUserPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPlansInput, UserUpdateWithoutUserPlansInput>, UserUncheckedUpdateWithoutUserPlansInput>
  }

  export type PlanUpdateOneRequiredWithoutUserPlansNestedInput = {
    create?: XOR<PlanCreateWithoutUserPlansInput, PlanUncheckedCreateWithoutUserPlansInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUserPlansInput
    upsert?: PlanUpsertWithoutUserPlansInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutUserPlansInput, PlanUpdateWithoutUserPlansInput>, PlanUncheckedUpdateWithoutUserPlansInput>
  }

  export type UserCreateNestedOneWithoutPlusAccessGrantsInput = {
    create?: XOR<UserCreateWithoutPlusAccessGrantsInput, UserUncheckedCreateWithoutPlusAccessGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlusAccessGrantsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlusAccessGrantsNestedInput = {
    create?: XOR<UserCreateWithoutPlusAccessGrantsInput, UserUncheckedCreateWithoutPlusAccessGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlusAccessGrantsInput
    upsert?: UserUpsertWithoutPlusAccessGrantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlusAccessGrantsInput, UserUpdateWithoutPlusAccessGrantsInput>, UserUncheckedUpdateWithoutPlusAccessGrantsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAvatarSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarSource | EnumAvatarSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarSourceFilter<$PrismaModel> | $Enums.AvatarSource
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAvatarSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarSource | EnumAvatarSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarSource[] | ListEnumAvatarSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarSourceWithAggregatesFilter<$PrismaModel> | $Enums.AvatarSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvatarSourceFilter<$PrismaModel>
    _max?: NestedEnumAvatarSourceFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type NestedEnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisualStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VisualStyle | EnumVisualStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisualStyleNullableFilter<$PrismaModel> | $Enums.VisualStyle | null
  }

  export type NestedEnumVisualStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisualStyle | EnumVisualStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisualStyle[] | ListEnumVisualStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisualStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.VisualStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVisualStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumVisualStyleNullableFilter<$PrismaModel>
  }

  export type NestedEnumStickerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StickerStatus | EnumStickerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStickerStatusFilter<$PrismaModel> | $Enums.StickerStatus
  }

  export type NestedEnumStickerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickerStatus | EnumStickerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickerStatus[] | ListEnumStickerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStickerStatusWithAggregatesFilter<$PrismaModel> | $Enums.StickerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickerStatusFilter<$PrismaModel>
    _max?: NestedEnumStickerStatusFilter<$PrismaModel>
  }

  export type NestedEnumImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeFilter<$PrismaModel> | $Enums.ImageType
  }

  export type NestedEnumImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageType | EnumImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageType[] | ListEnumImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageTypeFilter<$PrismaModel>
    _max?: NestedEnumImageTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleFilter<$PrismaModel> | $Enums.MembershipRole
  }

  export type NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.MembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumMembershipRoleFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumTranslationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusFilter<$PrismaModel> | $Enums.TranslationStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranslationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationStatusFilter<$PrismaModel>
    _max?: NestedEnumTranslationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCreditTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeFilter<$PrismaModel> | $Enums.CreditTransactionType
  }

  export type NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreditTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPlanTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierFilter<$PrismaModel> | $Enums.PlanTier
  }

  export type NestedEnumPlanTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanTier | EnumPlanTierFieldRefInput<$PrismaModel>
    in?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanTier[] | ListEnumPlanTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTierWithAggregatesFilter<$PrismaModel> | $Enums.PlanTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTierFilter<$PrismaModel>
    _max?: NestedEnumPlanTierFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type CharacterCreateWithoutCreatorInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCreatorInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutCreatorInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput>
  }

  export type CharacterCreateManyCreatorInputEnvelope = {
    data: CharacterCreateManyCreatorInput | CharacterCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type StoryCreateWithoutAuthorInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutStoriesInput
    tags?: TagCreateNestedManyWithoutStoriesInput
    conversations?: ConversationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutStoriesInput
    tags?: TagUncheckedCreateNestedManyWithoutStoriesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput>
  }

  export type StoryCreateManyAuthorInputEnvelope = {
    data: StoryCreateManyAuthorInput | StoryCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AttireCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    charactersUsingAsMain?: CharacterCreateNestedManyWithoutMainAttireInput
    characters?: CharacterCreateNestedManyWithoutAttiresInput
  }

  export type AttireUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    charactersUsingAsMain?: CharacterUncheckedCreateNestedManyWithoutMainAttireInput
    characters?: CharacterUncheckedCreateNestedManyWithoutAttiresInput
  }

  export type AttireCreateOrConnectWithoutOwnerInput = {
    where: AttireWhereUniqueInput
    create: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput>
  }

  export type AttireCreateManyOwnerInputEnvelope = {
    data: AttireCreateManyOwnerInput | AttireCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type AssistantCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultCharacter?: CharacterCreateNestedOneWithoutAssistantsUsingAsDefaultInput
    participations?: ConversationParticipantCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    defaultCharacterId?: string | null
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantCreateOrConnectWithoutCreatorInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput>
  }

  export type AssistantCreateManyCreatorInputEnvelope = {
    data: AssistantCreateManyCreatorInput | AssistantCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutOwnerInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput>
  }

  export type ConversationCreateManyOwnerInputEnvelope = {
    data: ConversationCreateManyOwnerInput | ConversationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    actingCharacter?: CharacterCreateNestedOneWithoutActingParticipationsInput
    actingAssistant?: AssistantCreateNestedOneWithoutParticipationsInput
    representingCharacter?: CharacterCreateNestedOneWithoutRepresentingParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutConversationOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutConversationOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutConversationOwnerInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput>
  }

  export type ConversationCreateManyConversationOwnerInputEnvelope = {
    data: ConversationCreateManyConversationOwnerInput | ConversationCreateManyConversationOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserConversationMembershipCreateWithoutUserInput = {
    id?: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
    conversation: ConversationCreateNestedOneWithoutMembersInput
    inviter?: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type UserConversationMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type UserConversationMembershipCreateOrConnectWithoutUserInput = {
    where: UserConversationMembershipWhereUniqueInput
    create: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput>
  }

  export type UserConversationMembershipCreateManyUserInputEnvelope = {
    data: UserConversationMembershipCreateManyUserInput | UserConversationMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserConversationMembershipCreateWithoutInviterInput = {
    id?: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
    conversation: ConversationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type UserConversationMembershipUncheckedCreateWithoutInviterInput = {
    id?: string
    conversationId: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type UserConversationMembershipCreateOrConnectWithoutInviterInput = {
    where: UserConversationMembershipWhereUniqueInput
    create: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput>
  }

  export type UserConversationMembershipCreateManyInviterInputEnvelope = {
    data: UserConversationMembershipCreateManyInviterInput | UserConversationMembershipCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCharacterCreateWithoutUserInput = {
    id?: string
    characterId: string
    createdAt?: Date | string
  }

  export type FavoriteCharacterUncheckedCreateWithoutUserInput = {
    id?: string
    characterId: string
    createdAt?: Date | string
  }

  export type FavoriteCharacterCreateOrConnectWithoutUserInput = {
    where: FavoriteCharacterWhereUniqueInput
    create: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCharacterCreateManyUserInputEnvelope = {
    data: FavoriteCharacterCreateManyUserInput | FavoriteCharacterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CreditTransactionCreateWithoutUserInput = {
    id?: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
  }

  export type CreditTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
  }

  export type CreditTransactionCreateOrConnectWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    create: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput>
  }

  export type CreditTransactionCreateManyUserInputEnvelope = {
    data: CreditTransactionCreateManyUserInput | CreditTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageLogCreateWithoutUserInput = {
    id?: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type UsageLogUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type UsageLogCreateOrConnectWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogCreateManyUserInputEnvelope = {
    data: UsageLogCreateManyUserInput | UsageLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserMonthlyBalanceCreateWithoutUserInput = {
    id?: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyBalanceUncheckedCreateWithoutUserInput = {
    id?: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyBalanceCreateOrConnectWithoutUserInput = {
    where: UserMonthlyBalanceWhereUniqueInput
    create: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput>
  }

  export type UserMonthlyBalanceCreateManyUserInputEnvelope = {
    data: UserMonthlyBalanceCreateManyUserInput | UserMonthlyBalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPlanCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
    plan: PlanCreateNestedOneWithoutUserPlansInput
  }

  export type UserPlanUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlanCreateOrConnectWithoutUserInput = {
    where: UserPlanWhereUniqueInput
    create: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput>
  }

  export type UserPlanCreateManyUserInputEnvelope = {
    data: UserPlanCreateManyUserInput | UserPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPlusAccessCreateWithoutUserInput = {
    id?: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPlusAccessUncheckedCreateWithoutUserInput = {
    id?: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPlusAccessCreateOrConnectWithoutUserInput = {
    where: UserPlusAccessWhereUniqueInput
    create: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput>
  }

  export type UserPlusAccessCreateManyUserInputEnvelope = {
    data: UserPlusAccessCreateManyUserInput | UserPlusAccessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutCreatorInput, CharacterUncheckedUpdateWithoutCreatorInput>
    create: XOR<CharacterCreateWithoutCreatorInput, CharacterUncheckedCreateWithoutCreatorInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutCreatorInput, CharacterUncheckedUpdateWithoutCreatorInput>
  }

  export type CharacterUpdateManyWithWhereWithoutCreatorInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    firstName?: StringFilter<"Character"> | string
    lastName?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    style?: EnumVisualStyleNullableFilter<"Character"> | $Enums.VisualStyle | null
    reference?: StringNullableFilter<"Character"> | string | null
    physicalCharacteristics?: StringNullableFilter<"Character"> | string | null
    personality?: StringNullableFilter<"Character"> | string | null
    history?: StringNullableFilter<"Character"> | string | null
    visibility?: EnumVisibilityFilter<"Character"> | $Enums.Visibility
    isSystemCharacter?: BoolFilter<"Character"> | boolean
    originalLanguageCode?: StringNullableFilter<"Character"> | string | null
    ageRating?: EnumAgeRatingFilter<"Character"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Character">
    userId?: StringFilter<"Character"> | string
    loraId?: StringNullableFilter<"Character"> | string | null
    mainAttireId?: StringNullableFilter<"Character"> | string | null
    contentVersion?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
  }

  export type StoryUpsertWithWhereUniqueWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutAuthorInput, StoryUncheckedUpdateWithoutAuthorInput>
    create: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutAuthorInput, StoryUncheckedUpdateWithoutAuthorInput>
  }

  export type StoryUpdateManyWithWhereWithoutAuthorInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutAuthorInput>
  }

  export type StoryScalarWhereInput = {
    AND?: StoryScalarWhereInput | StoryScalarWhereInput[]
    OR?: StoryScalarWhereInput[]
    NOT?: StoryScalarWhereInput | StoryScalarWhereInput[]
    id?: StringFilter<"Story"> | string
    title?: StringFilter<"Story"> | string
    synopsis?: StringNullableFilter<"Story"> | string | null
    initialText?: StringNullableFilter<"Story"> | string | null
    coverImage?: StringNullableFilter<"Story"> | string | null
    objectives?: JsonNullableFilter<"Story">
    authorId?: StringFilter<"Story"> | string
    ageRating?: EnumAgeRatingFilter<"Story"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Story">
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    contentVersion?: IntFilter<"Story"> | number
    originalLanguageCode?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
  }

  export type AttireUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AttireWhereUniqueInput
    update: XOR<AttireUpdateWithoutOwnerInput, AttireUncheckedUpdateWithoutOwnerInput>
    create: XOR<AttireCreateWithoutOwnerInput, AttireUncheckedCreateWithoutOwnerInput>
  }

  export type AttireUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AttireWhereUniqueInput
    data: XOR<AttireUpdateWithoutOwnerInput, AttireUncheckedUpdateWithoutOwnerInput>
  }

  export type AttireUpdateManyWithWhereWithoutOwnerInput = {
    where: AttireScalarWhereInput
    data: XOR<AttireUpdateManyMutationInput, AttireUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AttireScalarWhereInput = {
    AND?: AttireScalarWhereInput | AttireScalarWhereInput[]
    OR?: AttireScalarWhereInput[]
    NOT?: AttireScalarWhereInput | AttireScalarWhereInput[]
    id?: StringFilter<"Attire"> | string
    name?: StringFilter<"Attire"> | string
    description?: StringNullableFilter<"Attire"> | string | null
    gender?: StringNullableFilter<"Attire"> | string | null
    promptHead?: StringNullableFilter<"Attire"> | string | null
    promptBody?: StringNullableFilter<"Attire"> | string | null
    promptFull?: StringNullableFilter<"Attire"> | string | null
    previewImageUrl?: StringNullableFilter<"Attire"> | string | null
    originalLanguageCode?: StringNullableFilter<"Attire"> | string | null
    visibility?: EnumVisibilityFilter<"Attire"> | $Enums.Visibility
    userId?: StringFilter<"Attire"> | string
    ageRating?: EnumAgeRatingFilter<"Attire"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Attire">
    contentVersion?: IntFilter<"Attire"> | number
    createdAt?: DateTimeFilter<"Attire"> | Date | string
    updatedAt?: DateTimeFilter<"Attire"> | Date | string
  }

  export type AssistantUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AssistantWhereUniqueInput
    update: XOR<AssistantUpdateWithoutCreatorInput, AssistantUncheckedUpdateWithoutCreatorInput>
    create: XOR<AssistantCreateWithoutCreatorInput, AssistantUncheckedCreateWithoutCreatorInput>
  }

  export type AssistantUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AssistantWhereUniqueInput
    data: XOR<AssistantUpdateWithoutCreatorInput, AssistantUncheckedUpdateWithoutCreatorInput>
  }

  export type AssistantUpdateManyWithWhereWithoutCreatorInput = {
    where: AssistantScalarWhereInput
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AssistantScalarWhereInput = {
    AND?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
    OR?: AssistantScalarWhereInput[]
    NOT?: AssistantScalarWhereInput | AssistantScalarWhereInput[]
    id?: StringFilter<"Assistant"> | string
    name?: StringFilter<"Assistant"> | string
    description?: StringNullableFilter<"Assistant"> | string | null
    instructions?: StringFilter<"Assistant"> | string
    defaultCharacterId?: StringNullableFilter<"Assistant"> | string | null
    visibility?: EnumVisibilityFilter<"Assistant"> | $Enums.Visibility
    userId?: StringFilter<"Assistant"> | string
    createdAt?: DateTimeFilter<"Assistant"> | Date | string
    updatedAt?: DateTimeFilter<"Assistant"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutOwnerInput, ConversationUncheckedUpdateWithoutOwnerInput>
    create: XOR<ConversationCreateWithoutOwnerInput, ConversationUncheckedCreateWithoutOwnerInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutOwnerInput, ConversationUncheckedUpdateWithoutOwnerInput>
  }

  export type ConversationUpdateManyWithWhereWithoutOwnerInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    isTitleUserEdited?: BoolFilter<"Conversation"> | boolean
    isTitleSystemEdited?: BoolFilter<"Conversation"> | boolean
    projectId?: StringNullableFilter<"Conversation"> | string | null
    storyId?: StringNullableFilter<"Conversation"> | string | null
    settings?: JsonNullableFilter<"Conversation">
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    titleLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    memoryLastUpdatedAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    isMultiUser?: BoolFilter<"Conversation"> | boolean
    maxUsers?: IntFilter<"Conversation"> | number
    ownerUserId?: StringNullableFilter<"Conversation"> | string | null
    allowUserInvites?: BoolFilter<"Conversation"> | boolean
    requireApproval?: BoolFilter<"Conversation"> | boolean
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    actingAssistantId?: StringNullableFilter<"ConversationParticipant"> | string | null
    representingCharacterId?: StringNullableFilter<"ConversationParticipant"> | string | null
    configOverride?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutConversationOwnerInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutConversationOwnerInput, ConversationUncheckedUpdateWithoutConversationOwnerInput>
    create: XOR<ConversationCreateWithoutConversationOwnerInput, ConversationUncheckedCreateWithoutConversationOwnerInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutConversationOwnerInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutConversationOwnerInput, ConversationUncheckedUpdateWithoutConversationOwnerInput>
  }

  export type ConversationUpdateManyWithWhereWithoutConversationOwnerInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationOwnerInput>
  }

  export type UserConversationMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: UserConversationMembershipWhereUniqueInput
    update: XOR<UserConversationMembershipUpdateWithoutUserInput, UserConversationMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<UserConversationMembershipCreateWithoutUserInput, UserConversationMembershipUncheckedCreateWithoutUserInput>
  }

  export type UserConversationMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: UserConversationMembershipWhereUniqueInput
    data: XOR<UserConversationMembershipUpdateWithoutUserInput, UserConversationMembershipUncheckedUpdateWithoutUserInput>
  }

  export type UserConversationMembershipUpdateManyWithWhereWithoutUserInput = {
    where: UserConversationMembershipScalarWhereInput
    data: XOR<UserConversationMembershipUpdateManyMutationInput, UserConversationMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConversationMembershipScalarWhereInput = {
    AND?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
    OR?: UserConversationMembershipScalarWhereInput[]
    NOT?: UserConversationMembershipScalarWhereInput | UserConversationMembershipScalarWhereInput[]
    id?: StringFilter<"UserConversationMembership"> | string
    conversationId?: StringFilter<"UserConversationMembership"> | string
    userId?: StringFilter<"UserConversationMembership"> | string
    role?: EnumMembershipRoleFilter<"UserConversationMembership"> | $Enums.MembershipRole
    canWrite?: BoolFilter<"UserConversationMembership"> | boolean
    canInvite?: BoolFilter<"UserConversationMembership"> | boolean
    canModerate?: BoolFilter<"UserConversationMembership"> | boolean
    joinedAt?: DateTimeFilter<"UserConversationMembership"> | Date | string
    invitedBy?: StringNullableFilter<"UserConversationMembership"> | string | null
    isActive?: BoolFilter<"UserConversationMembership"> | boolean
  }

  export type UserConversationMembershipUpsertWithWhereUniqueWithoutInviterInput = {
    where: UserConversationMembershipWhereUniqueInput
    update: XOR<UserConversationMembershipUpdateWithoutInviterInput, UserConversationMembershipUncheckedUpdateWithoutInviterInput>
    create: XOR<UserConversationMembershipCreateWithoutInviterInput, UserConversationMembershipUncheckedCreateWithoutInviterInput>
  }

  export type UserConversationMembershipUpdateWithWhereUniqueWithoutInviterInput = {
    where: UserConversationMembershipWhereUniqueInput
    data: XOR<UserConversationMembershipUpdateWithoutInviterInput, UserConversationMembershipUncheckedUpdateWithoutInviterInput>
  }

  export type UserConversationMembershipUpdateManyWithWhereWithoutInviterInput = {
    where: UserConversationMembershipScalarWhereInput
    data: XOR<UserConversationMembershipUpdateManyMutationInput, UserConversationMembershipUncheckedUpdateManyWithoutInviterInput>
  }

  export type FavoriteCharacterUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteCharacterWhereUniqueInput
    update: XOR<FavoriteCharacterUpdateWithoutUserInput, FavoriteCharacterUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCharacterCreateWithoutUserInput, FavoriteCharacterUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCharacterUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteCharacterWhereUniqueInput
    data: XOR<FavoriteCharacterUpdateWithoutUserInput, FavoriteCharacterUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteCharacterUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteCharacterScalarWhereInput
    data: XOR<FavoriteCharacterUpdateManyMutationInput, FavoriteCharacterUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteCharacterScalarWhereInput = {
    AND?: FavoriteCharacterScalarWhereInput | FavoriteCharacterScalarWhereInput[]
    OR?: FavoriteCharacterScalarWhereInput[]
    NOT?: FavoriteCharacterScalarWhereInput | FavoriteCharacterScalarWhereInput[]
    id?: StringFilter<"FavoriteCharacter"> | string
    userId?: StringFilter<"FavoriteCharacter"> | string
    characterId?: StringFilter<"FavoriteCharacter"> | string
    createdAt?: DateTimeFilter<"FavoriteCharacter"> | Date | string
  }

  export type CreditTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    update: XOR<CreditTransactionUpdateWithoutUserInput, CreditTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput>
  }

  export type CreditTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    data: XOR<CreditTransactionUpdateWithoutUserInput, CreditTransactionUncheckedUpdateWithoutUserInput>
  }

  export type CreditTransactionUpdateManyWithWhereWithoutUserInput = {
    where: CreditTransactionScalarWhereInput
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type CreditTransactionScalarWhereInput = {
    AND?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
    OR?: CreditTransactionScalarWhereInput[]
    NOT?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
    id?: StringFilter<"CreditTransaction"> | string
    userId?: StringFilter<"CreditTransaction"> | string
    transactionType?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    amountCredits?: FloatFilter<"CreditTransaction"> | number
    balanceAfter?: FloatNullableFilter<"CreditTransaction"> | number | null
    notes?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedUsageLogId?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedPlanId?: StringNullableFilter<"CreditTransaction"> | string | null
    timestamp?: DateTimeFilter<"CreditTransaction"> | Date | string
  }

  export type UsageLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    update: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    data: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
  }

  export type UsageLogUpdateManyWithWhereWithoutUserInput = {
    where: UsageLogScalarWhereInput
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageLogScalarWhereInput = {
    AND?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    OR?: UsageLogScalarWhereInput[]
    NOT?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringFilter<"UsageLog"> | string
    conversationId?: StringNullableFilter<"UsageLog"> | string | null
    serviceType?: StringFilter<"UsageLog"> | string
    providerName?: StringNullableFilter<"UsageLog"> | string | null
    modelName?: StringNullableFilter<"UsageLog"> | string | null
    inputTokens?: IntNullableFilter<"UsageLog"> | number | null
    outputTokens?: IntNullableFilter<"UsageLog"> | number | null
    charactersProcessed?: IntNullableFilter<"UsageLog"> | number | null
    imagesProcessed?: IntNullableFilter<"UsageLog"> | number | null
    costUsd?: FloatNullableFilter<"UsageLog"> | number | null
    creditsConsumed?: FloatNullableFilter<"UsageLog"> | number | null
    additionalMetadata?: JsonNullableFilter<"UsageLog">
    processed?: BoolFilter<"UsageLog"> | boolean
    processedAt?: DateTimeNullableFilter<"UsageLog"> | Date | string | null
    timestamp?: DateTimeFilter<"UsageLog"> | Date | string
  }

  export type UserMonthlyBalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMonthlyBalanceWhereUniqueInput
    update: XOR<UserMonthlyBalanceUpdateWithoutUserInput, UserMonthlyBalanceUncheckedUpdateWithoutUserInput>
    create: XOR<UserMonthlyBalanceCreateWithoutUserInput, UserMonthlyBalanceUncheckedCreateWithoutUserInput>
  }

  export type UserMonthlyBalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMonthlyBalanceWhereUniqueInput
    data: XOR<UserMonthlyBalanceUpdateWithoutUserInput, UserMonthlyBalanceUncheckedUpdateWithoutUserInput>
  }

  export type UserMonthlyBalanceUpdateManyWithWhereWithoutUserInput = {
    where: UserMonthlyBalanceScalarWhereInput
    data: XOR<UserMonthlyBalanceUpdateManyMutationInput, UserMonthlyBalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMonthlyBalanceScalarWhereInput = {
    AND?: UserMonthlyBalanceScalarWhereInput | UserMonthlyBalanceScalarWhereInput[]
    OR?: UserMonthlyBalanceScalarWhereInput[]
    NOT?: UserMonthlyBalanceScalarWhereInput | UserMonthlyBalanceScalarWhereInput[]
    id?: StringFilter<"UserMonthlyBalance"> | string
    userId?: StringFilter<"UserMonthlyBalance"> | string
    monthStartDate?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    startingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    creditsGranted?: FloatFilter<"UserMonthlyBalance"> | number
    creditsSpent?: FloatFilter<"UserMonthlyBalance"> | number
    endingBalance?: FloatFilter<"UserMonthlyBalance"> | number
    createdAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyBalance"> | Date | string
  }

  export type UserPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPlanWhereUniqueInput
    update: XOR<UserPlanUpdateWithoutUserInput, UserPlanUncheckedUpdateWithoutUserInput>
    create: XOR<UserPlanCreateWithoutUserInput, UserPlanUncheckedCreateWithoutUserInput>
  }

  export type UserPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPlanWhereUniqueInput
    data: XOR<UserPlanUpdateWithoutUserInput, UserPlanUncheckedUpdateWithoutUserInput>
  }

  export type UserPlanUpdateManyWithWhereWithoutUserInput = {
    where: UserPlanScalarWhereInput
    data: XOR<UserPlanUpdateManyMutationInput, UserPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPlanScalarWhereInput = {
    AND?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
    OR?: UserPlanScalarWhereInput[]
    NOT?: UserPlanScalarWhereInput | UserPlanScalarWhereInput[]
    id?: StringFilter<"UserPlan"> | string
    userId?: StringFilter<"UserPlan"> | string
    planId?: StringFilter<"UserPlan"> | string
    status?: EnumSubscriptionStatusFilter<"UserPlan"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"UserPlan"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"UserPlan"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"UserPlan"> | boolean
    canceledAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPlan"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlan"> | Date | string
    lastCreditsGrantedAt?: DateTimeNullableFilter<"UserPlan"> | Date | string | null
    paypalSubscriptionId?: StringNullableFilter<"UserPlan"> | string | null
  }

  export type UserPlusAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPlusAccessWhereUniqueInput
    update: XOR<UserPlusAccessUpdateWithoutUserInput, UserPlusAccessUncheckedUpdateWithoutUserInput>
    create: XOR<UserPlusAccessCreateWithoutUserInput, UserPlusAccessUncheckedCreateWithoutUserInput>
  }

  export type UserPlusAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPlusAccessWhereUniqueInput
    data: XOR<UserPlusAccessUpdateWithoutUserInput, UserPlusAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserPlusAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserPlusAccessScalarWhereInput
    data: XOR<UserPlusAccessUpdateManyMutationInput, UserPlusAccessUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPlusAccessScalarWhereInput = {
    AND?: UserPlusAccessScalarWhereInput | UserPlusAccessScalarWhereInput[]
    OR?: UserPlusAccessScalarWhereInput[]
    NOT?: UserPlusAccessScalarWhereInput | UserPlusAccessScalarWhereInput[]
    id?: StringFilter<"UserPlusAccess"> | string
    userId?: StringFilter<"UserPlusAccess"> | string
    grantedBy?: StringNullableFilter<"UserPlusAccess"> | string | null
    reason?: StringNullableFilter<"UserPlusAccess"> | string | null
    startDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    endDate?: DateTimeFilter<"UserPlusAccess"> | Date | string
    isActive?: BoolFilter<"UserPlusAccess"> | boolean
    createdAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
    updatedAt?: DateTimeFilter<"UserPlusAccess"> | Date | string
  }

  export type CharacterCreateWithoutLoraInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutLoraInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutLoraInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput>
  }

  export type CharacterCreateManyLoraInputEnvelope = {
    data: CharacterCreateManyLoraInput | CharacterCreateManyLoraInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutLoraInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutLoraInput, CharacterUncheckedUpdateWithoutLoraInput>
    create: XOR<CharacterCreateWithoutLoraInput, CharacterUncheckedCreateWithoutLoraInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutLoraInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutLoraInput, CharacterUncheckedUpdateWithoutLoraInput>
  }

  export type CharacterUpdateManyWithWhereWithoutLoraInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutLoraInput>
  }

  export type UserCreateWithoutCreatedAttiresInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAttiresInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAttiresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAttiresInput, UserUncheckedCreateWithoutCreatedAttiresInput>
  }

  export type CharacterCreateWithoutMainAttireInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutMainAttireInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutMainAttireInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput>
  }

  export type CharacterCreateManyMainAttireInputEnvelope = {
    data: CharacterCreateManyMainAttireInput | CharacterCreateManyMainAttireInput[]
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutAttiresInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAttiresInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAttiresInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput>
  }

  export type UserUpsertWithoutCreatedAttiresInput = {
    update: XOR<UserUpdateWithoutCreatedAttiresInput, UserUncheckedUpdateWithoutCreatedAttiresInput>
    create: XOR<UserCreateWithoutCreatedAttiresInput, UserUncheckedCreateWithoutCreatedAttiresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAttiresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAttiresInput, UserUncheckedUpdateWithoutCreatedAttiresInput>
  }

  export type UserUpdateWithoutCreatedAttiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAttiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterUpsertWithWhereUniqueWithoutMainAttireInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutMainAttireInput, CharacterUncheckedUpdateWithoutMainAttireInput>
    create: XOR<CharacterCreateWithoutMainAttireInput, CharacterUncheckedCreateWithoutMainAttireInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutMainAttireInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutMainAttireInput, CharacterUncheckedUpdateWithoutMainAttireInput>
  }

  export type CharacterUpdateManyWithWhereWithoutMainAttireInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutMainAttireInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutAttiresInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutAttiresInput, CharacterUncheckedUpdateWithoutAttiresInput>
    create: XOR<CharacterCreateWithoutAttiresInput, CharacterUncheckedCreateWithoutAttiresInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutAttiresInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutAttiresInput, CharacterUncheckedUpdateWithoutAttiresInput>
  }

  export type CharacterUpdateManyWithWhereWithoutAttiresInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutAttiresInput>
  }

  export type CharacterCreateWithoutTagsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutTagsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutTagsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput>
  }

  export type StoryCreateWithoutTagsInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutStoriesInput
    characters?: CharacterCreateNestedManyWithoutStoriesInput
    conversations?: ConversationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutStoriesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutTagsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutTagsInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutTagsInput, CharacterUncheckedUpdateWithoutTagsInput>
    create: XOR<CharacterCreateWithoutTagsInput, CharacterUncheckedCreateWithoutTagsInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutTagsInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutTagsInput, CharacterUncheckedUpdateWithoutTagsInput>
  }

  export type CharacterUpdateManyWithWhereWithoutTagsInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutTagsInput>
  }

  export type StoryUpsertWithWhereUniqueWithoutTagsInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutTagsInput, StoryUncheckedUpdateWithoutTagsInput>
    create: XOR<StoryCreateWithoutTagsInput, StoryUncheckedCreateWithoutTagsInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutTagsInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutTagsInput, StoryUncheckedUpdateWithoutTagsInput>
  }

  export type StoryUpdateManyWithWhereWithoutTagsInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutTagsInput>
  }

  export type UserCreateWithoutCreatedCharactersInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCharactersInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCharactersInput, UserUncheckedCreateWithoutCreatedCharactersInput>
  }

  export type LoraCreateWithoutCharactersInput = {
    id?: string
    civitaiModelId?: string | null
    civitaiVersionId?: string | null
    name: string
    modelType?: string | null
    baseModel?: string | null
    downloadCount?: number | null
    modelUrl?: string | null
    tags?: LoraCreatetagsInput | string[]
    trainedWords?: LoraCreatetrainedWordsInput | string[]
    nsfw?: boolean
    filename?: string | null
    filepathRelative?: string | null
    firstImageUrl?: string | null
    imageUrls?: LoraCreateimageUrlsInput | string[]
    category?: string | null
    term?: string | null
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoraUncheckedCreateWithoutCharactersInput = {
    id?: string
    civitaiModelId?: string | null
    civitaiVersionId?: string | null
    name: string
    modelType?: string | null
    baseModel?: string | null
    downloadCount?: number | null
    modelUrl?: string | null
    tags?: LoraCreatetagsInput | string[]
    trainedWords?: LoraCreatetrainedWordsInput | string[]
    nsfw?: boolean
    filename?: string | null
    filepathRelative?: string | null
    firstImageUrl?: string | null
    imageUrls?: LoraCreateimageUrlsInput | string[]
    category?: string | null
    term?: string | null
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoraCreateOrConnectWithoutCharactersInput = {
    where: LoraWhereUniqueInput
    create: XOR<LoraCreateWithoutCharactersInput, LoraUncheckedCreateWithoutCharactersInput>
  }

  export type AttireCreateWithoutCharactersUsingAsMainInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCreatedAttiresInput
    characters?: CharacterCreateNestedManyWithoutAttiresInput
  }

  export type AttireUncheckedCreateWithoutCharactersUsingAsMainInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    userId: string
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutAttiresInput
  }

  export type AttireCreateOrConnectWithoutCharactersUsingAsMainInput = {
    where: AttireWhereUniqueInput
    create: XOR<AttireCreateWithoutCharactersUsingAsMainInput, AttireUncheckedCreateWithoutCharactersUsingAsMainInput>
  }

  export type StoryCreateWithoutCharactersInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutStoriesInput
    tags?: TagCreateNestedManyWithoutStoriesInput
    conversations?: ConversationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutCharactersInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutStoriesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutCharactersInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput>
  }

  export type AttireCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCreatedAttiresInput
    charactersUsingAsMain?: CharacterCreateNestedManyWithoutMainAttireInput
  }

  export type AttireUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    userId: string
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    charactersUsingAsMain?: CharacterUncheckedCreateNestedManyWithoutMainAttireInput
  }

  export type AttireCreateOrConnectWithoutCharactersInput = {
    where: AttireWhereUniqueInput
    create: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput>
  }

  export type TagCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutCharactersInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput>
  }

  export type CharacterStickerCreateWithoutCharacterInput = {
    id?: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterStickerUncheckedCreateWithoutCharacterInput = {
    id?: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterStickerCreateOrConnectWithoutCharacterInput = {
    where: CharacterStickerWhereUniqueInput
    create: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterStickerCreateManyCharacterInputEnvelope = {
    data: CharacterStickerCreateManyCharacterInput | CharacterStickerCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterImageCreateWithoutCharacterInput = {
    id?: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterImageUncheckedCreateWithoutCharacterInput = {
    id?: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterImageCreateOrConnectWithoutCharacterInput = {
    where: CharacterImageWhereUniqueInput
    create: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterImageCreateManyCharacterInputEnvelope = {
    data: CharacterImageCreateManyCharacterInput | CharacterImageCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type AssistantCreateWithoutDefaultCharacterInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutAssistantsInput
    participations?: ConversationParticipantCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantUncheckedCreateWithoutDefaultCharacterInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingAssistantInput
  }

  export type AssistantCreateOrConnectWithoutDefaultCharacterInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput>
  }

  export type AssistantCreateManyDefaultCharacterInputEnvelope = {
    data: AssistantCreateManyDefaultCharacterInput | AssistantCreateManyDefaultCharacterInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutActingCharacterInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user?: UserCreateNestedOneWithoutConversationParticipationsInput
    actingAssistant?: AssistantCreateNestedOneWithoutParticipationsInput
    representingCharacter?: CharacterCreateNestedOneWithoutRepresentingParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutActingCharacterInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutActingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput>
  }

  export type ConversationParticipantCreateManyActingCharacterInputEnvelope = {
    data: ConversationParticipantCreateManyActingCharacterInput | ConversationParticipantCreateManyActingCharacterInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutRepresentingCharacterInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user?: UserCreateNestedOneWithoutConversationParticipationsInput
    actingCharacter?: CharacterCreateNestedOneWithoutActingParticipationsInput
    actingAssistant?: AssistantCreateNestedOneWithoutParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutRepresentingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput>
  }

  export type ConversationParticipantCreateManyRepresentingCharacterInputEnvelope = {
    data: ConversationParticipantCreateManyRepresentingCharacterInput | ConversationParticipantCreateManyRepresentingCharacterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCharactersInput = {
    update: XOR<UserUpdateWithoutCreatedCharactersInput, UserUncheckedUpdateWithoutCreatedCharactersInput>
    create: XOR<UserCreateWithoutCreatedCharactersInput, UserUncheckedCreateWithoutCreatedCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCharactersInput, UserUncheckedUpdateWithoutCreatedCharactersInput>
  }

  export type UserUpdateWithoutCreatedCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LoraUpsertWithoutCharactersInput = {
    update: XOR<LoraUpdateWithoutCharactersInput, LoraUncheckedUpdateWithoutCharactersInput>
    create: XOR<LoraCreateWithoutCharactersInput, LoraUncheckedCreateWithoutCharactersInput>
    where?: LoraWhereInput
  }

  export type LoraUpdateToOneWithWhereWithoutCharactersInput = {
    where?: LoraWhereInput
    data: XOR<LoraUpdateWithoutCharactersInput, LoraUncheckedUpdateWithoutCharactersInput>
  }

  export type LoraUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoraUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    civitaiModelId?: NullableStringFieldUpdateOperationsInput | string | null
    civitaiVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    modelType?: NullableStringFieldUpdateOperationsInput | string | null
    baseModel?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: NullableIntFieldUpdateOperationsInput | number | null
    modelUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LoraUpdatetagsInput | string[]
    trainedWords?: LoraUpdatetrainedWordsInput | string[]
    nsfw?: BoolFieldUpdateOperationsInput | boolean
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    filepathRelative?: NullableStringFieldUpdateOperationsInput | string | null
    firstImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: LoraUpdateimageUrlsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttireUpsertWithoutCharactersUsingAsMainInput = {
    update: XOR<AttireUpdateWithoutCharactersUsingAsMainInput, AttireUncheckedUpdateWithoutCharactersUsingAsMainInput>
    create: XOR<AttireCreateWithoutCharactersUsingAsMainInput, AttireUncheckedCreateWithoutCharactersUsingAsMainInput>
    where?: AttireWhereInput
  }

  export type AttireUpdateToOneWithWhereWithoutCharactersUsingAsMainInput = {
    where?: AttireWhereInput
    data: XOR<AttireUpdateWithoutCharactersUsingAsMainInput, AttireUncheckedUpdateWithoutCharactersUsingAsMainInput>
  }

  export type AttireUpdateWithoutCharactersUsingAsMainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCreatedAttiresNestedInput
    characters?: CharacterUpdateManyWithoutAttiresNestedInput
  }

  export type AttireUncheckedUpdateWithoutCharactersUsingAsMainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutAttiresNestedInput
  }

  export type StoryUpsertWithWhereUniqueWithoutCharactersInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutCharactersInput, StoryUncheckedUpdateWithoutCharactersInput>
    create: XOR<StoryCreateWithoutCharactersInput, StoryUncheckedCreateWithoutCharactersInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutCharactersInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutCharactersInput, StoryUncheckedUpdateWithoutCharactersInput>
  }

  export type StoryUpdateManyWithWhereWithoutCharactersInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutCharactersInput>
  }

  export type AttireUpsertWithWhereUniqueWithoutCharactersInput = {
    where: AttireWhereUniqueInput
    update: XOR<AttireUpdateWithoutCharactersInput, AttireUncheckedUpdateWithoutCharactersInput>
    create: XOR<AttireCreateWithoutCharactersInput, AttireUncheckedCreateWithoutCharactersInput>
  }

  export type AttireUpdateWithWhereUniqueWithoutCharactersInput = {
    where: AttireWhereUniqueInput
    data: XOR<AttireUpdateWithoutCharactersInput, AttireUncheckedUpdateWithoutCharactersInput>
  }

  export type AttireUpdateManyWithWhereWithoutCharactersInput = {
    where: AttireScalarWhereInput
    data: XOR<AttireUpdateManyMutationInput, AttireUncheckedUpdateManyWithoutCharactersInput>
  }

  export type TagUpsertWithWhereUniqueWithoutCharactersInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutCharactersInput, TagUncheckedUpdateWithoutCharactersInput>
    create: XOR<TagCreateWithoutCharactersInput, TagUncheckedCreateWithoutCharactersInput>
  }

  export type TagUpdateWithWhereUniqueWithoutCharactersInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutCharactersInput, TagUncheckedUpdateWithoutCharactersInput>
  }

  export type TagUpdateManyWithWhereWithoutCharactersInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutCharactersInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    ageRating?: EnumAgeRatingFilter<"Tag"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"Tag">
    originalLanguageCode?: StringNullableFilter<"Tag"> | string | null
    weight?: IntFilter<"Tag"> | number
    searchable?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type CharacterStickerUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterStickerWhereUniqueInput
    update: XOR<CharacterStickerUpdateWithoutCharacterInput, CharacterStickerUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterStickerCreateWithoutCharacterInput, CharacterStickerUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterStickerUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterStickerWhereUniqueInput
    data: XOR<CharacterStickerUpdateWithoutCharacterInput, CharacterStickerUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterStickerUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterStickerScalarWhereInput
    data: XOR<CharacterStickerUpdateManyMutationInput, CharacterStickerUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterStickerScalarWhereInput = {
    AND?: CharacterStickerScalarWhereInput | CharacterStickerScalarWhereInput[]
    OR?: CharacterStickerScalarWhereInput[]
    NOT?: CharacterStickerScalarWhereInput | CharacterStickerScalarWhereInput[]
    id?: StringFilter<"CharacterSticker"> | string
    characterId?: StringFilter<"CharacterSticker"> | string
    emotionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    actionTag?: StringNullableFilter<"CharacterSticker"> | string | null
    imageUrl?: StringNullableFilter<"CharacterSticker"> | string | null
    promptUsed?: StringNullableFilter<"CharacterSticker"> | string | null
    status?: EnumStickerStatusFilter<"CharacterSticker"> | $Enums.StickerStatus
    createdAt?: DateTimeFilter<"CharacterSticker"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSticker"> | Date | string
  }

  export type CharacterImageUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterImageWhereUniqueInput
    update: XOR<CharacterImageUpdateWithoutCharacterInput, CharacterImageUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterImageCreateWithoutCharacterInput, CharacterImageUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterImageUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterImageWhereUniqueInput
    data: XOR<CharacterImageUpdateWithoutCharacterInput, CharacterImageUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterImageUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterImageScalarWhereInput
    data: XOR<CharacterImageUpdateManyMutationInput, CharacterImageUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterImageScalarWhereInput = {
    AND?: CharacterImageScalarWhereInput | CharacterImageScalarWhereInput[]
    OR?: CharacterImageScalarWhereInput[]
    NOT?: CharacterImageScalarWhereInput | CharacterImageScalarWhereInput[]
    id?: StringFilter<"CharacterImage"> | string
    characterId?: StringFilter<"CharacterImage"> | string
    type?: EnumImageTypeFilter<"CharacterImage"> | $Enums.ImageType
    url?: StringFilter<"CharacterImage"> | string
    key?: StringNullableFilter<"CharacterImage"> | string | null
    width?: IntNullableFilter<"CharacterImage"> | number | null
    height?: IntNullableFilter<"CharacterImage"> | number | null
    sizeBytes?: IntNullableFilter<"CharacterImage"> | number | null
    contentType?: StringNullableFilter<"CharacterImage"> | string | null
    ageRating?: EnumAgeRatingFilter<"CharacterImage"> | $Enums.AgeRating
    contentTags?: EnumContentTagNullableListFilter<"CharacterImage">
    description?: StringNullableFilter<"CharacterImage"> | string | null
    isActive?: BoolFilter<"CharacterImage"> | boolean
    createdAt?: DateTimeFilter<"CharacterImage"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterImage"> | Date | string
  }

  export type AssistantUpsertWithWhereUniqueWithoutDefaultCharacterInput = {
    where: AssistantWhereUniqueInput
    update: XOR<AssistantUpdateWithoutDefaultCharacterInput, AssistantUncheckedUpdateWithoutDefaultCharacterInput>
    create: XOR<AssistantCreateWithoutDefaultCharacterInput, AssistantUncheckedCreateWithoutDefaultCharacterInput>
  }

  export type AssistantUpdateWithWhereUniqueWithoutDefaultCharacterInput = {
    where: AssistantWhereUniqueInput
    data: XOR<AssistantUpdateWithoutDefaultCharacterInput, AssistantUncheckedUpdateWithoutDefaultCharacterInput>
  }

  export type AssistantUpdateManyWithWhereWithoutDefaultCharacterInput = {
    where: AssistantScalarWhereInput
    data: XOR<AssistantUpdateManyMutationInput, AssistantUncheckedUpdateManyWithoutDefaultCharacterInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutActingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutActingCharacterInput, ConversationParticipantUncheckedUpdateWithoutActingCharacterInput>
    create: XOR<ConversationParticipantCreateWithoutActingCharacterInput, ConversationParticipantUncheckedCreateWithoutActingCharacterInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutActingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutActingCharacterInput, ConversationParticipantUncheckedUpdateWithoutActingCharacterInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutActingCharacterInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutActingCharacterInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutRepresentingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedUpdateWithoutRepresentingCharacterInput>
    create: XOR<ConversationParticipantCreateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedCreateWithoutRepresentingCharacterInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutRepresentingCharacterInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutRepresentingCharacterInput, ConversationParticipantUncheckedUpdateWithoutRepresentingCharacterInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutRepresentingCharacterInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterInput>
  }

  export type CharacterCreateWithoutStickersInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutStickersInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutStickersInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutStickersInput, CharacterUncheckedCreateWithoutStickersInput>
  }

  export type CharacterUpsertWithoutStickersInput = {
    update: XOR<CharacterUpdateWithoutStickersInput, CharacterUncheckedUpdateWithoutStickersInput>
    create: XOR<CharacterCreateWithoutStickersInput, CharacterUncheckedCreateWithoutStickersInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutStickersInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutStickersInput, CharacterUncheckedUpdateWithoutStickersInput>
  }

  export type CharacterUpdateWithoutStickersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutStickersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterCreateWithoutImagesInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutImagesInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutImagesInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutImagesInput, CharacterUncheckedCreateWithoutImagesInput>
  }

  export type CharacterUpsertWithoutImagesInput = {
    update: XOR<CharacterUpdateWithoutImagesInput, CharacterUncheckedUpdateWithoutImagesInput>
    create: XOR<CharacterCreateWithoutImagesInput, CharacterUncheckedCreateWithoutImagesInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutImagesInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutImagesInput, CharacterUncheckedUpdateWithoutImagesInput>
  }

  export type CharacterUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type UserCreateWithoutStoriesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoriesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
  }

  export type CharacterCreateWithoutStoriesInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutStoriesInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutStoriesInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput>
  }

  export type TagCreateWithoutStoriesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutStoriesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.TagType
    ageRating?: $Enums.AgeRating
    contentTags?: TagCreatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: string | null
    weight?: number
    searchable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutStoriesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput>
  }

  export type ConversationCreateWithoutStoryInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutStoryInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutStoryInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput>
  }

  export type ConversationCreateManyStoryInputEnvelope = {
    data: ConversationCreateManyStoryInput | ConversationCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoriesInput = {
    update: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterUpsertWithWhereUniqueWithoutStoriesInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutStoriesInput, CharacterUncheckedUpdateWithoutStoriesInput>
    create: XOR<CharacterCreateWithoutStoriesInput, CharacterUncheckedCreateWithoutStoriesInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutStoriesInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutStoriesInput, CharacterUncheckedUpdateWithoutStoriesInput>
  }

  export type CharacterUpdateManyWithWhereWithoutStoriesInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutStoriesInput>
  }

  export type TagUpsertWithWhereUniqueWithoutStoriesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutStoriesInput, TagUncheckedUpdateWithoutStoriesInput>
    create: XOR<TagCreateWithoutStoriesInput, TagUncheckedCreateWithoutStoriesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutStoriesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutStoriesInput, TagUncheckedUpdateWithoutStoriesInput>
  }

  export type TagUpdateManyWithWhereWithoutStoriesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutStoriesInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutStoryInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutStoryInput, ConversationUncheckedUpdateWithoutStoryInput>
    create: XOR<ConversationCreateWithoutStoryInput, ConversationUncheckedCreateWithoutStoryInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutStoryInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutStoryInput, ConversationUncheckedUpdateWithoutStoryInput>
  }

  export type ConversationUpdateManyWithWhereWithoutStoryInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutStoryInput>
  }

  export type CharacterCreateWithoutAssistantsUsingAsDefaultInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAssistantsUsingAsDefaultInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAssistantsUsingAsDefaultInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedCreateWithoutAssistantsUsingAsDefaultInput>
  }

  export type UserCreateWithoutAssistantsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssistantsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssistantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssistantsInput, UserUncheckedCreateWithoutAssistantsInput>
  }

  export type ConversationParticipantCreateWithoutActingAssistantInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user?: UserCreateNestedOneWithoutConversationParticipationsInput
    actingCharacter?: CharacterCreateNestedOneWithoutActingParticipationsInput
    representingCharacter?: CharacterCreateNestedOneWithoutRepresentingParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutActingAssistantInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutActingAssistantInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput>
  }

  export type ConversationParticipantCreateManyActingAssistantInputEnvelope = {
    data: ConversationParticipantCreateManyActingAssistantInput | ConversationParticipantCreateManyActingAssistantInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithoutAssistantsUsingAsDefaultInput = {
    update: XOR<CharacterUpdateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedUpdateWithoutAssistantsUsingAsDefaultInput>
    create: XOR<CharacterCreateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedCreateWithoutAssistantsUsingAsDefaultInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutAssistantsUsingAsDefaultInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutAssistantsUsingAsDefaultInput, CharacterUncheckedUpdateWithoutAssistantsUsingAsDefaultInput>
  }

  export type CharacterUpdateWithoutAssistantsUsingAsDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAssistantsUsingAsDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type UserUpsertWithoutAssistantsInput = {
    update: XOR<UserUpdateWithoutAssistantsInput, UserUncheckedUpdateWithoutAssistantsInput>
    create: XOR<UserCreateWithoutAssistantsInput, UserUncheckedCreateWithoutAssistantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssistantsInput, UserUncheckedUpdateWithoutAssistantsInput>
  }

  export type UserUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssistantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutActingAssistantInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutActingAssistantInput, ConversationParticipantUncheckedUpdateWithoutActingAssistantInput>
    create: XOR<ConversationParticipantCreateWithoutActingAssistantInput, ConversationParticipantUncheckedCreateWithoutActingAssistantInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutActingAssistantInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutActingAssistantInput, ConversationParticipantUncheckedUpdateWithoutActingAssistantInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutActingAssistantInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutActingAssistantInput>
  }

  export type StoryCreateWithoutConversationsInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutStoriesInput
    characters?: CharacterCreateNestedManyWithoutStoriesInput
    tags?: TagCreateNestedManyWithoutStoriesInput
  }

  export type StoryUncheckedCreateWithoutConversationsInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutStoriesInput
    tags?: TagUncheckedCreateNestedManyWithoutStoriesInput
  }

  export type StoryCreateOrConnectWithoutConversationsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutConversationsInput, StoryUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutOwnedConversationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedConversationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedConversationsInput, UserUncheckedCreateWithoutOwnedConversationsInput>
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    id?: string
    configOverride?: string | null
    joinedAt?: Date | string
    user?: UserCreateNestedOneWithoutConversationParticipationsInput
    actingCharacter?: CharacterCreateNestedOneWithoutActingParticipationsInput
    actingAssistant?: AssistantCreateNestedOneWithoutParticipationsInput
    representingCharacter?: CharacterCreateNestedOneWithoutRepresentingParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationMemoryCreateWithoutConversationInput = {
    id?: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationMemoryUncheckedCreateWithoutConversationInput = {
    id?: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationMemoryCreateOrConnectWithoutConversationInput = {
    where: ConversationMemoryWhereUniqueInput
    create: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMemoryCreateManyConversationInputEnvelope = {
    data: ConversationMemoryCreateManyConversationInput | ConversationMemoryCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserConversationMembershipCreateWithoutConversationInput = {
    id?: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutMembershipsInput
    inviter?: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type UserConversationMembershipUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type UserConversationMembershipCreateOrConnectWithoutConversationInput = {
    where: UserConversationMembershipWhereUniqueInput
    create: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput>
  }

  export type UserConversationMembershipCreateManyConversationInputEnvelope = {
    data: UserConversationMembershipCreateManyConversationInput | UserConversationMembershipCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type StoryUpsertWithoutConversationsInput = {
    update: XOR<StoryUpdateWithoutConversationsInput, StoryUncheckedUpdateWithoutConversationsInput>
    create: XOR<StoryCreateWithoutConversationsInput, StoryUncheckedCreateWithoutConversationsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutConversationsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutConversationsInput, StoryUncheckedUpdateWithoutConversationsInput>
  }

  export type StoryUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    characters?: CharacterUpdateManyWithoutStoriesNestedInput
    tags?: TagUpdateManyWithoutStoriesNestedInput
  }

  export type StoryUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutStoriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutStoriesNestedInput
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutOwnedConversationsInput = {
    update: XOR<UserUpdateWithoutOwnedConversationsInput, UserUncheckedUpdateWithoutOwnedConversationsInput>
    create: XOR<UserCreateWithoutOwnedConversationsInput, UserUncheckedCreateWithoutOwnedConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedConversationsInput, UserUncheckedUpdateWithoutOwnedConversationsInput>
  }

  export type UserUpdateWithoutOwnedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationMemoryUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationMemoryWhereUniqueInput
    update: XOR<ConversationMemoryUpdateWithoutConversationInput, ConversationMemoryUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationMemoryCreateWithoutConversationInput, ConversationMemoryUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMemoryUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationMemoryWhereUniqueInput
    data: XOR<ConversationMemoryUpdateWithoutConversationInput, ConversationMemoryUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationMemoryUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationMemoryScalarWhereInput
    data: XOR<ConversationMemoryUpdateManyMutationInput, ConversationMemoryUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationMemoryScalarWhereInput = {
    AND?: ConversationMemoryScalarWhereInput | ConversationMemoryScalarWhereInput[]
    OR?: ConversationMemoryScalarWhereInput[]
    NOT?: ConversationMemoryScalarWhereInput | ConversationMemoryScalarWhereInput[]
    id?: StringFilter<"ConversationMemory"> | string
    conversationId?: StringFilter<"ConversationMemory"> | string
    summary?: StringFilter<"ConversationMemory"> | string
    keyEvents?: JsonFilter<"ConversationMemory">
    messageCount?: IntFilter<"ConversationMemory"> | number
    startMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    endMessageId?: StringNullableFilter<"ConversationMemory"> | string | null
    createdAt?: DateTimeFilter<"ConversationMemory"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationMemory"> | Date | string
  }

  export type UserConversationMembershipUpsertWithWhereUniqueWithoutConversationInput = {
    where: UserConversationMembershipWhereUniqueInput
    update: XOR<UserConversationMembershipUpdateWithoutConversationInput, UserConversationMembershipUncheckedUpdateWithoutConversationInput>
    create: XOR<UserConversationMembershipCreateWithoutConversationInput, UserConversationMembershipUncheckedCreateWithoutConversationInput>
  }

  export type UserConversationMembershipUpdateWithWhereUniqueWithoutConversationInput = {
    where: UserConversationMembershipWhereUniqueInput
    data: XOR<UserConversationMembershipUpdateWithoutConversationInput, UserConversationMembershipUncheckedUpdateWithoutConversationInput>
  }

  export type UserConversationMembershipUpdateManyWithWhereWithoutConversationInput = {
    where: UserConversationMembershipScalarWhereInput
    data: XOR<UserConversationMembershipUpdateManyMutationInput, UserConversationMembershipUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMembersInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMembersInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMembersInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutSentInvitesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
  }

  export type ConversationUpsertWithoutMembersInput = {
    update: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMembersInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
  }

  export type ConversationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSentInvitesInput = {
    update: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type UserUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutConversationParticipationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationParticipationsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationParticipationsInput, UserUncheckedCreateWithoutConversationParticipationsInput>
  }

  export type CharacterCreateWithoutActingParticipationsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    representingParticipations?: ConversationParticipantCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutActingParticipationsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    representingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutRepresentingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutActingParticipationsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutActingParticipationsInput, CharacterUncheckedCreateWithoutActingParticipationsInput>
  }

  export type AssistantCreateWithoutParticipationsInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultCharacter?: CharacterCreateNestedOneWithoutAssistantsUsingAsDefaultInput
    creator: UserCreateNestedOneWithoutAssistantsInput
  }

  export type AssistantUncheckedCreateWithoutParticipationsInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    defaultCharacterId?: string | null
    visibility?: $Enums.Visibility
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantCreateOrConnectWithoutParticipationsInput = {
    where: AssistantWhereUniqueInput
    create: XOR<AssistantCreateWithoutParticipationsInput, AssistantUncheckedCreateWithoutParticipationsInput>
  }

  export type CharacterCreateWithoutRepresentingParticipationsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCharactersInput
    lora?: LoraCreateNestedOneWithoutCharactersInput
    mainAttire?: AttireCreateNestedOneWithoutCharactersUsingAsMainInput
    stories?: StoryCreateNestedManyWithoutCharactersInput
    attires?: AttireCreateNestedManyWithoutCharactersInput
    tags?: TagCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerCreateNestedManyWithoutCharacterInput
    images?: CharacterImageCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantCreateNestedManyWithoutActingCharacterInput
  }

  export type CharacterUncheckedCreateWithoutRepresentingParticipationsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutCharactersInput
    attires?: AttireUncheckedCreateNestedManyWithoutCharactersInput
    tags?: TagUncheckedCreateNestedManyWithoutCharactersInput
    stickers?: CharacterStickerUncheckedCreateNestedManyWithoutCharacterInput
    images?: CharacterImageUncheckedCreateNestedManyWithoutCharacterInput
    assistantsUsingAsDefault?: AssistantUncheckedCreateNestedManyWithoutDefaultCharacterInput
    actingParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutActingCharacterInput
  }

  export type CharacterCreateOrConnectWithoutRepresentingParticipationsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutRepresentingParticipationsInput, CharacterUncheckedCreateWithoutRepresentingParticipationsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationParticipationsInput = {
    update: XOR<UserUpdateWithoutConversationParticipationsInput, UserUncheckedUpdateWithoutConversationParticipationsInput>
    create: XOR<UserCreateWithoutConversationParticipationsInput, UserUncheckedCreateWithoutConversationParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationParticipationsInput, UserUncheckedUpdateWithoutConversationParticipationsInput>
  }

  export type UserUpdateWithoutConversationParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterUpsertWithoutActingParticipationsInput = {
    update: XOR<CharacterUpdateWithoutActingParticipationsInput, CharacterUncheckedUpdateWithoutActingParticipationsInput>
    create: XOR<CharacterCreateWithoutActingParticipationsInput, CharacterUncheckedCreateWithoutActingParticipationsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutActingParticipationsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutActingParticipationsInput, CharacterUncheckedUpdateWithoutActingParticipationsInput>
  }

  export type CharacterUpdateWithoutActingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutActingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type AssistantUpsertWithoutParticipationsInput = {
    update: XOR<AssistantUpdateWithoutParticipationsInput, AssistantUncheckedUpdateWithoutParticipationsInput>
    create: XOR<AssistantCreateWithoutParticipationsInput, AssistantUncheckedCreateWithoutParticipationsInput>
    where?: AssistantWhereInput
  }

  export type AssistantUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: AssistantWhereInput
    data: XOR<AssistantUpdateWithoutParticipationsInput, AssistantUncheckedUpdateWithoutParticipationsInput>
  }

  export type AssistantUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultCharacter?: CharacterUpdateOneWithoutAssistantsUsingAsDefaultNestedInput
    creator?: UserUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type AssistantUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    defaultCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUpsertWithoutRepresentingParticipationsInput = {
    update: XOR<CharacterUpdateWithoutRepresentingParticipationsInput, CharacterUncheckedUpdateWithoutRepresentingParticipationsInput>
    create: XOR<CharacterCreateWithoutRepresentingParticipationsInput, CharacterUncheckedCreateWithoutRepresentingParticipationsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutRepresentingParticipationsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutRepresentingParticipationsInput, CharacterUncheckedUpdateWithoutRepresentingParticipationsInput>
  }

  export type CharacterUpdateWithoutRepresentingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutRepresentingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    memories?: ConversationMemoryUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserCreateWithoutFavoriteCharactersInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoriteCharactersInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteCharactersInput, UserUncheckedCreateWithoutFavoriteCharactersInput>
  }

  export type UserUpsertWithoutFavoriteCharactersInput = {
    update: XOR<UserUpdateWithoutFavoriteCharactersInput, UserUncheckedUpdateWithoutFavoriteCharactersInput>
    create: XOR<UserCreateWithoutFavoriteCharactersInput, UserUncheckedCreateWithoutFavoriteCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteCharactersInput, UserUncheckedUpdateWithoutFavoriteCharactersInput>
  }

  export type UserUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMemoriesInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
    story?: StoryCreateNestedOneWithoutConversationsInput
    owner: UserCreateNestedOneWithoutConversationsInput
    conversationOwner?: UserCreateNestedOneWithoutOwnedConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMemoriesInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    members?: UserConversationMembershipUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMemoriesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMemoriesInput, ConversationUncheckedCreateWithoutMemoriesInput>
  }

  export type ConversationUpsertWithoutMemoriesInput = {
    update: XOR<ConversationUpdateWithoutMemoriesInput, ConversationUncheckedUpdateWithoutMemoriesInput>
    create: XOR<ConversationCreateWithoutMemoriesInput, ConversationUncheckedCreateWithoutMemoriesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMemoriesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMemoriesInput, ConversationUncheckedUpdateWithoutMemoriesInput>
  }

  export type ConversationUpdateWithoutMemoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMemoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserCreateWithoutCreditTransactionsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditTransactionsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
  }

  export type UserUpsertWithoutCreditTransactionsInput = {
    update: XOR<UserUpdateWithoutCreditTransactionsInput, UserUncheckedUpdateWithoutCreditTransactionsInput>
    create: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditTransactionsInput, UserUncheckedUpdateWithoutCreditTransactionsInput>
  }

  export type UserUpdateWithoutCreditTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserPlanCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
    user: UserCreateNestedOneWithoutUserPlansInput
  }

  export type UserPlanUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlanCreateOrConnectWithoutPlanInput = {
    where: UserPlanWhereUniqueInput
    create: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput>
  }

  export type UserPlanCreateManyPlanInputEnvelope = {
    data: UserPlanCreateManyPlanInput | UserPlanCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserPlanUpsertWithWhereUniqueWithoutPlanInput = {
    where: UserPlanWhereUniqueInput
    update: XOR<UserPlanUpdateWithoutPlanInput, UserPlanUncheckedUpdateWithoutPlanInput>
    create: XOR<UserPlanCreateWithoutPlanInput, UserPlanUncheckedCreateWithoutPlanInput>
  }

  export type UserPlanUpdateWithWhereUniqueWithoutPlanInput = {
    where: UserPlanWhereUniqueInput
    data: XOR<UserPlanUpdateWithoutPlanInput, UserPlanUncheckedUpdateWithoutPlanInput>
  }

  export type UserPlanUpdateManyWithWhereWithoutPlanInput = {
    where: UserPlanScalarWhereInput
    data: XOR<UserPlanUpdateManyMutationInput, UserPlanUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutUsageLogsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
  }

  export type UserUpsertWithoutUsageLogsInput = {
    update: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMonthlyBalancesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMonthlyBalancesInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMonthlyBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMonthlyBalancesInput, UserUncheckedCreateWithoutMonthlyBalancesInput>
  }

  export type UserUpsertWithoutMonthlyBalancesInput = {
    update: XOR<UserUpdateWithoutMonthlyBalancesInput, UserUncheckedUpdateWithoutMonthlyBalancesInput>
    create: XOR<UserCreateWithoutMonthlyBalancesInput, UserUncheckedCreateWithoutMonthlyBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMonthlyBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMonthlyBalancesInput, UserUncheckedUpdateWithoutMonthlyBalancesInput>
  }

  export type UserUpdateWithoutMonthlyBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMonthlyBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserPlansInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPlansInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    plusAccessGrants?: UserPlusAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPlansInput, UserUncheckedCreateWithoutUserPlansInput>
  }

  export type PlanCreateWithoutUserPlansInput = {
    id?: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paypalPlanId?: string | null
  }

  export type PlanUncheckedCreateWithoutUserPlansInput = {
    id?: string
    tier: $Enums.PlanTier
    name: string
    priceMonthly: number
    creditsPerMonth: number
    description?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paypalPlanId?: string | null
  }

  export type PlanCreateOrConnectWithoutUserPlansInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutUserPlansInput, PlanUncheckedCreateWithoutUserPlansInput>
  }

  export type UserUpsertWithoutUserPlansInput = {
    update: XOR<UserUpdateWithoutUserPlansInput, UserUncheckedUpdateWithoutUserPlansInput>
    create: XOR<UserCreateWithoutUserPlansInput, UserUncheckedCreateWithoutUserPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPlansInput, UserUncheckedUpdateWithoutUserPlansInput>
  }

  export type UserUpdateWithoutUserPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    plusAccessGrants?: UserPlusAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanUpsertWithoutUserPlansInput = {
    update: XOR<PlanUpdateWithoutUserPlansInput, PlanUncheckedUpdateWithoutUserPlansInput>
    create: XOR<PlanCreateWithoutUserPlansInput, PlanUncheckedCreateWithoutUserPlansInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutUserPlansInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutUserPlansInput, PlanUncheckedUpdateWithoutUserPlansInput>
  }

  export type PlanUpdateWithoutUserPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanUncheckedUpdateWithoutUserPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumPlanTierFieldUpdateOperationsInput | $Enums.PlanTier
    name?: StringFieldUpdateOperationsInput | string
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    creditsPerMonth?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paypalPlanId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPlusAccessGrantsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterCreateNestedManyWithoutCreatorInput
    stories?: StoryCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireCreateNestedManyWithoutOwnerInput
    assistants?: AssistantCreateNestedManyWithoutCreatorInput
    conversations?: ConversationCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceCreateNestedManyWithoutUserInput
    userPlans?: UserPlanCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlusAccessGrantsInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerAccountId: string
    username?: string | null
    email?: string | null
    displayName?: string | null
    fullName?: string | null
    avatarUrl?: string | null
    avatarSource?: $Enums.AvatarSource
    avatarUpdatedAt?: Date | string | null
    birthDate?: Date | string | null
    gender?: string | null
    preferredLanguage?: string | null
    role?: $Enums.UserRole
    lastLoginAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    maxAgeRating?: $Enums.AgeRating
    blockedTags?: UserCreateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedCreateNestedManyWithoutCreatorInput
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    createdAttires?: AttireUncheckedCreateNestedManyWithoutOwnerInput
    assistants?: AssistantUncheckedCreateNestedManyWithoutCreatorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOwnerInput
    conversationParticipations?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    ownedConversations?: ConversationUncheckedCreateNestedManyWithoutConversationOwnerInput
    memberships?: UserConversationMembershipUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: UserConversationMembershipUncheckedCreateNestedManyWithoutInviterInput
    favoriteCharacters?: FavoriteCharacterUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    monthlyBalances?: UserMonthlyBalanceUncheckedCreateNestedManyWithoutUserInput
    userPlans?: UserPlanUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlusAccessGrantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlusAccessGrantsInput, UserUncheckedCreateWithoutPlusAccessGrantsInput>
  }

  export type UserUpsertWithoutPlusAccessGrantsInput = {
    update: XOR<UserUpdateWithoutPlusAccessGrantsInput, UserUncheckedUpdateWithoutPlusAccessGrantsInput>
    create: XOR<UserCreateWithoutPlusAccessGrantsInput, UserUncheckedCreateWithoutPlusAccessGrantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlusAccessGrantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlusAccessGrantsInput, UserUncheckedUpdateWithoutPlusAccessGrantsInput>
  }

  export type UserUpdateWithoutPlusAccessGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUpdateManyWithoutCreatorNestedInput
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlusAccessGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSource?: EnumAvatarSourceFieldUpdateOperationsInput | $Enums.AvatarSource
    avatarUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAgeRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    blockedTags?: UserUpdateblockedTagsInput | $Enums.ContentTag[]
    createdCharacters?: CharacterUncheckedUpdateManyWithoutCreatorNestedInput
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    createdAttires?: AttireUncheckedUpdateManyWithoutOwnerNestedInput
    assistants?: AssistantUncheckedUpdateManyWithoutCreatorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOwnerNestedInput
    conversationParticipations?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    ownedConversations?: ConversationUncheckedUpdateManyWithoutConversationOwnerNestedInput
    memberships?: UserConversationMembershipUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: UserConversationMembershipUncheckedUpdateManyWithoutInviterNestedInput
    favoriteCharacters?: FavoriteCharacterUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    monthlyBalances?: UserMonthlyBalanceUncheckedUpdateManyWithoutUserNestedInput
    userPlans?: UserPlanUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterCreateManyCreatorInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    loraId?: string | null
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryCreateManyAuthorInput = {
    id?: string
    title: string
    synopsis?: string | null
    initialText?: string | null
    coverImage?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: $Enums.AgeRating
    contentTags?: StoryCreatecontentTagsInput | $Enums.ContentTag[]
    visibility?: $Enums.Visibility
    contentVersion?: number
    originalLanguageCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttireCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    gender?: string | null
    promptHead?: string | null
    promptBody?: string | null
    promptFull?: string | null
    previewImageUrl?: string | null
    originalLanguageCode?: string | null
    visibility?: $Enums.Visibility
    ageRating?: $Enums.AgeRating
    contentTags?: AttireCreatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    defaultCharacterId?: string | null
    visibility?: $Enums.Visibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
  }

  export type ConversationParticipantCreateManyUserInput = {
    id?: string
    conversationId: string
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationCreateManyConversationOwnerInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    storyId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    allowUserInvites?: boolean
    requireApproval?: boolean
  }

  export type UserConversationMembershipCreateManyUserInput = {
    id?: string
    conversationId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type UserConversationMembershipCreateManyInviterInput = {
    id?: string
    conversationId: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type FavoriteCharacterCreateManyUserInput = {
    id?: string
    characterId: string
    createdAt?: Date | string
  }

  export type CreditTransactionCreateManyUserInput = {
    id?: string
    transactionType: $Enums.CreditTransactionType
    amountCredits: number
    balanceAfter?: number | null
    notes?: string | null
    relatedUsageLogId?: string | null
    relatedPlanId?: string | null
    timestamp?: Date | string
  }

  export type UsageLogCreateManyUserInput = {
    id?: string
    conversationId?: string | null
    serviceType: string
    providerName?: string | null
    modelName?: string | null
    inputTokens?: number | null
    outputTokens?: number | null
    charactersProcessed?: number | null
    imagesProcessed?: number | null
    costUsd?: number | null
    creditsConsumed?: number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: boolean
    processedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type UserMonthlyBalanceCreateManyUserInput = {
    id?: string
    monthStartDate: Date | string
    startingBalance: number
    creditsGranted?: number
    creditsSpent?: number
    endingBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPlanCreateManyUserInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlusAccessCreateManyUserInput = {
    id?: string
    grantedBy?: string | null
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutStoriesNestedInput
    tags?: TagUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutStoriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttireUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charactersUsingAsMain?: CharacterUpdateManyWithoutMainAttireNestedInput
    characters?: CharacterUpdateManyWithoutAttiresNestedInput
  }

  export type AttireUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charactersUsingAsMain?: CharacterUncheckedUpdateManyWithoutMainAttireNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutAttiresNestedInput
  }

  export type AttireUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultCharacter?: CharacterUpdateOneWithoutAssistantsUsingAsDefaultNestedInput
    participations?: ConversationParticipantUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    defaultCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: ConversationParticipantUncheckedUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    defaultCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    actingCharacter?: CharacterUpdateOneWithoutActingParticipationsNestedInput
    actingAssistant?: AssistantUpdateOneWithoutParticipationsNestedInput
    representingCharacter?: CharacterUpdateOneWithoutRepresentingParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutConversationOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneWithoutConversationsNestedInput
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutConversationOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMembersNestedInput
    inviter?: UserUpdateOneWithoutSentInvitesNestedInput
  }

  export type UserConversationMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type UserConversationMembershipUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FavoriteCharacterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCharacterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCharacterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    amountCredits?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    relatedUsageLogId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    charactersProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    imagesProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableFloatFieldUpdateOperationsInput | number | null
    creditsConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    additionalMetadata?: NullableJsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyBalanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startingBalance?: FloatFieldUpdateOperationsInput | number
    creditsGranted?: FloatFieldUpdateOperationsInput | number
    creditsSpent?: FloatFieldUpdateOperationsInput | number
    endingBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: PlanUpdateOneRequiredWithoutUserPlansNestedInput
  }

  export type UserPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlusAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlusAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPlusAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateManyLoraInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    mainAttireId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutLoraInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutLoraInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutLoraInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateManyMainAttireInput = {
    id?: string
    firstName: string
    lastName?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    style?: $Enums.VisualStyle | null
    reference?: string | null
    physicalCharacteristics?: string | null
    personality?: string | null
    history?: string | null
    visibility?: $Enums.Visibility
    isSystemCharacter?: boolean
    originalLanguageCode?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterCreatecontentTagsInput | $Enums.ContentTag[]
    userId: string
    loraId?: string | null
    contentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutMainAttireInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutMainAttireInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutMainAttireInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUpdateWithoutAttiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAttiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutAttiresInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    stories?: StoryUpdateManyWithoutCharactersNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutCharactersNestedInput
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    characters?: CharacterUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerCreateManyCharacterInput = {
    id?: string
    emotionTag?: string | null
    actionTag?: string | null
    imageUrl?: string | null
    promptUsed?: string | null
    status?: $Enums.StickerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterImageCreateManyCharacterInput = {
    id?: string
    type: $Enums.ImageType
    url: string
    key?: string | null
    width?: number | null
    height?: number | null
    sizeBytes?: number | null
    contentType?: string | null
    ageRating?: $Enums.AgeRating
    contentTags?: CharacterImageCreatecontentTagsInput | $Enums.ContentTag[]
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssistantCreateManyDefaultCharacterInput = {
    id?: string
    name: string
    description?: string | null
    instructions: string
    visibility?: $Enums.Visibility
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationParticipantCreateManyActingCharacterInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateManyRepresentingCharacterInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type StoryUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    tags?: TagUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutStoriesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    synopsis?: NullableStringFieldUpdateOperationsInput | string | null
    initialText?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: StoryUpdatecontentTagsInput | $Enums.ContentTag[]
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    contentVersion?: IntFieldUpdateOperationsInput | number
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttireUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCreatedAttiresNestedInput
    charactersUsingAsMain?: CharacterUpdateManyWithoutMainAttireNestedInput
  }

  export type AttireUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charactersUsingAsMain?: CharacterUncheckedUpdateManyWithoutMainAttireNestedInput
  }

  export type AttireUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    promptHead?: NullableStringFieldUpdateOperationsInput | string | null
    promptBody?: NullableStringFieldUpdateOperationsInput | string | null
    promptFull?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: AttireUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterStickerUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    emotionTag?: NullableStringFieldUpdateOperationsInput | string | null
    actionTag?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    promptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStickerStatusFieldUpdateOperationsInput | $Enums.StickerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterImageUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumImageTypeFieldUpdateOperationsInput | $Enums.ImageType
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterImageUpdatecontentTagsInput | $Enums.ContentTag[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssistantUpdateWithoutDefaultCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutAssistantsNestedInput
    participations?: ConversationParticipantUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantUncheckedUpdateWithoutDefaultCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: ConversationParticipantUncheckedUpdateManyWithoutActingAssistantNestedInput
  }

  export type AssistantUncheckedUpdateManyWithoutDefaultCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutActingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneWithoutConversationParticipationsNestedInput
    actingAssistant?: AssistantUpdateOneWithoutParticipationsNestedInput
    representingCharacter?: CharacterUpdateOneWithoutRepresentingParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutActingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutActingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutRepresentingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneWithoutConversationParticipationsNestedInput
    actingCharacter?: CharacterUpdateOneWithoutActingParticipationsNestedInput
    actingAssistant?: AssistantUpdateOneWithoutParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutRepresentingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyStoryInput = {
    id?: string
    title?: string
    isTitleUserEdited?: boolean
    isTitleSystemEdited?: boolean
    projectId?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string | null
    titleLastUpdatedAt?: Date | string | null
    memoryLastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    isMultiUser?: boolean
    maxUsers?: number
    ownerUserId?: string | null
    allowUserInvites?: boolean
    requireApproval?: boolean
  }

  export type CharacterUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCharactersNestedInput
    lora?: LoraUpdateOneWithoutCharactersNestedInput
    mainAttire?: AttireUpdateOneWithoutCharactersUsingAsMainNestedInput
    attires?: AttireUpdateManyWithoutCharactersNestedInput
    tags?: TagUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attires?: AttireUncheckedUpdateManyWithoutCharactersNestedInput
    tags?: TagUncheckedUpdateManyWithoutCharactersNestedInput
    stickers?: CharacterStickerUncheckedUpdateManyWithoutCharacterNestedInput
    images?: CharacterImageUncheckedUpdateManyWithoutCharacterNestedInput
    assistantsUsingAsDefault?: AssistantUncheckedUpdateManyWithoutDefaultCharacterNestedInput
    actingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutActingCharacterNestedInput
    representingParticipations?: ConversationParticipantUncheckedUpdateManyWithoutRepresentingCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableEnumVisualStyleFieldUpdateOperationsInput | $Enums.VisualStyle | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    physicalCharacteristics?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isSystemCharacter?: BoolFieldUpdateOperationsInput | boolean
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: CharacterUpdatecontentTagsInput | $Enums.ContentTag[]
    userId?: StringFieldUpdateOperationsInput | string
    loraId?: NullableStringFieldUpdateOperationsInput | string | null
    mainAttireId?: NullableStringFieldUpdateOperationsInput | string | null
    contentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ageRating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    contentTags?: TagUpdatecontentTagsInput | $Enums.ContentTag[]
    originalLanguageCode?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    searchable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneRequiredWithoutConversationsNestedInput
    conversationOwner?: UserUpdateOneWithoutOwnedConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    memories?: ConversationMemoryUncheckedUpdateManyWithoutConversationNestedInput
    members?: UserConversationMembershipUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isTitleUserEdited?: BoolFieldUpdateOperationsInput | boolean
    isTitleSystemEdited?: BoolFieldUpdateOperationsInput | boolean
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memoryLastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    isMultiUser?: BoolFieldUpdateOperationsInput | boolean
    maxUsers?: IntFieldUpdateOperationsInput | number
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    allowUserInvites?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantCreateManyActingAssistantInput = {
    id?: string
    conversationId: string
    userId?: string | null
    actingCharacterId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateWithoutActingAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneWithoutConversationParticipationsNestedInput
    actingCharacter?: CharacterUpdateOneWithoutActingParticipationsNestedInput
    representingCharacter?: CharacterUpdateOneWithoutRepresentingParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutActingAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutActingAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    id?: string
    userId?: string | null
    actingCharacterId?: string | null
    actingAssistantId?: string | null
    representingCharacterId?: string | null
    configOverride?: string | null
    joinedAt?: Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    senderType: $Enums.SenderType
    content: string
    attachments?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ConversationMemoryCreateManyConversationInput = {
    id?: string
    summary: string
    keyEvents: JsonNullValueInput | InputJsonValue
    messageCount: number
    startMessageId?: string | null
    endMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConversationMembershipCreateManyConversationInput = {
    id?: string
    userId: string
    role?: $Enums.MembershipRole
    canWrite?: boolean
    canInvite?: boolean
    canModerate?: boolean
    joinedAt?: Date | string
    invitedBy?: string | null
    isActive?: boolean
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutConversationParticipationsNestedInput
    actingCharacter?: CharacterUpdateOneWithoutActingParticipationsNestedInput
    actingAssistant?: AssistantUpdateOneWithoutParticipationsNestedInput
    representingCharacter?: CharacterUpdateOneWithoutRepresentingParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    actingAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    representingCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    configOverride?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemoryUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    keyEvents?: JsonNullValueInput | InputJsonValue
    messageCount?: IntFieldUpdateOperationsInput | number
    startMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    endMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConversationMembershipUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    inviter?: UserUpdateOneWithoutSentInvitesNestedInput
  }

  export type UserConversationMembershipUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserConversationMembershipUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canInvite?: BoolFieldUpdateOperationsInput | boolean
    canModerate?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPlanCreateManyPlanInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastCreditsGrantedAt?: Date | string | null
    paypalSubscriptionId?: string | null
  }

  export type UserPlanUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserPlansNestedInput
  }

  export type UserPlanUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPlanUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCreditsGrantedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}