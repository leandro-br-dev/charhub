# Credits Service Documentation

**Purpose**: Credit-based monetization system for premium features.

**Related Files**:
- Service: `backend/src/services/creditService.ts`
- Types: `backend/src/types/credits.ts`
- Errors: `backend/src/errors/CreditErrors.ts`
- Costs: `backend/src/data/service-costs.json`
- Routes: `backend/src/routes/v1/credits.ts`
- Used by: Chat, image generation, story generation, premium features

## Overview

The credits system enables monetization of premium features by requiring users to spend credits for certain operations.

### Key Features

- **Deduct credits** for premium operations (chat, image generation, etc.)
- **Add credits** for purchases, rewards, bonuses
- **Transaction history** with full audit trail
- **Balance validation** before operations
- **Error handling** for insufficient credits

### Credit Flow

```
User requests premium feature
       ↓
Check sufficient credits
       ↓
Perform operation
       ↓
Deduct credits
       ↓
Record transaction
       ↓
Return result
```

## Architecture

### Database Schema

```prisma
model CreditTransaction {
  id            String   @id @default(uuid())
  userId        String
  amount        Int      // Positive for addition, negative for deduction
  balanceBefore Int
  balanceAfter  Int
  reason        String   // Transaction reason enum
  metadata      Json?    // Additional context
  createdAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdAt])
}

model User {
  id                String              @id @default(uuid())
  creditBalance     Int                 @default(200) // Initial bonus
  creditTransactions CreditTransaction[]
}
```

### Transaction Reasons

**Deductions**:
- `CHAT_MESSAGE` - Sending chat message
- `IMAGE_GENERATION` - Generating AI image
- `PREMIUM_FEATURE` - Using premium feature
- `STORY_GENERATION` - Generating story

**Additions**:
- `INITIAL_BONUS` - New user signup bonus
- `DAILY_REWARD` - Daily login reward
- `FIRST_CHAT_REWARD` - First chat completion reward
- `PURCHASE` - User purchased credits
- `REFUND` - Refund for failed operation
- `ADMIN_GRANT` - Manual credit grant by admin

### Credit Costs

Costs are configured in `backend/src/data/service-costs.json`:

| Feature | Cost | Source |
|---------|------|--------|
| Chat message | 1 credit | `service-costs.json` |
| Image generation | 10 credits | `service-costs.json` |
| Story generation | 5 credits | `service-costs.json` |
| Premium feature | 5 credits | `service-costs.json` |

**To update costs**: Edit `backend/src/data/service-costs.json`

## API/Usage

### Check Credits Before Operation

```typescript
import { requireCredits } from '../services/creditService';

async function sendChatMessage(userId: string, message: string) {
  // 1. Check if user has sufficient credits
  await requireCredits(userId, 1); // Throws if < 1 credit

  // 2. Perform operation
  const result = await chatService.send(message);

  // 3. Deduct credits
  await deductCredits(userId, 1, 'CHAT_MESSAGE', {
    messageId: result.id,
    conversationId: result.conversationId
  });

  return result;
}
```

### Deduct Credits

```typescript
import { deductCredits } from '../services/creditService';

await deductCredits(userId, 10, 'IMAGE_GENERATION', {
  imageUrl: 'https://...',
  prompt: 'A beautiful sunset'
});
```

**Parameters**:
- `userId` - User ID
- `amount` - Credits to deduct (positive number)
- `reason` - Transaction reason (enum)
- `metadata` - Optional JSON object with additional context

### Add Credits

```typescript
import { addCredits } from '../services/creditService';

// Signup bonus
await addCredits(userId, 200, 'INITIAL_BONUS');

// Daily reward
await addCredits(userId, 20, 'DAILY_REWARD');

// Purchase
await addCredits(userId, 100, 'PURCHASE', {
  transactionId: 'txn_123',
  paymentMethod: 'paypal'
});

// Refund
await addCredits(userId, 10, 'REFUND', {
  originalTransactionId: 'txn_456',
  reason: 'Image generation failed'
});
```

### Get User Balance

```typescript
import { getUserBalance } from '../services/creditService';

const balance = await getUserBalance(userId);
console.log(`User has ${balance} credits`);
```

## Error Handling

```typescript
import { requireCredits, InsufficientCreditsError } from '../services/creditService';

try {
  await requireCredits(userId, 10);
  // ... perform operation
} catch (error) {
  if (error instanceof InsufficientCreditsError) {
    return res.status(402).json({ // 402 Payment Required
      error: 'INSUFFICIENT_CREDITS',
      required: 10,
      current: error.currentBalance,
      message: 'You need 10 credits to use this feature'
    });
  }
  throw error;
}
```

**HTTP Status**: Use `402 Payment Required` for insufficient credits errors.

## Frontend Integration

### Check Balance Before Operation

```typescript
import { api } from '@/lib/api';

async function handlePremiumFeature() {
  // Get user balance
  const { balance } = await api.get('/api/v1/credits/balance');

  if (balance < 10) {
    toast.error('Insufficient credits. You need 10 credits.');
    return;
  }

  // Proceed with operation
  await api.post('/api/v1/premium-feature');
}
```

### Keep Balance Synchronized

Use TanStack Query for automatic refetching:

```typescript
import { useQuery, useQueryClient } from '@tanstack/react-query';

export function useCreditBalance() {
  return useQuery({
    queryKey: ['credits', 'balance'],
    queryFn: async () => {
      const res = await api.get('/api/v1/credits/balance');
      return res.data.balance;
    },
    refetchInterval: 30000 // Refetch every 30s
  });
}

// Invalidate after credit operations
const queryClient = useQueryClient();
await api.post('/api/v1/chat/send');
queryClient.invalidateQueries({ queryKey: ['credits', 'balance'] });
```

## Usage Example: Complete Flow

```typescript
import { requireCredits, deductCredits, addCredits, getUserBalance } from '../services/creditService';
import { InsufficientCreditsError } from '../errors/CreditErrors';

class ChatService {
  async sendMessage(userId: string, message: string) {
    const cost = 1; // 1 credit per message

    // 1. Validate balance
    try {
      await requireCredits(userId, cost);
    } catch (error) {
      if (error instanceof InsufficientCreditsError) {
        throw new Error(`Insufficient credits. Need ${cost}, have ${error.currentBalance}`);
      }
      throw error;
    }

    // 2. Send message
    const result = await this.chatProvider.send(message);

    // 3. Deduct credits
    await deductCredits(userId, cost, 'CHAT_MESSAGE', {
      messageId: result.id,
      conversationId: result.conversationId,
      messageLength: message.length
    });

    return result;
  }

  async purchaseCredits(userId: string, amount: number, paymentDetails: any) {
    // Process payment...
    const paymentResult = await this.paymentService.charge(amount, paymentDetails);

    // Add credits to user balance
    await addCredits(userId, amount, 'PURCHASE', {
      transactionId: paymentResult.transactionId,
      paymentMethod: paymentDetails.method
    });

    return paymentResult;
  }
}
```

## Dependencies

- **Prisma**: Database ORM for credit operations
- **User Service**: For user validation
- **Payment Service**: For credit purchases

## Important Notes

### Best Practices

**DO**:
- Always check credits before operation (`requireCredits`)
- Deduct credits after successful operation
- Include relevant metadata in transactions
- Use appropriate transaction reason enum
- Handle `InsufficientCreditsError` gracefully

**DON'T**:
- Deduct credits before operation (only after success)
- Forget to handle insufficient credits errors
- Skip transaction metadata (important for debugging)
- Hardcode credit costs (use `service-costs.json`)

### Initial Bonus

New users automatically receive 200 credits (configured in Prisma schema default).

### Updating Costs

To change credit costs for features:

1. Edit `backend/src/data/service-costs.json`
2. Update service logic to read from config (currently hardcoded in some places)
3. Consider making costs configurable per feature

## Testing

```typescript
import { requireCredits, deductCredits, addCredits, getUserBalance } from '../services/creditService';
import { InsufficientCreditsError } from '../errors/CreditErrors';

describe('Credits Service', () => {
  it('should deduct credits and create transaction', async () => {
    const userId = 'user_123';

    // Add initial credits
    await addCredits(userId, 100, 'INITIAL_BONUS');

    // Deduct credits
    await deductCredits(userId, 10, 'CHAT_MESSAGE');

    // Verify balance
    const balance = await getUserBalance(userId);
    expect(balance).toBe(90);
  });

  it('should throw error on insufficient credits', async () => {
    const userId = 'user_456';
    await addCredits(userId, 5, 'INITIAL_BONUS');

    await expect(
      requireCredits(userId, 10)
    ).rejects.toThrow(InsufficientCreditsError);
  });

  it('should record transaction with metadata', async () => {
    const userId = 'user_789';
    await addCredits(userId, 100, 'INITIAL_BONUS');

    await deductCredits(userId, 10, 'IMAGE_GENERATION', {
      prompt: 'A beautiful sunset',
      model: 'dall-e-3'
    });

    const transactions = await prisma.creditTransaction.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    expect(transactions[0].metadata).toEqual({
      prompt: 'A beautiful sunset',
      model: 'dall-e-3'
    });
  });
});
```

## See Also

- **Implementation Spec**: `docs/05-business/planning/features/implemented/credits-system.md`
- **API Reference**: `backend/src/routes/v1/credits.ts`
- **Service Costs**: `backend/src/data/service-costs.json`
- **Credit Verification Guide**: `docs/02-guides/development/credit-verification.md`
- **Payment Service**: `backend/src/services/payments/.docs.md`
