# Translation Service Documentation

**Purpose**: Automatic content translation with multi-level caching and LLM integration.

**Related Files**:
- Service: `backend/src/services/translation/translationService.ts`
- Metrics: `backend/src/services/translation/translationMetrics.ts`
- Middleware: `backend/src/middleware/translationMiddleware.ts`
- Routes: `backend/src/routes/v1/admin/translations.ts`
- Used by: Character, Story, Attire, Tag APIs

## Overview

The translation service provides automatic translation of user-generated content (UGC) with intelligent caching to minimize LLM costs.

### Key Features

- **Automatic translation** based on user language preference
- **Multi-level cache**: Redis (L1) → Database (L2) → LLM (L3)
- **Support for all 11 platform languages**
- **Content versioning** for cache invalidation
- **Metrics and analytics** for translation performance

### Translation Flow

```
User request (with language header)
       ↓
API returns content with originalLanguageCode
       ↓
Middleware detects language mismatch
       ↓
Check cache L1 (Redis, TTL: 1 hour)
       ↓ MISS
Check cache L2 (Database, permanent)
       ↓ MISS
Generate translation via LLM
       ↓
Store in L2 and L1
       ↓
Return translated content
```

## Architecture

### Cache Levels

**L1 - Redis (Fast Cache)**
- TTL: 1 hour (configurable)
- Response time: ~1-5ms
- Purpose: Reduce database load for frequently accessed content

**L2 - Database (Persistent Cache)**
- Storage: Permanent until content version changes
- Response time: ~10-50ms
- Purpose: Avoid LLM calls for previously translated content

**L3 - LLM (Generation)**
- Provider: Gemini 2.5 Flash Lite (default)
- Response time: ~500-2000ms
- Purpose: Generate new translations

### Content Versioning

Content includes `contentVersion` field for cache invalidation:

```prisma
model YourModel {
  id                   String  @id @default(uuid())
  name                 String
  originalLanguageCode String?  @default("en-US")
  contentVersion       Int     @default(1) // ← Increment to invalidate cache
}
```

When translatable fields change, increment `contentVersion` to invalidate all cached translations.

### Supported Languages

- en-US (English)
- pt-BR (Portuguese - Brazil)
- es-ES (Spanish)
- fr-FR (French)
- de-DE (German)
- it-IT (Italian)
- ja-JP (Japanese)
- ko-KR (Korean)
- zh-CN (Chinese - Simplified)
- ru-RU (Russian)
- ar-SA (Arabic)

## Configuration

### Environment Variables

```bash
# Redis (required for L1 cache)
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# Translation
TRANSLATION_DEFAULT_PROVIDER=gemini
TRANSLATION_DEFAULT_MODEL=gemini-2.5-flash-lite
TRANSLATION_CACHE_TTL=3600  # 1 hour in seconds
```

### Translatable Fields Configuration

Edit `backend/src/middleware/translationMiddleware.ts`:

```typescript
const TRANSLATABLE_FIELDS: Record<string, string[]> = {
  Character: ['personality', 'history', 'physicalCharacteristics'],
  Story: ['title', 'synopsis', 'initialText'],
  Attire: ['name', 'description'],
  Tag: ['name', 'description'],
  // Add your model here
  YourModel: ['name', 'description'],
};
```

### Content Type Detection

Add detection logic in `translationMiddleware.ts`:

```typescript
function inferContentType(data: any): string | null {
  // Character detection
  if ('firstName' in data && 'gender' in data) {
    return 'Character';
  }

  // Your model detection
  if ('yourUniqueField' in data && 'anotherField' in data) {
    return 'YourModel';
  }

  return null;
}
```

## API/Usage

### Adding Translation to New API

**Step 1: Update Schema**

```prisma
model YourModel {
  id                   String  @id @default(uuid())
  name                 String
  description          String?
  originalLanguageCode String?  @default("en-US")
  contentVersion       Int      @default(1)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}
```

**Step 2: Configure Middleware**

```typescript
// backend/src/middleware/translationMiddleware.ts
const TRANSLATABLE_FIELDS: Record<string, string[]> = {
  // ... existing models ...
  YourModel: ['name', 'description'],
};
```

**Step 3: Apply to Route**

```typescript
import { translationMiddleware } from '../../middleware/translationMiddleware';

router.get('/:id',
  optionalAuth,
  translationMiddleware(), // ← Add middleware
  async (req, res) => {
    const item = await yourService.getById(id);
    res.json({ success: true, data: item });
  }
);
```

**Step 4: Invalidate Cache on Update**

```typescript
import { translationService } from '../services/translation/translationService';

export async function updateYourModel(id: string, data: any) {
  const translatableFields = ['name', 'description'];
  const hasTranslatableChanges = translatableFields.some(field => field in data);

  // Increment version if translatable fields changed
  if (hasTranslatableChanges) {
    data.contentVersion = { increment: 1 };
  }

  const updated = await prisma.yourModel.update({
    where: { id },
    data,
  });

  // Invalidate cache
  if (hasTranslatableChanges) {
    await translationService.invalidateTranslations('YourModel', id);
  }

  return updated;
}
```

### Manual Translation

```typescript
import { translationService } from '../services/translation/translationService';

// Translate content manually
const translated = await translationService.translate({
  contentType: 'Character',
  contentId: characterId,
  targetLanguage: 'pt-BR',
  fields: {
    personality: character.personality,
    history: character.history
  }
});
```

### Cache Invalidation

```typescript
import { translationService } from '../services/translation/translationService';

// Invalidate all translations for a content item
await translationService.invalidateTranslations('Character', characterId);

// Invalidate specific field
await translationService.invalidateFieldTranslation(
  'Character',
  characterId,
  'personality',
  'pt-BR'
);
```

## Frontend Integration

**No frontend changes required!**

The axios interceptor in `frontend/src/lib/api.ts` automatically sends the `X-User-Language` header with every request.

Translation is completely transparent to the frontend - it simply receives the translated content.

## Dependencies

- **Redis**: L1 cache for fast translation retrieval
- **Prisma**: L2 cache for persistent translation storage
- **LLM (Gemini/OpenAI)**: Translation generation

## Important Notes

### Performance

- **Cache Hit (Redis)**: ~1-5ms
- **Cache Hit (Database)**: ~10-50ms
- **LLM Translation**: ~500-2000ms (first time only)
- **TTL Redis**: 1 hour (configurable via `TRANSLATION_CACHE_TTL`)

### Costs

- **Redis Cache**: Free (local)
- **Database Storage**: ~500 bytes per translation
- **LLM**: ~$0.00001 per translation (Gemini 2.5 Flash Lite)

With efficient caching, LLM costs are minimal after the first translation.

### Best Practices

**DO**:
- Set `originalLanguageCode` when creating content
- Increment `contentVersion` when updating translatable fields
- Invalidate cache after content updates
- Use specific content type detection
- Monitor cache hit rate via metrics endpoint

**DON'T**:
- Skip `contentVersion` increment on updates
- Forget to invalidate cache after edits
- Create overly broad content type detection
- Translate without caching (wastes money)

### Language Detection

User language is detected from (in priority order):
1. `X-User-Language` header (set by frontend)
2. `Accept-Language` header from browser
3. `preferredLanguage` field in User model

## Admin Endpoints

### Get Translation Metrics

```bash
GET /api/v1/admin/translations/metrics
```

Returns:
- Total translations (active, outdated, failed)
- Cache hit rate
- Average translation time
- Most translated language pairs
- Translations by content type

### Get Popular Content

```bash
GET /api/v1/admin/translations/popular/:contentType?limit=10
```

Returns most translated content for a specific type.

## Testing

```typescript
import { translationService } from '../services/translation/translationService';

describe('Translation Service', () => {
  it('should cache translation in Redis and Database', async () => {
    const result = await translationService.translate({
      contentType: 'Character',
      contentId: 'char_123',
      targetLanguage: 'pt-BR',
      fields: { personality: 'Friendly assistant' }
    });

    // Verify Redis cache
    const redisKey = `translation:Character:char_123:pt-BR`;
    const cached = await redis.get(redisKey);
    expect(cached).toBeDefined();

    // Verify database cache
    const dbTranslation = await prisma.translation.findUnique({
      where: {
        contentType_contentId_language: {
          contentType: 'Character',
          contentId: 'char_123',
          language: 'pt-BR'
        }
      }
    });
    expect(dbTranslation).toBeDefined();
  });

  it('should use cached translation on second request', async () => {
    const firstCall = await translationService.translate({...});
    const secondCall = await translationService.translate({...});

    // Second call should be much faster (cache hit)
    expect(secondCall.duration).toBeLessThan(firstCall.duration);
  });

  it('should invalidate cache when contentVersion increments', async () => {
    await translationService.translate({
      contentType: 'Character',
      contentId: 'char_123',
      targetLanguage: 'pt-BR',
      fields: { personality: 'Original' }
    });

    // Update content (increments contentVersion)
    await prisma.character.update({
      where: { id: 'char_123' },
      data: {
        personality: 'Updated',
        contentVersion: { increment: 1 }
      }
    });

    // Invalidate cache
    await translationService.invalidateTranslations('Character', 'char_123');

    // Verify cache is empty
    const cached = await redis.get(`translation:Character:char_123:pt-BR`);
    expect(cached).toBeNull();
  });
});
```

## Troubleshooting

**Translations not appearing**
- Check middleware is applied to route
- Verify `X-User-Language` header is sent
- Check content type detection logic

**Cache not working**
- Verify Redis is running: `docker compose ps redis`
- Check Redis connection in backend logs
- Verify `TRANSLATION_CACHE_TTL` is set

**High LLM costs**
- Check cache hit rate via metrics endpoint
- Verify `contentVersion` is incremented on updates
- Ensure cache invalidation is called after edits

**Translations outdated**
- Verify `contentVersion` is incremented
- Check `invalidateTranslations()` is called
- Consider reducing `TRANSLATION_CACHE_TTL`

## See Also

- **Tag System**: `backend/src/data/tags/.docs.md` - For tag translations
- **Database Schema**: `backend/prisma/schema.prisma`
- **Admin API**: `backend/src/routes/v1/admin/translations.ts`
- **i18next Documentation**: https://www.i18next.com/
