import crypto from 'crypto';
import { logger } from '../config/logger';

// AES-256-GCM encryption for messages
// Algorithm: AES-256-GCM (Galois/Counter Mode) - provides both confidentiality and authenticity
// Key: 256-bit (32 bytes) - derived from environment variable
// IV: 96-bit (12 bytes) - randomly generated for each message
// Auth Tag: 128-bit (16 bytes) - automatically generated by GCM mode

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12; // 12 bytes (96 bits) is recommended for GCM
const AUTH_TAG_LENGTH = 16; // 16 bytes (128 bits)
const KEY_LENGTH = 32; // 32 bytes (256 bits)

/**
 * Get encryption key from environment variable
 * The key should be a 64-character hex string (32 bytes when converted)
 */
function getEncryptionKey(): Buffer {
  const keyHex = process.env.MESSAGE_ENCRYPTION_KEY;

  if (!keyHex) {
    throw new Error('MESSAGE_ENCRYPTION_KEY environment variable is not set');
  }

  // Validate key format (should be 64 hex characters = 32 bytes)
  if (!/^[0-9a-f]{64}$/i.test(keyHex)) {
    throw new Error('MESSAGE_ENCRYPTION_KEY must be a 64-character hexadecimal string');
  }

  return Buffer.from(keyHex, 'hex');
}

/**
 * Encrypt a message using AES-256-GCM
 *
 * @param plaintext - The message to encrypt
 * @returns Encrypted message in format: iv:authTag:ciphertext (all hex-encoded)
 */
export function encryptMessage(plaintext: string): string {
  try {
    const key = getEncryptionKey();

    // Generate a random IV for this message
    const iv = crypto.randomBytes(IV_LENGTH);

    // Create cipher
    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);

    // Encrypt the message
    let ciphertext = cipher.update(plaintext, 'utf8', 'hex');
    ciphertext += cipher.final('hex');

    // Get the authentication tag
    const authTag = cipher.getAuthTag();

    // Combine IV + Auth Tag + Ciphertext (all in hex)
    // Format: <iv>:<authTag>:<ciphertext>
    const encrypted = `${iv.toString('hex')}:${authTag.toString('hex')}:${ciphertext}`;

    logger.debug({
      ivLength: iv.length,
      authTagLength: authTag.length,
      ciphertextLength: ciphertext.length,
      totalLength: encrypted.length
    }, 'Message encrypted successfully');

    return encrypted;
  } catch (error) {
    logger.error({ error }, 'Failed to encrypt message');
    throw new Error('Message encryption failed');
  }
}

/**
 * Decrypt a message using AES-256-GCM
 *
 * @param encrypted - Encrypted message in format: iv:authTag:ciphertext
 * @returns Decrypted plaintext message
 */
export function decryptMessage(encrypted: string): string {
  try {
    const key = getEncryptionKey();

    // Split the encrypted message into its components
    const parts = encrypted.split(':');

    if (parts.length !== 3) {
      throw new Error('Invalid encrypted message format');
    }

    const [ivHex, authTagHex, ciphertext] = parts;

    // Convert hex strings back to buffers
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');

    // Validate component lengths
    if (iv.length !== IV_LENGTH) {
      throw new Error(`Invalid IV length: expected ${IV_LENGTH}, got ${iv.length}`);
    }

    if (authTag.length !== AUTH_TAG_LENGTH) {
      throw new Error(`Invalid auth tag length: expected ${AUTH_TAG_LENGTH}, got ${authTag.length}`);
    }

    // Create decipher
    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);

    // Decrypt the message
    let plaintext = decipher.update(ciphertext, 'hex', 'utf8');
    plaintext += decipher.final('utf8');

    logger.debug({
      ivLength: iv.length,
      authTagLength: authTag.length,
      plaintextLength: plaintext.length
    }, 'Message decrypted successfully');

    return plaintext;
  } catch (error) {
    logger.error({ error }, 'Failed to decrypt message');
    throw new Error('Message decryption failed');
  }
}

/**
 * Generate a new encryption key
 * This should be run once and the key stored securely in environment variables
 *
 * @returns 64-character hex string (32 bytes)
 */
export function generateEncryptionKey(): string {
  const key = crypto.randomBytes(KEY_LENGTH);
  return key.toString('hex');
}

/**
 * Check if a string is encrypted (has the expected format)
 *
 * @param content - Content to check
 * @returns true if content appears to be encrypted
 */
export function isEncrypted(content: string): boolean {
  // Check if it matches the format: <hex>:<hex>:<hex>
  const parts = content.split(':');

  if (parts.length !== 3) {
    return false;
  }

  const [ivHex, authTagHex, ciphertext] = parts;

  // Validate that all parts are valid hex strings
  const hexRegex = /^[0-9a-f]+$/i;

  return (
    hexRegex.test(ivHex) &&
    hexRegex.test(authTagHex) &&
    hexRegex.test(ciphertext) &&
    ivHex.length === IV_LENGTH * 2 && // hex is 2 chars per byte
    authTagHex.length === AUTH_TAG_LENGTH * 2
  );
}
