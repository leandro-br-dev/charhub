generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  GOOGLE
  FACEBOOK
}

enum UserRole {
  BASIC
  PREMIUM
  ADMIN
}

// Age-based content rating system (similar to movie/anime ratings)
enum AgeRating {
  L // Livre (All ages) - General audiences
  TEN // 10+ - Mild themes
  TWELVE // 12+ - Moderate themes
  FOURTEEN // 14+ - More mature themes, mild sexual references
  SIXTEEN // 16+ - Strong themes, explicit language, moderate violence
  EIGHTEEN // 18+ - Adult content, explicit violence/sexual content
}

// Content warning tags (can be combined with age rating)
enum ContentTag {
  VIOLENCE // Physical violence, fighting
  GORE // Explicit violence, blood, injuries
  SEXUAL // Sexual content, innuendo
  NUDITY // Nudity or partial nudity
  LANGUAGE // Strong language, profanity
  DRUGS // Drug use or references
  ALCOHOL // Alcohol consumption
  HORROR // Horror themes, disturbing content
  PSYCHOLOGICAL // Psychological themes, mental health
  DISCRIMINATION // Discriminatory content, hate speech
  CRIME // Criminal activities
  GAMBLING // Gambling themes
}

model User {
  id                String       @id @default(uuid())
  provider          AuthProvider
  providerAccountId String
  username          String?      @unique
  email             String?      @unique
  displayName       String?
  fullName          String?
  avatarUrl         String?
  avatarSource      AvatarSource @default(PROVIDER)
  avatarUpdatedAt   DateTime?
  birthDate         DateTime?
  gender            String?
  preferredLanguage String?      @default("en") // User's preferred language for AI responses (ISO 639-1 code)
  role              UserRole     @default(BASIC)
  lastLoginAt       DateTime     @default(now())
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Content filtering preferences
  maxAgeRating AgeRating    @default(EIGHTEEN) // Maximum age rating user wants to see
  blockedTags  ContentTag[] // Content tags the user wants to block

  // Relations
  createdCharacters Character[] @relation("CharacterCreator")
  createdStories    Story[]     @relation("StoryCreator")
  createdAttires    Attire[]    @relation("AttireCreator")

  // Chat system relations
  assistants            Assistant[]               @relation("UserAssistants")
  conversations         Conversation[]            @relation("UserConversations")
  conversationParticipations ConversationParticipant[] @relation("UserParticipations")

  // Favorites
  favoriteCharacters FavoriteCharacter[] @relation("UserFavoriteCharacters")

  @@unique([provider, providerAccountId])
}

enum AvatarSource {
  PROVIDER
  UPLOADED
}

// Generic content classification model (can be used for any content type)
model ContentClassification {
  id          String       @id @default(uuid())
  ageRating   AgeRating
  contentTags ContentTag[]
  reason      String? // Optional: explanation for the rating

  // Polymorphic relations (contentType + contentId pattern)
  contentType String // e.g., "Character", "Story", "Image", "Conversation"
  contentId   String // ID of the content being classified

  // Moderation info
  autoClassified Boolean   @default(true) // Was it auto-classified or manually reviewed?
  reviewedBy     String? // User ID of moderator who reviewed (if manual)
  reviewedAt     DateTime? // When it was reviewed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([contentType, contentId]) // One classification per content item
  @@index([ageRating])
  @@index([contentType])
}

// Sticker generation status
enum StickerStatus {
  PENDING
  GENERATING
  COMPLETED
  FAILED
}

// Tag type classification
enum TagType {
  CHARACTER
  STORY
}

// LoRA model from Civitai
model Lora {
  id String @id @default(uuid())

  // Civitai integration
  civitaiModelId   String?
  civitaiVersionId String? @unique

  // Metadata
  name          String
  modelType     String? // e.g., "LORA", "Checkpoint", etc.
  baseModel     String? // e.g., "SD 1.5", "SDXL", etc.
  downloadCount Int?     @default(0)
  modelUrl      String?
  tags          String[] // Civitai tags
  trainedWords  String[] // Trigger words for the LoRA
  nsfw          Boolean  @default(false)

  // File information
  filename         String?
  filepathRelative String?
  firstImageUrl    String?
  imageUrls        String[]

  // Internal categorization
  category String?
  term     String?
  deleted  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]

  @@index([civitaiModelId])
  @@index([civitaiVersionId])
  @@index([deleted])
}

// Attire (clothing/appearance system)
model Attire {
  id          String  @id @default(uuid())
  name        String
  description String?
  gender      String? // "male", "female", "unisex"

  // Prompt components for image generation
  promptHead String? // Head/face appearance prompts
  promptBody String? // Body/clothing prompts
  promptFull String? // Full combined prompt

  previewImageUrl      String?
  originalLanguageCode String?

  // Ownership and visibility
  isPublic Boolean @default(false)
  userId   String
  owner    User    @relation("AttireCreator", fields: [userId], references: [id], onDelete: Cascade)

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  charactersUsingAsMain Character[] @relation("CharacterMainAttire")
  characters            Character[] @relation("CharacterAttires")

  @@index([userId])
  @@index([isPublic])
  @@index([ageRating])
}

// Tag system for categorization
model Tag {
  id                   String    @id @default(uuid())
  name                 String
  type                 TagType
  weight               Int       @default(1)
  ageRating            AgeRating @default(L)
  originalLanguageCode String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]
  stories    Story[]

  @@unique([name, type])
  @@index([type])
  @@index([ageRating])
}

// Character model (full implementation)
model Character {
  id String @id @default(uuid())

  // Basic information
  firstName String
  lastName  String?
  age       Int?
  gender    String? // "male", "female", "non-binary", etc.
  species   String? // "human", "elf", "robot", etc.
  style     String? // Art style preference

  // Visual and descriptive
  avatar                  String? // Avatar image URL
  physicalCharacteristics String? @db.Text // Physical appearance description
  personality             String? @db.Text // Personality traits
  history                 String? @db.Text // Background/backstory

  // Configuration
  isPublic             Boolean @default(true)
  originalLanguageCode String?

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  // Ownership
  userId  String
  creator User   @relation("CharacterCreator", fields: [userId], references: [id], onDelete: Cascade)

  // LoRA and Attire associations
  loraId String?
  lora   Lora?   @relation(fields: [loraId], references: [id], onDelete: SetNull)

  mainAttireId String?
  mainAttire   Attire? @relation("CharacterMainAttire", fields: [mainAttireId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  attires  Attire[]           @relation("CharacterAttires")
  tags     Tag[]
  stickers CharacterSticker[]

  // Chat system relations
  assistantsUsingAsDefault   Assistant[]               @relation("AssistantDefaultCharacter")
  actingParticipations       ConversationParticipant[] @relation("ParticipantActingCharacter")
  representingParticipations ConversationParticipant[] @relation("ParticipantRepresentingCharacter")

  @@index([userId])
  @@index([isPublic])
  @@index([ageRating])
  @@index([loraId])
  @@index([mainAttireId])
}

// Character stickers (emotion/action images)
model CharacterSticker {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  emotionTag String?
  actionTag  String?
  imageUrl   String?
  promptUsed String?       @db.Text
  status     StickerStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([characterId])
  @@index([status])
}

// Story model (for future phases)
model Story {
  id       String  @id @default(uuid())
  title    String
  synopsis String?

  creatorId String
  creator   User   @relation("StoryCreator", fields: [creatorId], references: [id], onDelete: Cascade)

  isPublic Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tags Tag[]

  @@index([creatorId])
  @@index([isPublic])
}

// ============================================================================
// CHAT SYSTEM MODELS (Phase 2)
// ============================================================================

// Assistant represents an AI agent with specific instructions and personality
// It can act in conversations representing a Character
model Assistant {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // System prompt / instructions that define the assistant's behavior
  instructions String @db.Text

  // Default character this assistant represents (optional)
  defaultCharacterId String?
  defaultCharacter   Character? @relation("AssistantDefaultCharacter", fields: [defaultCharacterId], references: [id], onDelete: SetNull)

  // Visibility
  isPublic Boolean @default(false)

  // Ownership
  userId  String
  creator User   @relation("UserAssistants", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participations ConversationParticipant[] @relation("ParticipantAssistant")

  @@index([userId])
  @@index([isPublic])
  @@index([defaultCharacterId])
}

// Conversation represents a chat session between user and characters
model Conversation {
  id    String @id @default(uuid())
  title String @default("New Conversation") // Topic/title of the conversation

  // Title edit tracking
  isTitleUserEdited   Boolean @default(false)
  isTitleSystemEdited Boolean @default(false)

  // Optional: link conversation to a project (for future use)
  projectId String?

  // Settings stored as JSON (LLM preferences, roleplay settings, etc.)
  settings Json? // Will store: { view, llm_settings, roleplay_specific, etc. }

  // Timestamps
  lastMessageAt     DateTime? // Timestamp of last message (for sorting)
  titleLastUpdatedAt DateTime? // When title was last changed
  memoryLastUpdatedAt DateTime? // When conversation memory was last updated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  owner  User   @relation("UserConversations", fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  participants ConversationParticipant[]
  messages     Message[]

  @@index([userId])
  @@index([lastMessageAt])
  @@index([projectId])
}

// Sender type for messages
enum SenderType {
  USER
  CHARACTER
  ASSISTANT
  SYSTEM
}

// ConversationParticipant represents an entity participating in a conversation
// Can be: User, Character (acting directly), or Assistant (acting as a character)
model ConversationParticipant {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // XOR constraint: Exactly ONE of these must be set
  // Option 1: Human user participating
  userId String?
  user   User?   @relation("UserParticipations", fields: [userId], references: [id], onDelete: Cascade)

  // Option 2: Character acting directly (no AI logic, simple responses)
  actingCharacterId String?
  actingCharacter   Character? @relation("ParticipantActingCharacter", fields: [actingCharacterId], references: [id], onDelete: Cascade)

  // Option 3: Assistant (AI) acting in the conversation
  actingAssistantId String?
  actingAssistant   Assistant? @relation("ParticipantAssistant", fields: [actingAssistantId], references: [id], onDelete: Cascade)

  // The character being visually represented (appearance, name, etc.)
  // Required when actingAssistantId is set
  representingCharacterId String?
  representingCharacter   Character? @relation("ParticipantRepresentingCharacter", fields: [representingCharacterId], references: [id], onDelete: SetNull)

  // Optional: JSON config override for this specific participant in this conversation
  configOverride String? @db.Text // JSON string

  joinedAt  DateTime @default(now())

  @@index([conversationId])
  @@index([userId])
  @@index([actingCharacterId])
  @@index([actingAssistantId])
  @@index([representingCharacterId])
  @@index([conversationId, actingCharacterId])
  @@index([conversationId, actingAssistantId])
}

// Message represents a single message in a conversation
model Message {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Sender identification
  senderId   String     // ID of the sender (User, Character, or Assistant)
  senderType SenderType // Type of sender

  // Content
  content String @db.Text // Message content (can be JSON for rich content)

  // Optional: Attachments (image URLs, file URLs, etc.)
  attachments String? @db.Text // JSON array of attachment URLs

  // Metadata (can store additional info like emotion, action, etc.)
  metadata Json? // Flexible metadata field

  timestamp DateTime @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([conversationId, timestamp])
}

// ============================================================================
// FAVORITES SYSTEM
// ============================================================================

// FavoriteCharacter represents a user's favorite character
model FavoriteCharacter {
  id String @id @default(uuid())

  userId      String
  user        User      @relation("UserFavoriteCharacters", fields: [userId], references: [id], onDelete: Cascade)

  characterId String
  // Note: We don't add a relation to Character model to avoid circular dependency issues
  // The characterId is validated at the service level

  createdAt DateTime @default(now())

  @@unique([userId, characterId]) // A user can favorite a character only once
  @@index([userId])
  @@index([characterId])
}
