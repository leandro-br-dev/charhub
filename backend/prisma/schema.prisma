generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

enum AuthProvider {
  GOOGLE
  FACEBOOK
  SYSTEM
}

enum UserRole {
  BASIC
  PREMIUM
  ADMIN
  BOT
}

// Age-based content rating system (similar to movie/anime ratings)
enum AgeRating {
  L // Livre (All ages) - General audiences
  TEN // 10+ - Mild themes
  TWELVE // 12+ - Moderate themes
  FOURTEEN // 14+ - More mature themes, mild sexual references
  SIXTEEN // 16+ - Strong themes, explicit language, moderate violence
  EIGHTEEN // 18+ - Adult content, explicit violence/sexual content
}

// Content warning tags (can be combined with age rating)
enum ContentTag {
  VIOLENCE // Physical violence, fighting
  GORE // Explicit violence, blood, injuries
  SEXUAL // Sexual content, innuendo
  NUDITY // Nudity or partial nudity
  LANGUAGE // Strong language, profanity
  DRUGS // Drug use or references
  ALCOHOL // Alcohol consumption
  HORROR // Horror themes, disturbing content
  PSYCHOLOGICAL // Psychological themes, mental health
  DISCRIMINATION // Discriminatory content, hate speech
  CRIME // Criminal activities
  GAMBLING // Gambling themes
}

// Character role in a story
enum StoryCharacterRole {
  MAIN // Main character - played by the user
  SECONDARY // Secondary character - played by AI
}

// Visibility levels for user-generated content
enum Visibility {
  PRIVATE // Only owner can see
  UNLISTED // Anyone with the link can see
  PUBLIC // Everyone can see and search
}

// Visual style options for characters
enum VisualStyle {
  ANIME        // Japanese anime style (default)
  REALISTIC    // Realistic/photorealistic style
  SEMI_REALISTIC // Semi-realistic art style
  CARTOON      // Western cartoon style
  MANGA        // Japanese manga/comic style
  MANHWA       // Korean manhwa/webtoon style
  COMIC        // Western comic book style
  CHIBI        // Super deformed/cute style
  PIXEL_ART    // Pixel art/retro game style
  THREE_D      // 3D rendered style
}

// Character gender options (standardized in English)
enum CharacterGender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
  UNKNOWN
}

// ============================================================================
// VISUAL STYLE REFERENCE SYSTEM
// ============================================================================

// Model type for style resources (checkpoints and LoRAs)
enum ModelType {
  CHECKPOINT     // Base model (SDXL, SD1.5, etc)
  LORA_STYLE     // Style enhancement LoRA (anime screencap, realistic, etc)
  LORA_CONTENT   // Content-specific LoRA (furry, hentai, etc)
}

// Content type for checkpoint overrides
enum ContentType {
  GENERAL     // Default content
  FURRY       // Anthropomorphic characters
  HENTAI      // Adult anime content
  FANTASY     // Fantasy themes
  SCI_FI      // Science fiction themes
}

// Theme enum for style + theme combinations
enum Theme {
  DARK_FANTASY  // Dark fantasy content (current default)
  FANTASY       // High fantasy, bright, magical
  FURRY         // Anthropomorphic characters
  SCI_FI        // Science fiction
  GENERAL       // General purpose
}

model User {
  id                String       @id @default(uuid())
  provider          AuthProvider
  providerAccountId String
  username          String?      @unique
  email             String?      @unique
  displayName       String?
  fullName          String?
  avatarUrl         String?
  avatarSource      AvatarSource @default(PROVIDER)
  avatarUpdatedAt   DateTime?
  birthDate         DateTime?
  gender            String?
  preferredLanguage String?      @default("en") // User's preferred language for AI responses (ISO 639-1 code)
  role              UserRole     @default(BASIC)
  lastLoginAt       DateTime     @default(now())
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Welcome flow
  hasCompletedWelcome Boolean @default(false) // Flag to show welcome modal for new users

  // Content filtering preferences
  maxAgeRating AgeRating    @default(L) // Maximum age rating user wants to see (L = Livre/All ages by default)
  blockedTags  ContentTag[] // Content tags the user wants to block

  // Relations
  createdCharacters Character[] @relation("CharacterCreator")
  stories           Story[]      @relation("StoryAuthor")
  createdAttires    Attire[]    @relation("AttireCreator")

  // Chat system relations
  assistants            Assistant[]               @relation("UserAssistants")
  conversations         Conversation[]            @relation("UserConversations")
  conversationParticipations ConversationParticipant[] @relation("UserParticipations")

  // Multi-user chat relations
  ownedConversations  Conversation[] @relation("ConversationOwner")
  memberships         UserConversationMembership[] @relation("ConversationMemberships")
  sentInvites         UserConversationMembership[] @relation("SentInvites")

  // Favorites
  favoriteCharacters FavoriteCharacter[] @relation("UserFavoriteCharacters")
  storyFavorites      StoryFavorite[]     @relation("UserStoryFavorites")

  // Credit and subscription relations
  creditTransactions CreditTransaction[] @relation("UserCreditTransactions")
  usageLogs          UsageLog[]          @relation("UserUsageLogs")
  monthlyBalances    UserMonthlyBalance[] @relation("UserMonthlyBalances")
  userPlans          UserPlan[]          @relation("UserSubscriptionPlans")
  plusAccessGrants   UserPlusAccess[]    @relation("UserPlusAccessGrants")

  // LLM cost tracking relations
  llmUsageLogs       LLMUsageLog[]       @relation("UserLLMUsageLogs")

  @@unique([provider, providerAccountId])
}

enum AvatarSource {
  PROVIDER
  UPLOADED
}

// Generic content classification model (can be used for any content type)
model ContentClassification {
  id          String       @id @default(uuid())
  ageRating   AgeRating
  contentTags ContentTag[]
  reason      String? // Optional: explanation for the rating

  // Polymorphic relations (contentType + contentId pattern)
  contentType String // e.g., "Character", "Story", "Image", "Conversation"
  contentId   String // ID of the content being classified

  // Moderation info
  autoClassified Boolean   @default(true) // Was it auto-classified or manually reviewed?
  reviewedBy     String? // User ID of moderator who reviewed (if manual)
  reviewedAt     DateTime? // When it was reviewed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([contentType, contentId]) // One classification per content item
  @@index([ageRating])
  @@index([contentType])
}

// Sticker generation status
enum StickerStatus {
  PENDING
  GENERATING
  COMPLETED
  FAILED
}

// Types of images associated with a character
enum ImageType {
  AVATAR     // Profile picture (square) - primary character image
  COVER      // Featured portrait image
  SAMPLE     // User-provided reference image for generation
  STICKER    // Expression images with transparent background
  OTHER      // Miscellaneous images
  REFERENCE  // AI-generated reference image (content field describes view: avatar, front, side, back)
}

// Tag type classification
enum TagType {
  CHARACTER // Character traits, roles, occupations
  STORY // Story genres, themes
  ASSET // Visual assets, clothing, accessories
  GAME // Game-related tags
  MEDIA // Media types (anime, manga, etc.)
  GENERAL // General classification tags
}

// LoRA model from Civitai
model Lora {
  id String @id @default(uuid())

  // Civitai integration
  civitaiModelId   String?
  civitaiVersionId String? @unique

  // Metadata
  name          String
  modelType     String? // e.g., "LORA", "Checkpoint", etc.
  baseModel     String? // e.g., "SD 1.5", "SDXL", etc.
  downloadCount Int?     @default(0)
  modelUrl      String?
  tags          String[] // Civitai tags
  trainedWords  String[] // Trigger words for the LoRA
  nsfw          Boolean  @default(false)

  // File information
  filename         String?
  filepathRelative String?
  firstImageUrl    String?
  imageUrls        String[]

  // Internal categorization
  category String?
  term     String?
  deleted  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]

  @@index([civitaiModelId])
  @@index([civitaiVersionId])
  @@index([deleted])
}

// Visual Style Configuration - manages checkpoints and LoRAs per visual style
model VisualStyleConfig {
  id   String      @id @default(uuid())
  style VisualStyle @unique // ANIME, REALISTIC, etc
  name String // Display name
  description String? // User-facing description
  isActive Boolean @default(true)

  // Theme support
  supportedThemes Theme[] // Themes this style supports

  // Default checkpoint for this style
  defaultCheckpointId String?
  defaultCheckpoint StyleCheckpoint? @relation("DefaultCheckpoint", fields: [defaultCheckpointId], references: [id])

  // Content-specific overrides
  contentCheckpoints StyleContentCheckpoint[]

  // Theme-specific checkpoint overrides
  themeCheckpoints StyleThemeCheckpoint[]

  // LoRAs to apply for this style
  styleLoras StyleLoraMapping[]

  // Style-specific prompt modifiers
  positivePromptSuffix String? // Tags to add for this style
  negativePromptSuffix String? // Tags to avoid for this style

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Stable Diffusion Checkpoints for visual styles
model StyleCheckpoint {
  id   String   @id @default(uuid())
  name String // e.g., "RAMTHRUST'S-NSFW-PINK-ALCHEMY-MIX"
  filename String @unique // e.g., "ramthrustsNSFWPINK_alchemyMix176.safetensors"
  path String // Full path in ComfyUI
  civitaiUrl String? // Reference URL
  modelType ModelType // CHECKPOINT

  // What styles use this checkpoint?
  defaultForStyles VisualStyleConfig[] @relation("DefaultCheckpoint")
  contentMappings StyleContentCheckpoint[]
  themeMappings StyleThemeCheckpoint[]

  // Configuration
  config Json? // { sampler: "DPM++ 2M Karras", cfg: 6, steps: 30 }

  isActive Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([modelType])
  @@index([isActive])
}

// LoRA Models for visual styles
model StyleLora {
  id   String   @id @default(uuid())
  name String // e.g., "Velvet's Mythic Fantasy Styles"
  filename String @unique // e.g., "iLLMythD4rkL1nesV2.safetensors"
  path String // Full path in ComfyUI (legacy, for reference)
  filepathRelative String? // Relative path from models/ folder, e.g., "loras/Illustrious/Style/xxx.safetensors"
  civitaiUrl String?
  modelType ModelType // LORA_STYLE or LORA_CONTENT

  // Trigger words (comma-separated)
  triggerWords String? // e.g., "D4rkL1nes"

  // What styles use this LoRA?
  styleMappings StyleLoraMapping[]
  themeOverrides StyleThemeCheckpoint[] @relation("ThemeLora")

  // Configuration
  weight Float @default(1.0) // Default weight (0.0-1.5)

  isActive Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([modelType])
  @@index([isActive])
}

// Maps LoRAs to Visual Styles
model StyleLoraMapping {
  id   String @id @default(uuid())

  styleId String
  styleConfig VisualStyleConfig @relation(fields: [styleId], references: [id], onDelete: Cascade)

  loraId String
  lora StyleLora @relation(fields: [loraId], references: [id], onDelete: Cascade)

  // Override default weight for this style
  weight Float?

  // Application priority (lower = applied first)
  priority Int @default(0)

  @@unique([styleId, loraId])
  @@index([styleId])
  @@index([loraId])
}

// Content-specific checkpoint overrides
model StyleContentCheckpoint {
  id   String @id @default(uuid())

  styleId String
  styleConfig VisualStyleConfig @relation(fields: [styleId], references: [id], onDelete: Cascade)

  checkpointId String
  checkpoint StyleCheckpoint @relation(fields: [checkpointId], references: [id], onDelete: Cascade)

  contentType ContentType // FURRY, HENTAI, etc

  @@unique([styleId, contentType])
  @@index([styleId])
  @@index([contentType])
  @@index([checkpointId])
}

// Theme-specific checkpoint overrides for Style + Theme combinations
model StyleThemeCheckpoint {
  id   String @id @default(uuid())

  styleId String
  styleConfig VisualStyleConfig @relation(fields: [styleId], references: [id], onDelete: Cascade)

  checkpointId String
  checkpoint StyleCheckpoint @relation(fields: [checkpointId], references: [id], onDelete: Cascade)

  theme Theme // DARK_FANTASY, FANTASY, FURRY, etc

  // Optional: LoRA override for this theme
  loraId String?
  loraOverride StyleLora? @relation("ThemeLora", fields: [loraId], references: [id], onDelete: SetNull)

  // Configuration
  loraStrength Float? // Override default LoRA strength

  @@unique([styleId, theme])
  @@index([styleId])
  @@index([theme])
  @@index([checkpointId])
}

// Attire (clothing/appearance system)
model Attire {
  id          String  @id @default(uuid())
  name        String
  description String?
  gender      String? // "male", "female", "unisex"

  // Prompt components for image generation
  promptHead String? // Head/face appearance prompts
  promptBody String? // Body/clothing prompts
  promptFull String? // Full combined prompt

  previewImageUrl      String?
  originalLanguageCode String?

  // Ownership and visibility
  visibility Visibility @default(PRIVATE)
  userId     String
  owner      User       @relation("AttireCreator", fields: [userId], references: [id], onDelete: Cascade)

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  charactersUsingAsMain Character[] @relation("CharacterMainAttire")
  characters            Character[] @relation("CharacterAttires")

  @@index([userId])
  @@index([visibility])
  @@index([ageRating])
}

// Tag system for categorization
model Tag {
  id   String  @id @default(uuid())
  name String // Tag name in English (used for search/filtering)
  description String? @db.Text // Description of the tag
  type TagType // What this tag classifies (character, story, asset, etc.)

  // Content classification (mandatory age rating)
  ageRating AgeRating @default(L) // Minimum age rating required

  // Optional content warnings (can be multiple)
  contentTags ContentTag[] // Additional content warnings (violence, nudity, etc.)

  // Translation and metadata
  originalLanguageCode String? // Language code if translated from another language
  weight               Int     @default(1) // Priority/importance weight

  // Search optimization - denormalized for faster queries
  searchable Boolean @default(true) // Whether this tag appears in searches

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]
  stories    Story[]

  @@unique([name, type]) // Same tag name can exist for different types
  @@index([type])
  @@index([ageRating])
  @@index([searchable])
}

// Species system for character classification
model Species {
  id   String  @id @default(uuid())
  name String  @unique // Species name in English (used for search/filtering)

  // Content classification (optional, for species that might be restricted)
  ageRating AgeRating @default(L) // Minimum age rating required
  contentTags ContentTag[] // Additional content warnings if needed

  // Categorization for filtering
  category String? // e.g., "humanoid", "beast", "elemental", "undead", "mythical", "robot"

  // Translation and metadata
  description String? @db.Text // Description of the species
  originalLanguageCode String? // Language code if translated from another language
  weight      Int     @default(1) // Priority/popularity weight

  // Search optimization
  searchable  Boolean @default(true) // Whether this species appears in searches

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]

  @@index([category])
  @@index([ageRating])
  @@index([searchable])
}

// Character model (full implementation)
model Character {
  id String @id @default(uuid())

  // Basic information
  firstName String
  lastName  String?
  age       Int?
  gender    CharacterGender? @default(UNKNOWN) // Standardized gender enum
  speciesId String? // Reference to Species table
  species   Species? @relation(fields: [speciesId], references: [id], onDelete: SetNull)
  style     VisualStyle? @default(ANIME) // Visual art style preference
  theme     Theme? @default(DARK_FANTASY) // Content type/theme
  reference String? // Source reference (e.g., "One Piece", "Marvel Comics")

  // Visual and descriptive
  physicalCharacteristics String? @db.Text // Physical appearance description
  personality             String? @db.Text // Personality traits
  history                 String? @db.Text // Background/backstory

  // Configuration
  visibility           Visibility @default(PUBLIC)
  isSystemCharacter    Boolean    @default(false) // System characters are hidden from users (e.g., narrator)
  originalLanguageCode String?

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  // Ownership
  userId  String
  creator User   @relation("CharacterCreator", fields: [userId], references: [id], onDelete: Cascade)

  // LoRA and Attire associations
  loraId String?
  lora   Lora?   @relation(fields: [loraId], references: [id], onDelete: SetNull)

  mainAttireId String?
  mainAttire   Attire? @relation("CharacterMainAttire", fields: [mainAttireId], references: [id], onDelete: SetNull)

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  storyCharacters StoryCharacter[] @relation("StoryCharacters")
  attires         Attire[]           @relation("CharacterAttires")
  tags            Tag[]
  stickers        CharacterSticker[]
  images          CharacterImage[]
  curatedFrom CuratedImage? // Source curated image if auto-generated

  // Chat system relations
  assistantsUsingAsDefault   Assistant[]               @relation("AssistantDefaultCharacter")
  actingParticipations       ConversationParticipant[] @relation("ParticipantActingCharacter")
  representingParticipations ConversationParticipant[] @relation("ParticipantRepresentingCharacter")

  @@index([userId])
  @@index([visibility])
  @@index([isSystemCharacter])
  @@index([ageRating])
  @@index([loraId])
  @@index([mainAttireId])
  @@index([speciesId])
}

// Character stickers (emotion/action images)
model CharacterSticker {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  emotionTag String?
  actionTag  String?
  imageUrl   String?
  promptUsed String?       @db.Text
  status     StickerStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([characterId])
  @@index([status])
}

// Character images with per-image content classification
model CharacterImage {
  id          String      @id @default(uuid())
  characterId String
  character   Character   @relation(fields: [characterId], references: [id], onDelete: Cascade)

  type        ImageType
  url         String
  key         String?
  width       Int?
  height      Int?
  sizeBytes   Int?
  contentType String?

  // Content field for REFERENCE type: describes the view (avatar, front, side, back)
  // Can also be used for other types to store additional metadata
  content     String?     @db.Text

  // Per-image classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[] @default([])
  description String?      @db.Text

  // Active image flag - only one active per type per character
  isActive    Boolean      @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([characterId])
  @@index([type])
  @@index([ageRating])
  @@index([characterId, type, isActive])
}

// Story-Character join model with role distinction
model StoryCharacter {
  id         String             @id @default(uuid())
  storyId    String
  story      Story              @relation("StoryCharacters", fields: [storyId], references: [id], onDelete: Cascade)
  characterId String
  character  Character          @relation("StoryCharacters", fields: [characterId], references: [id], onDelete: Cascade)
  role       StoryCharacterRole @default(SECONDARY) // MAIN = played by user, SECONDARY = played by AI
  order      Int                @default(0) // For ordering characters in the story

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([storyId, characterId])
  @@index([storyId])
  @@index([characterId])
  @@index([role])
}

model Story {
  id            String       @id @default(uuid())
  title         String
  synopsis      String?      @db.Text
  initialText   String?      @db.Text
  coverImage    String?
  objectives    Json?
  authorId      String
  author        User         @relation("StoryAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  storyCharacters StoryCharacter[] @relation("StoryCharacters")
  storyFavorites StoryFavorite[] @relation("StoryFavorites")
  tags          Tag[]
  ageRating     AgeRating    @default(L)
  contentTags   ContentTag[]
  visibility    Visibility   @default(PRIVATE)

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes
  originalLanguageCode String? // ISO 639-1 code of original language

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  conversations Conversation[]

  @@index([authorId])
  @@index([visibility])
}

model StoryFavorite {
  id        String   @id @default(uuid())
  userId    String
  storyId   String
  createdAt DateTime @default(now())

  user      User     @relation("UserStoryFavorites", fields: [userId], references: [id], onDelete: Cascade)
  story     Story    @relation("StoryFavorites", fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([userId, storyId])
  @@index([userId])
  @@index([storyId])
}

// ============================================================================
// CHAT SYSTEM MODELS (Phase 2)
// ============================================================================

// Assistant represents an AI agent with specific instructions and personality
// It can act in conversations representing a Character
model Assistant {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // System prompt / instructions that define the assistant's behavior
  instructions String @db.Text

  // Default character this assistant represents (optional)
  defaultCharacterId String?
  defaultCharacter   Character? @relation("AssistantDefaultCharacter", fields: [defaultCharacterId], references: [id], onDelete: SetNull)

  // Visibility
  visibility Visibility @default(PRIVATE)

  // Ownership
  userId  String
  creator User   @relation("UserAssistants", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participations ConversationParticipant[] @relation("ParticipantAssistant")

  @@index([userId])
  @@index([visibility])
  @@index([defaultCharacterId])
}

// Conversation represents a chat session between user and characters
model Conversation {
  id    String @id @default(uuid())
  title String @default("New Conversation") // Topic/title of the conversation

  // Title edit tracking
  isTitleUserEdited   Boolean @default(false)
  isTitleSystemEdited Boolean @default(false)

  // Optional: link conversation to a project (for future use)
  projectId String?

  // Optional: link conversation to a story
  story   Story?  @relation(fields: [storyId], references: [id])
  storyId String?

  // Settings stored as JSON (LLM preferences, roleplay settings, etc.)
  settings Json? // Will store: { view, llm_settings, roleplay_specific, etc. }

  // Timestamps
  lastMessageAt     DateTime? // Timestamp of last message (for sorting)
  titleLastUpdatedAt DateTime? // When title was last changed
  memoryLastUpdatedAt DateTime? // When conversation memory was last updated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  owner  User   @relation("UserConversations", fields: [userId], references: [id], onDelete: Cascade)

  // Multi-user support
  isMultiUser      Boolean @default(false)
  maxUsers         Int     @default(1) // Limite de usuários humanos (1-4)
  ownerUserId      String?
  conversationOwner User?  @relation("ConversationOwner", fields: [ownerUserId], references: [id])
  allowUserInvites Boolean @default(false) // Membros podem convidar?
  requireApproval  Boolean @default(false) // Owner precisa aprovar joins?

  // Relations
  participants ConversationParticipant[]
  messages     Message[]
  memories     ConversationMemory[]
  members      UserConversationMembership[]

  @@index([userId])
  @@index([ownerUserId])
  @@index([isMultiUser])
  @@index([lastMessageAt])
  @@index([projectId])
  @@index([storyId])
}

// Sender type for messages
enum SenderType {
  USER
  CHARACTER
  ASSISTANT
  SYSTEM
}

// Membership roles for multi-user conversations
enum MembershipRole {
  OWNER      // Criador, controle total
  MODERATOR  // Pode kick, mute, invite
  MEMBER     // Pode enviar mensagens
  VIEWER     // Read-only
}

// User membership in multi-user conversations
model UserConversationMembership {
  id             String         @id @default(uuid())
  conversationId String
  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User           @relation("ConversationMemberships", fields: [userId], references: [id], onDelete: Cascade)

  // Role and permissions
  role           MembershipRole @default(MEMBER)
  canWrite       Boolean        @default(true)  // Pode enviar mensagens?
  canInvite      Boolean        @default(false) // Pode convidar outros?
  canModerate    Boolean        @default(false) // Pode kick/mute?

  // Membership metadata
  joinedAt       DateTime       @default(now())
  invitedBy      String?
  inviter        User?          @relation("SentInvites", fields: [invitedBy], references: [id])
  isActive       Boolean        @default(true)  // false = kicked/left

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
  @@index([role])
  @@index([isActive])
}

// ConversationParticipant represents an entity participating in a conversation
// Can be: User, Character (acting directly), or Assistant (acting as a character)
model ConversationParticipant {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // XOR constraint: Exactly ONE of these must be set
  // Option 1: Human user participating
  userId String?
  user   User?   @relation("UserParticipations", fields: [userId], references: [id], onDelete: Cascade)

  // Option 2: Character acting directly (no AI logic, simple responses)
  actingCharacterId String?
  actingCharacter   Character? @relation("ParticipantActingCharacter", fields: [actingCharacterId], references: [id], onDelete: Cascade)

  // Option 3: Assistant (AI) acting in the conversation
  actingAssistantId String?
  actingAssistant   Assistant? @relation("ParticipantAssistant", fields: [actingAssistantId], references: [id], onDelete: Cascade)

  // The character being visually represented (appearance, name, etc.)
  // Required when actingAssistantId is set
  representingCharacterId String?
  representingCharacter   Character? @relation("ParticipantRepresentingCharacter", fields: [representingCharacterId], references: [id], onDelete: SetNull)

  // Optional: JSON config override for this specific participant in this conversation
  configOverride String? @db.Text // JSON string

  joinedAt  DateTime @default(now())

  @@index([conversationId])
  @@index([userId])
  @@index([actingCharacterId])
  @@index([actingAssistantId])
  @@index([representingCharacterId])
  @@index([conversationId, actingCharacterId])
  @@index([conversationId, actingAssistantId])
}

// Message represents a single message in a conversation
model Message {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Sender identification
  senderId   String     // ID of the sender (User, Character, or Assistant)
  senderType SenderType // Type of sender

  // Content
  content String @db.Text // Message content (can be JSON for rich content)

  // Optional: Attachments (image URLs, file URLs, etc.)
  attachments String? @db.Text // JSON array of attachment URLs

  // Metadata (can store additional info like emotion, action, etc.)
  metadata Json? // Flexible metadata field

  timestamp DateTime @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([conversationId, timestamp])
}

// ============================================================================
// FAVORITES SYSTEM
// ============================================================================

// FavoriteCharacter represents a user's favorite character
model FavoriteCharacter {
  id String @id @default(uuid())

  userId      String
  user        User      @relation("UserFavoriteCharacters", fields: [userId], references: [id], onDelete: Cascade)

  characterId String
  // Note: We don't add a relation to Character model to avoid circular dependency issues
  // The characterId is validated at the service level

  createdAt DateTime @default(now())

  @@unique([userId, characterId]) // A user can favorite a character only once
  @@index([userId])
  @@index([characterId])
}

// ============================================================================
// TRANSLATION SYSTEM FOR USER-GENERATED CONTENT
// ============================================================================

// Translation status for content translations
enum TranslationStatus {
  PENDING     // Translation in progress
  ACTIVE      // Translation active and available
  OUTDATED    // Original content was updated
  FAILED      // Translation failed
  REVIEWED    // Reviewed by human moderator
}

// ContentTranslation stores translations of user-generated content
// Uses polymorphic pattern to support multiple content types
model ContentTranslation {
  id String @id @default(uuid())

  // Polymorphic identification (contentType + contentId pattern)
  contentType String // "Character", "Story", "Attire", "Tag", etc.
  contentId   String // ID of the content being translated
  fieldName   String // Field being translated: "personality", "description", etc.

  // Languages
  originalLanguageCode String // ISO 639-1: "pt-BR", "en-US", etc.
  targetLanguageCode   String // Target language code
  originalText         String @db.Text // Original text (for cache/validation)
  translatedText       String @db.Text // Translated text

  // Translation metadata
  translationProvider String? // "gemini", "openai", "grok", "human"
  translationModel    String? // Model used: "gemini-2.5-flash-lite", etc.
  confidence          Float?  // Confidence score (0-1)

  // Quality control
  status     TranslationStatus @default(ACTIVE)
  reviewedBy String? // UserID of reviewer (if human reviewed)
  reviewedAt DateTime?

  // Performance metrics
  translationTimeMs Int? // Translation time in milliseconds
  characterCount    Int? // Number of characters translated

  // Versioning (to detect when original content changes)
  sourceVersion Int @default(1) // Version of the source content

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optimized indexes for ultra-fast lookup
  @@unique([contentType, contentId, fieldName, targetLanguageCode])
  @@index([contentType, contentId])
  @@index([targetLanguageCode])
  @@index([status])
  @@index([originalLanguageCode, targetLanguageCode])
}

// ============================================================================
// CONVERSATION MEMORY SYSTEM
// ============================================================================

// Stores compressed summaries of old conversation messages to reduce context size
model ConversationMemory {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Memory content
  summary        String       @db.Text // Resumo em prosa das mensagens compactadas
  keyEvents      Json         // Array de eventos importantes estruturados
  messageCount   Int          // Quantas mensagens foram resumidas neste snapshot

  // Range of messages summarized
  startMessageId String? // ID da primeira mensagem resumida
  endMessageId   String? // ID da última mensagem resumida

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([conversationId])
  @@index([createdAt])
}

// ============================================================================
// CREDIT AND SUBSCRIPTION SYSTEM
// ============================================================================

// Credit transactions log
model CreditTransaction {
  id                   String                @id @default(uuid())
  userId               String
  user                 User                  @relation("UserCreditTransactions", fields: [userId], references: [id], onDelete: Cascade)
  transactionType      CreditTransactionType
  amountCredits        Float
  balanceAfter         Float?
  notes                String?
  relatedUsageLogId    String?
  relatedPlanId        String?
  timestamp            DateTime              @default(now())

  @@index([userId])
  @@index([userId, timestamp])
  @@index([transactionType])
  @@index([timestamp])
}

// Subscription plans
model Plan {
  id                   String          @id @default(uuid())
  tier                 PlanTier        @unique
  name                 String
  priceMonthly         Float
  creditsPerMonth      Int
  description          String?
  features             Json?
  isActive             Boolean         @default(true)
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  // Translation support
  originalLanguageCode String          @default("en-US")
  contentVersion       Int             @default(1)

  // Multi-provider support
  paymentProvider      PaymentProvider @default(STRIPE)

  // PayPal (existing)
  paypalPlanId         String?         @unique

  // Stripe (new)
  stripePriceId        String?         @unique
  stripeProductId      String?

  userPlans         UserPlan[]      @relation("PlanSubscriptions")

  @@index([tier])
  @@index([isActive])
  @@index([paymentProvider])
}

// Service credit costs configuration
model ServiceCreditCost {
  id                String   @id @default(uuid())
  serviceIdentifier String   @unique
  creditsPerUnit    Float
  unitDescription   String
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([serviceIdentifier])
  @@index([isActive])
}

// Usage logs for tracking service consumption
model UsageLog {
  id                  String      @id @default(uuid())
  userId              String
  user                User        @relation("UserUsageLogs", fields: [userId], references: [id], onDelete: Cascade)
  conversationId      String?
  serviceType         String      // Service identifier (e.g., "llm_chat_safe", "image_generation")
  providerName        String?     // Provider (e.g., "openai", "gemini")
  modelName           String?     // Model name (e.g., "gpt-4", "gemini-2.0-flash-exp")
  inputTokens         Int?
  outputTokens        Int?
  charactersProcessed Int?        // For TTS/STT services
  imagesProcessed     Int?
  costUsd             Float?      // Cost in USD from provider
  creditsConsumed     Float?
  additionalMetadata  Json?       // Additional metadata
  processed           Boolean     @default(false)
  processedAt         DateTime?
  timestamp           DateTime    @default(now())

  @@index([userId])
  @@index([userId, processed])
  @@index([serviceType])
  @@index([timestamp])
  @@index([processed])
  @@index([creditsConsumed]) // For filtering unprocessed logs (WHERE creditsConsumed IS NULL)
}

// Monthly credit balance tracking
model UserMonthlyBalance {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation("UserMonthlyBalances", fields: [userId], references: [id], onDelete: Cascade)
  monthStartDate  DateTime
  startingBalance Float
  creditsGranted  Float    @default(0)
  creditsSpent    Float    @default(0)
  endingBalance   Float
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, monthStartDate])
  @@index([userId])
  @@index([monthStartDate])
}

// User subscription to plans
model UserPlan {
  id                    String             @id @default(uuid())
  userId                String
  user                  User               @relation("UserSubscriptionPlans", fields: [userId], references: [id], onDelete: Cascade)
  planId                String
  plan                  Plan               @relation("PlanSubscriptions", fields: [planId], references: [id])
  status                SubscriptionStatus @default(ACTIVE)

  // Multi-provider support
  paymentProvider       PaymentProvider?

  // PayPal (existing)
  paypalSubscriptionId  String?            @unique

  // Stripe (new)
  stripeSubscriptionId  String?            @unique
  stripeCustomerId      String?

  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  cancelAtPeriodEnd     Boolean            @default(false)
  canceledAt            DateTime?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  lastCreditsGrantedAt  DateTime?

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@index([paymentProvider])
  @@index([paypalSubscriptionId])
  @@index([stripeSubscriptionId])
}

// Plus tier access grants (for admin-granted access)
model UserPlusAccess {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation("UserPlusAccessGrants", fields: [userId], references: [id], onDelete: Cascade)
  grantedBy String?
  reason    String?
  startDate DateTime
  endDate   DateTime
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
  @@index([endDate])
}

// ============================================================================
// CREDIT AND SUBSCRIPTION ENUMS
// ============================================================================

enum CreditTransactionType {
  GRANT_INITIAL
  GRANT_PLAN
  PURCHASE
  CONSUMPTION
  SYSTEM_REWARD
  REFUND
  ADJUSTMENT
  REFERRAL_BONUS
  PROMOTIONAL
}

enum PlanTier {
  FREE
  PLUS
  PREMIUM
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED    // British spelling to match code
  EXPIRED
  PAYMENT_FAILED
}

// Payment provider options for subscriptions
enum PaymentProvider {
  STRIPE
  PAYPAL
}

// ============================================================================
// AUTOMATED CHARACTER POPULATION SYSTEM
// ============================================================================

// Status of a curated image in the curation pipeline
enum CurationStatus {
  PENDING      // Awaiting classification
  APPROVED     // Approved for generation
  REJECTED     // Rejected (inappropriate content)
  PROCESSING   // In generation
  COMPLETED    // Character generated successfully
  FAILED       // Generation failed
}

// Curated image from external sources (Civitai, etc.) for character generation
model CuratedImage {
  id              String   @id @default(uuid())
  sourceUrl       String   @unique
  sourceId        String?  // Civitai image ID
  sourcePlatform  String   @default("civitai")

  // Metadata from source
  tags            String[] // Source tags (e.g., Civitai tags)
  sourceRating    Float?   // Rating original (1-5)
  author          String?  // Artist original
  license         String?  // License info

  // Curation
  status          CurationStatus @default(PENDING)
  ageRating       AgeRating?
  qualityScore    Float?   // Quality assessment (0-5)
  contentTags     ContentTag[] // AI-generated content tags
  description     String?  @db.Text // AI-generated description

  // Diversity tracking (for improved character generation variety)
  gender          String?  // "male", "female", "non-binary", "unknown"
  species         String?  // "human", "elf", "robot", "furry", "demon", "angel", etc.

  // Storage
  localPath       String?  // Temp storage path
  uploadedToR2    Boolean  @default(false)
  r2Url           String?
  r2Key           String?

  // Processing
  generatedCharId String?  @unique
  generatedChar   Character? @relation(fields: [generatedCharId], references: [id], onDelete: SetNull)

  // Audit
  createdAt       DateTime @default(now())
  processedAt     DateTime?
  rejectedAt      DateTime?
  rejectionReason String?

  @@index([status, ageRating])
  @@index([createdAt])
  @@index([processedAt])
}

// Batch generation log for tracking automated character generation runs
model BatchGenerationLog {
  id                String   @id @default(uuid())
  scheduledAt       DateTime
  executedAt        DateTime @default(now())
  completedAt       DateTime?

  // Stats
  targetCount       Int      // How many should be generated
  successCount      Int      @default(0)
  failureCount      Int      @default(0)

  // Details
  selectedImages    String[] // IDs of the curated images selected
  generatedCharIds  String[] // IDs of the characters generated
  errors            Json?    // Errors encountered

  // Metrics
  duration          Int?     // Seconds
  costEstimate      Float?   // USD

  @@index([scheduledAt])
  @@index([executedAt])
}

// ============================================================================
// SYSTEM CONFIGURATION AND CORRECTION LOGGING (FEATURE-011)
// ============================================================================

// System configuration key-value storage
model SystemConfiguration {
  id          String   @id @default(uuid())
  key         String   @unique
  value       String
  description String?
  category    String?  // e.g., "generation", "correction", "curation"
  updatedAt   DateTime @updatedAt
  updatedBy   String?  // User ID who last updated

  @@index([category])
}

// Correction job execution log
model CorrectionJobLog {
  id            String   @id @default(uuid())
  jobType       String   // "avatar-correction" or "data-completeness-correction"
  targetCount   Int
  successCount  Int
  failureCount  Int
  duration      Int?     // Duration in seconds
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  errors        Json?    // Array of {characterId, error}
  metadata      Json?    // Additional job-specific data

  @@index([jobType, startedAt])
}

// ============================================================================
// LLM COST TRACKING SYSTEM
// ============================================================================

// LLM Provider enum
enum LLMProvider {
  GEMINI
  OPENAI
  GROK
  ANTHROPIC
  TOGETHER_AI
  GROQ
}

// Feature type enum for LLM usage tracking
enum FeatureType {
  CHARACTER_GENERATION
  STORY_GENERATION
  CONTENT_TRANSLATION
  CHAT_MESSAGE
  AUTOMATED_GENERATION
  IMAGE_ANALYSIS
  OTHER
}

// LLM Usage Log - tracks all LLM API calls for cost analysis
model LLMUsageLog {
  id          String   @id @default(uuid())

  // Context
  userId      String?
  user        User?    @relation("UserLLMUsageLogs", fields: [userId], references: [id], onDelete: SetNull)
  feature     FeatureType // CHARACTER_GEN, STORY_GEN, TRANSLATION, CHAT, etc
  featureId   String?  // ID of character, story, etc (for drill-down)

  // LLM Details
  provider    LLMProvider // GEMINI, OPENAI, GROK, etc
  model       String   // e.g., "gemini-2.5-flash-lite", "gpt-4o-mini"
  operation   String?  // e.g., "character_analysis", "translation", "chat_response"

  // Token Usage
  inputTokens  Int
  outputTokens Int
  totalTokens  Int

  // Cost Calculation (in USD)
  inputCost    Decimal  @db.Decimal(10, 6)
  outputCost   Decimal  @db.Decimal(10, 6)
  totalCost    Decimal  @db.Decimal(10, 6)

  // Timing
  latency      Int?     // Response time in ms
  cached       Boolean  @default(false) // Was response cached?

  // Metadata
  metadata     Json?    // Additional context

  createdAt    DateTime @default(now())

  @@index([userId, feature, createdAt])
  @@index([feature, createdAt])
  @@index([createdAt])
  @@index([provider, model])
}

// LLM Pricing Configuration - stores pricing data for LLM models
model LLMPricing {
  id          String   @id @default(uuid())

  provider    LLMProvider
  model       String   // e.g., "gemini-2.5-flash-lite"

  // Pricing per 1M tokens (USD)
  inputPricePerMillion  Decimal @db.Decimal(10, 4)
  outputPricePerMillion Decimal @db.Decimal(10, 4)

  // Effective date range
  effectiveFrom DateTime @default(now())
  effectiveTo   DateTime?

  // Metadata
  source      String?  // e.g., "https://ai.google.dev/pricing"
  notes       String?  @db.Text

  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([provider, model, effectiveFrom])
  @@index([provider, model])
  @@index([isActive])
  @@index([effectiveFrom])
}
