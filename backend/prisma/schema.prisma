generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthProvider {
  GOOGLE
  FACEBOOK
}

enum UserRole {
  BASIC
  PREMIUM
  ADMIN
}

// Age-based content rating system (similar to movie/anime ratings)
enum AgeRating {
  L // Livre (All ages) - General audiences
  TEN // 10+ - Mild themes
  TWELVE // 12+ - Moderate themes
  FOURTEEN // 14+ - More mature themes, mild sexual references
  SIXTEEN // 16+ - Strong themes, explicit language, moderate violence
  EIGHTEEN // 18+ - Adult content, explicit violence/sexual content
}

// Content warning tags (can be combined with age rating)
enum ContentTag {
  VIOLENCE // Physical violence, fighting
  GORE // Explicit violence, blood, injuries
  SEXUAL // Sexual content, innuendo
  NUDITY // Nudity or partial nudity
  LANGUAGE // Strong language, profanity
  DRUGS // Drug use or references
  ALCOHOL // Alcohol consumption
  HORROR // Horror themes, disturbing content
  PSYCHOLOGICAL // Psychological themes, mental health
  DISCRIMINATION // Discriminatory content, hate speech
  CRIME // Criminal activities
  GAMBLING // Gambling themes
}

// Visibility levels for user-generated content
enum Visibility {
  PRIVATE // Only owner can see
  UNLISTED // Anyone with the link can see
  PUBLIC // Everyone can see and search
}

// Visual style options for characters
enum VisualStyle {
  ANIME        // Japanese anime style (default)
  REALISTIC    // Realistic/photorealistic style
  SEMI_REALISTIC // Semi-realistic art style
  CARTOON      // Western cartoon style
  MANGA        // Japanese manga/comic style
  MANHWA       // Korean manhwa/webtoon style
  COMIC        // Western comic book style
  CHIBI        // Super deformed/cute style
  PIXEL_ART    // Pixel art/retro game style
  THREE_D      // 3D rendered style
}

model User {
  id                String       @id @default(uuid())
  provider          AuthProvider
  providerAccountId String
  username          String?      @unique
  email             String?      @unique
  displayName       String?
  fullName          String?
  avatarUrl         String?
  avatarSource      AvatarSource @default(PROVIDER)
  avatarUpdatedAt   DateTime?
  birthDate         DateTime?
  gender            String?
  preferredLanguage String?      @default("en") // User's preferred language for AI responses (ISO 639-1 code)
  role              UserRole     @default(BASIC)
  lastLoginAt       DateTime     @default(now())
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Content filtering preferences
  maxAgeRating AgeRating    @default(EIGHTEEN) // Maximum age rating user wants to see
  blockedTags  ContentTag[] // Content tags the user wants to block

  // Relations
  createdCharacters Character[] @relation("CharacterCreator")
  stories           Story[]      @relation("StoryAuthor")
  createdAttires    Attire[]    @relation("AttireCreator")

  // Chat system relations
  assistants            Assistant[]               @relation("UserAssistants")
  conversations         Conversation[]            @relation("UserConversations")
  conversationParticipations ConversationParticipant[] @relation("UserParticipations")

  // Multi-user chat relations
  ownedConversations  Conversation[] @relation("ConversationOwner")
  memberships         UserConversationMembership[] @relation("ConversationMemberships")
  sentInvites         UserConversationMembership[] @relation("SentInvites")

  // Favorites
  favoriteCharacters FavoriteCharacter[] @relation("UserFavoriteCharacters")

  // Credit and subscription relations
  creditTransactions CreditTransaction[] @relation("UserCreditTransactions")
  usageLogs          UsageLog[]          @relation("UserUsageLogs")
  monthlyBalances    UserMonthlyBalance[] @relation("UserMonthlyBalances")
  userPlans          UserPlan[]          @relation("UserSubscriptionPlans")
  plusAccessGrants   UserPlusAccess[]    @relation("UserPlusAccessGrants")

  @@unique([provider, providerAccountId])
}

enum AvatarSource {
  PROVIDER
  UPLOADED
}

// Generic content classification model (can be used for any content type)
model ContentClassification {
  id          String       @id @default(uuid())
  ageRating   AgeRating
  contentTags ContentTag[]
  reason      String? // Optional: explanation for the rating

  // Polymorphic relations (contentType + contentId pattern)
  contentType String // e.g., "Character", "Story", "Image", "Conversation"
  contentId   String // ID of the content being classified

  // Moderation info
  autoClassified Boolean   @default(true) // Was it auto-classified or manually reviewed?
  reviewedBy     String? // User ID of moderator who reviewed (if manual)
  reviewedAt     DateTime? // When it was reviewed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([contentType, contentId]) // One classification per content item
  @@index([ageRating])
  @@index([contentType])
}

// Sticker generation status
enum StickerStatus {
  PENDING
  GENERATING
  COMPLETED
  FAILED
}

// Types of images associated with a character
enum ImageType {
  AVATAR
  COVER
  SAMPLE
  STICKER
  OTHER
}

// Tag type classification
enum TagType {
  CHARACTER // Character traits, roles, occupations
  STORY // Story genres, themes
  ASSET // Visual assets, clothing, accessories
  GAME // Game-related tags
  MEDIA // Media types (anime, manga, etc.)
  GENERAL // General classification tags
}

// LoRA model from Civitai
model Lora {
  id String @id @default(uuid())

  // Civitai integration
  civitaiModelId   String?
  civitaiVersionId String? @unique

  // Metadata
  name          String
  modelType     String? // e.g., "LORA", "Checkpoint", etc.
  baseModel     String? // e.g., "SD 1.5", "SDXL", etc.
  downloadCount Int?     @default(0)
  modelUrl      String?
  tags          String[] // Civitai tags
  trainedWords  String[] // Trigger words for the LoRA
  nsfw          Boolean  @default(false)

  // File information
  filename         String?
  filepathRelative String?
  firstImageUrl    String?
  imageUrls        String[]

  // Internal categorization
  category String?
  term     String?
  deleted  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]

  @@index([civitaiModelId])
  @@index([civitaiVersionId])
  @@index([deleted])
}

// Attire (clothing/appearance system)
model Attire {
  id          String  @id @default(uuid())
  name        String
  description String?
  gender      String? // "male", "female", "unisex"

  // Prompt components for image generation
  promptHead String? // Head/face appearance prompts
  promptBody String? // Body/clothing prompts
  promptFull String? // Full combined prompt

  previewImageUrl      String?
  originalLanguageCode String?

  // Ownership and visibility
  visibility Visibility @default(PRIVATE)
  userId     String
  owner      User       @relation("AttireCreator", fields: [userId], references: [id], onDelete: Cascade)

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  charactersUsingAsMain Character[] @relation("CharacterMainAttire")
  characters            Character[] @relation("CharacterAttires")

  @@index([userId])
  @@index([visibility])
  @@index([ageRating])
}

// Tag system for categorization
model Tag {
  id   String  @id @default(uuid())
  name String // Tag name in English (used for search/filtering)
  description String? @db.Text // Description of the tag
  type TagType // What this tag classifies (character, story, asset, etc.)

  // Content classification (mandatory age rating)
  ageRating AgeRating @default(L) // Minimum age rating required

  // Optional content warnings (can be multiple)
  contentTags ContentTag[] // Additional content warnings (violence, nudity, etc.)

  // Translation and metadata
  originalLanguageCode String? // Language code if translated from another language
  weight               Int     @default(1) // Priority/importance weight

  // Search optimization - denormalized for faster queries
  searchable Boolean @default(true) // Whether this tag appears in searches

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characters Character[]
  stories    Story[]

  @@unique([name, type]) // Same tag name can exist for different types
  @@index([type])
  @@index([ageRating])
  @@index([searchable])
}

// Character model (full implementation)
model Character {
  id String @id @default(uuid())

  // Basic information
  firstName String
  lastName  String?
  age       Int?
  gender    String? // "male", "female", "non-binary", etc.
  species   String? // "human", "elf", "robot", etc.
  style     VisualStyle? @default(ANIME) // Visual art style preference
  reference String? // Source reference (e.g., "One Piece", "Marvel Comics")

  // Visual and descriptive
  physicalCharacteristics String? @db.Text // Physical appearance description
  personality             String? @db.Text // Personality traits
  history                 String? @db.Text // Background/backstory

  // Configuration
  visibility           Visibility @default(PUBLIC)
  isSystemCharacter    Boolean    @default(false) // System characters are hidden from users (e.g., narrator)
  originalLanguageCode String?

  // Content classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[]

  // Ownership
  userId  String
  creator User   @relation("CharacterCreator", fields: [userId], references: [id], onDelete: Cascade)

  // LoRA and Attire associations
  loraId String?
  lora   Lora?   @relation(fields: [loraId], references: [id], onDelete: SetNull)

  mainAttireId String?
  mainAttire   Attire? @relation("CharacterMainAttire", fields: [mainAttireId], references: [id], onDelete: SetNull)

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  stories  Story[]
  attires  Attire[]           @relation("CharacterAttires")
  tags     Tag[]
  stickers CharacterSticker[]
  images   CharacterImage[]

  // Chat system relations
  assistantsUsingAsDefault   Assistant[]               @relation("AssistantDefaultCharacter")
  actingParticipations       ConversationParticipant[] @relation("ParticipantActingCharacter")
  representingParticipations ConversationParticipant[] @relation("ParticipantRepresentingCharacter")

  @@index([userId])
  @@index([visibility])
  @@index([isSystemCharacter])
  @@index([ageRating])
  @@index([loraId])
  @@index([mainAttireId])
}

// Character stickers (emotion/action images)
model CharacterSticker {
  id          String    @id @default(uuid())
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  emotionTag String?
  actionTag  String?
  imageUrl   String?
  promptUsed String?       @db.Text
  status     StickerStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([characterId])
  @@index([status])
}

// Character images with per-image content classification
model CharacterImage {
  id          String      @id @default(uuid())
  characterId String
  character   Character   @relation(fields: [characterId], references: [id], onDelete: Cascade)

  type        ImageType
  url         String
  key         String?
  width       Int?
  height      Int?
  sizeBytes   Int?
  contentType String?

  // Per-image classification
  ageRating   AgeRating    @default(L)
  contentTags ContentTag[] @default([])
  description String?      @db.Text

  // Active image flag - only one active per type per character
  isActive    Boolean      @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([characterId])
  @@index([type])
  @@index([ageRating])
  @@index([characterId, type, isActive])
}

model Story {
  id            String       @id @default(uuid())
  title         String
  synopsis      String?      @db.Text
  initialText   String?      @db.Text
  coverImage    String?
  objectives    Json?
  authorId      String
  author        User         @relation("StoryAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  characters    Character[]
  tags          Tag[]
  ageRating     AgeRating    @default(L)
  contentTags   ContentTag[]
  visibility    Visibility   @default(PRIVATE)

  // Translation versioning
  contentVersion Int @default(1) // Increments when translatable content changes
  originalLanguageCode String? // ISO 639-1 code of original language

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  conversations Conversation[]

  @@index([authorId])
  @@index([visibility])
}

// ============================================================================
// CHAT SYSTEM MODELS (Phase 2)
// ============================================================================

// Assistant represents an AI agent with specific instructions and personality
// It can act in conversations representing a Character
model Assistant {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // System prompt / instructions that define the assistant's behavior
  instructions String @db.Text

  // Default character this assistant represents (optional)
  defaultCharacterId String?
  defaultCharacter   Character? @relation("AssistantDefaultCharacter", fields: [defaultCharacterId], references: [id], onDelete: SetNull)

  // Visibility
  visibility Visibility @default(PRIVATE)

  // Ownership
  userId  String
  creator User   @relation("UserAssistants", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participations ConversationParticipant[] @relation("ParticipantAssistant")

  @@index([userId])
  @@index([visibility])
  @@index([defaultCharacterId])
}

// Conversation represents a chat session between user and characters
model Conversation {
  id    String @id @default(uuid())
  title String @default("New Conversation") // Topic/title of the conversation

  // Title edit tracking
  isTitleUserEdited   Boolean @default(false)
  isTitleSystemEdited Boolean @default(false)

  // Optional: link conversation to a project (for future use)
  projectId String?

  // Optional: link conversation to a story
  story   Story?  @relation(fields: [storyId], references: [id])
  storyId String?

  // Settings stored as JSON (LLM preferences, roleplay settings, etc.)
  settings Json? // Will store: { view, llm_settings, roleplay_specific, etc. }

  // Timestamps
  lastMessageAt     DateTime? // Timestamp of last message (for sorting)
  titleLastUpdatedAt DateTime? // When title was last changed
  memoryLastUpdatedAt DateTime? // When conversation memory was last updated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  owner  User   @relation("UserConversations", fields: [userId], references: [id], onDelete: Cascade)

  // Multi-user support
  isMultiUser      Boolean @default(false)
  maxUsers         Int     @default(1) // Limite de usuários humanos (1-4)
  ownerUserId      String?
  conversationOwner User?  @relation("ConversationOwner", fields: [ownerUserId], references: [id])
  allowUserInvites Boolean @default(false) // Membros podem convidar?
  requireApproval  Boolean @default(false) // Owner precisa aprovar joins?

  // Relations
  participants ConversationParticipant[]
  messages     Message[]
  memories     ConversationMemory[]
  members      UserConversationMembership[]

  @@index([userId])
  @@index([ownerUserId])
  @@index([isMultiUser])
  @@index([lastMessageAt])
  @@index([projectId])
  @@index([storyId])
}

// Sender type for messages
enum SenderType {
  USER
  CHARACTER
  ASSISTANT
  SYSTEM
}

// Membership roles for multi-user conversations
enum MembershipRole {
  OWNER      // Criador, controle total
  MODERATOR  // Pode kick, mute, invite
  MEMBER     // Pode enviar mensagens
  VIEWER     // Read-only
}

// User membership in multi-user conversations
model UserConversationMembership {
  id             String         @id @default(uuid())
  conversationId String
  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User           @relation("ConversationMemberships", fields: [userId], references: [id], onDelete: Cascade)

  // Role and permissions
  role           MembershipRole @default(MEMBER)
  canWrite       Boolean        @default(true)  // Pode enviar mensagens?
  canInvite      Boolean        @default(false) // Pode convidar outros?
  canModerate    Boolean        @default(false) // Pode kick/mute?

  // Membership metadata
  joinedAt       DateTime       @default(now())
  invitedBy      String?
  inviter        User?          @relation("SentInvites", fields: [invitedBy], references: [id])
  isActive       Boolean        @default(true)  // false = kicked/left

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
  @@index([role])
  @@index([isActive])
}

// ConversationParticipant represents an entity participating in a conversation
// Can be: User, Character (acting directly), or Assistant (acting as a character)
model ConversationParticipant {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // XOR constraint: Exactly ONE of these must be set
  // Option 1: Human user participating
  userId String?
  user   User?   @relation("UserParticipations", fields: [userId], references: [id], onDelete: Cascade)

  // Option 2: Character acting directly (no AI logic, simple responses)
  actingCharacterId String?
  actingCharacter   Character? @relation("ParticipantActingCharacter", fields: [actingCharacterId], references: [id], onDelete: Cascade)

  // Option 3: Assistant (AI) acting in the conversation
  actingAssistantId String?
  actingAssistant   Assistant? @relation("ParticipantAssistant", fields: [actingAssistantId], references: [id], onDelete: Cascade)

  // The character being visually represented (appearance, name, etc.)
  // Required when actingAssistantId is set
  representingCharacterId String?
  representingCharacter   Character? @relation("ParticipantRepresentingCharacter", fields: [representingCharacterId], references: [id], onDelete: SetNull)

  // Optional: JSON config override for this specific participant in this conversation
  configOverride String? @db.Text // JSON string

  joinedAt  DateTime @default(now())

  @@index([conversationId])
  @@index([userId])
  @@index([actingCharacterId])
  @@index([actingAssistantId])
  @@index([representingCharacterId])
  @@index([conversationId, actingCharacterId])
  @@index([conversationId, actingAssistantId])
}

// Message represents a single message in a conversation
model Message {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Sender identification
  senderId   String     // ID of the sender (User, Character, or Assistant)
  senderType SenderType // Type of sender

  // Content
  content String @db.Text // Message content (can be JSON for rich content)

  // Optional: Attachments (image URLs, file URLs, etc.)
  attachments String? @db.Text // JSON array of attachment URLs

  // Metadata (can store additional info like emotion, action, etc.)
  metadata Json? // Flexible metadata field

  timestamp DateTime @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([conversationId, timestamp])
}

// ============================================================================
// FAVORITES SYSTEM
// ============================================================================

// FavoriteCharacter represents a user's favorite character
model FavoriteCharacter {
  id String @id @default(uuid())

  userId      String
  user        User      @relation("UserFavoriteCharacters", fields: [userId], references: [id], onDelete: Cascade)

  characterId String
  // Note: We don't add a relation to Character model to avoid circular dependency issues
  // The characterId is validated at the service level

  createdAt DateTime @default(now())

  @@unique([userId, characterId]) // A user can favorite a character only once
  @@index([userId])
  @@index([characterId])
}

// ============================================================================
// TRANSLATION SYSTEM FOR USER-GENERATED CONTENT
// ============================================================================

// Translation status for content translations
enum TranslationStatus {
  PENDING     // Translation in progress
  ACTIVE      // Translation active and available
  OUTDATED    // Original content was updated
  FAILED      // Translation failed
  REVIEWED    // Reviewed by human moderator
}

// ContentTranslation stores translations of user-generated content
// Uses polymorphic pattern to support multiple content types
model ContentTranslation {
  id String @id @default(uuid())

  // Polymorphic identification (contentType + contentId pattern)
  contentType String // "Character", "Story", "Attire", "Tag", etc.
  contentId   String // ID of the content being translated
  fieldName   String // Field being translated: "personality", "description", etc.

  // Languages
  originalLanguageCode String // ISO 639-1: "pt-BR", "en-US", etc.
  targetLanguageCode   String // Target language code
  originalText         String @db.Text // Original text (for cache/validation)
  translatedText       String @db.Text // Translated text

  // Translation metadata
  translationProvider String? // "gemini", "openai", "grok", "human"
  translationModel    String? // Model used: "gemini-2.5-flash-lite", etc.
  confidence          Float?  // Confidence score (0-1)

  // Quality control
  status     TranslationStatus @default(ACTIVE)
  reviewedBy String? // UserID of reviewer (if human reviewed)
  reviewedAt DateTime?

  // Performance metrics
  translationTimeMs Int? // Translation time in milliseconds
  characterCount    Int? // Number of characters translated

  // Versioning (to detect when original content changes)
  sourceVersion Int @default(1) // Version of the source content

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optimized indexes for ultra-fast lookup
  @@unique([contentType, contentId, fieldName, targetLanguageCode])
  @@index([contentType, contentId])
  @@index([targetLanguageCode])
  @@index([status])
  @@index([originalLanguageCode, targetLanguageCode])
}

// ============================================================================
// CONVERSATION MEMORY SYSTEM
// ============================================================================

// Stores compressed summaries of old conversation messages to reduce context size
model ConversationMemory {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Memory content
  summary        String       @db.Text // Resumo em prosa das mensagens compactadas
  keyEvents      Json         // Array de eventos importantes estruturados
  messageCount   Int          // Quantas mensagens foram resumidas neste snapshot

  // Range of messages summarized
  startMessageId String? // ID da primeira mensagem resumida
  endMessageId   String? // ID da última mensagem resumida

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([conversationId])
  @@index([createdAt])
}

// ============================================================================
// CREDIT AND SUBSCRIPTION SYSTEM
// ============================================================================

// Credit transactions log
model CreditTransaction {
  id                   String                @id @default(uuid())
  userId               String
  user                 User                  @relation("UserCreditTransactions", fields: [userId], references: [id], onDelete: Cascade)
  transactionType      CreditTransactionType
  amountCredits        Float
  balanceAfter         Float?
  notes                String?
  relatedUsageLogId    String?
  relatedPlanId        String?
  timestamp            DateTime              @default(now())

  @@index([userId])
  @@index([userId, timestamp])
  @@index([transactionType])
  @@index([timestamp])
}

// Subscription plans
model Plan {
  id                String       @id @default(uuid())
  tier              PlanTier     @unique
  name              String
  priceMonthly      Float
  creditsPerMonth   Int
  description       String?
  features          Json?
  isActive          Boolean      @default(true)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  paypalPlanId      String?      @unique
  userPlans         UserPlan[]   @relation("PlanSubscriptions")

  @@index([tier])
  @@index([isActive])
}

// Service credit costs configuration
model ServiceCreditCost {
  id                String   @id @default(uuid())
  serviceIdentifier String   @unique
  creditsPerUnit    Float
  unitDescription   String
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([serviceIdentifier])
  @@index([isActive])
}

// Usage logs for tracking service consumption
model UsageLog {
  id                  String      @id @default(uuid())
  userId              String
  user                User        @relation("UserUsageLogs", fields: [userId], references: [id], onDelete: Cascade)
  conversationId      String?
  serviceType         String      // Service identifier (e.g., "llm_chat_safe", "image_generation")
  providerName        String?     // Provider (e.g., "openai", "gemini")
  modelName           String?     // Model name (e.g., "gpt-4", "gemini-2.0-flash-exp")
  inputTokens         Int?
  outputTokens        Int?
  charactersProcessed Int?        // For TTS/STT services
  imagesProcessed     Int?
  costUsd             Float?      // Cost in USD from provider
  creditsConsumed     Float?
  additionalMetadata  Json?       // Additional metadata
  processed           Boolean     @default(false)
  processedAt         DateTime?
  timestamp           DateTime    @default(now())

  @@index([userId])
  @@index([userId, processed])
  @@index([serviceType])
  @@index([timestamp])
  @@index([processed])
  @@index([creditsConsumed]) // For filtering unprocessed logs (WHERE creditsConsumed IS NULL)
}

// Monthly credit balance tracking
model UserMonthlyBalance {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation("UserMonthlyBalances", fields: [userId], references: [id], onDelete: Cascade)
  monthStartDate  DateTime
  startingBalance Float
  creditsGranted  Float    @default(0)
  creditsSpent    Float    @default(0)
  endingBalance   Float
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, monthStartDate])
  @@index([userId])
  @@index([monthStartDate])
}

// User subscription to plans
model UserPlan {
  id                    String             @id @default(uuid())
  userId                String
  user                  User               @relation("UserSubscriptionPlans", fields: [userId], references: [id], onDelete: Cascade)
  planId                String
  plan                  Plan               @relation("PlanSubscriptions", fields: [planId], references: [id])
  status                SubscriptionStatus @default(ACTIVE)
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  cancelAtPeriodEnd     Boolean            @default(false)
  canceledAt            DateTime?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  lastCreditsGrantedAt  DateTime?
  paypalSubscriptionId  String?            @unique

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@index([paypalSubscriptionId])
}

// Plus tier access grants (for admin-granted access)
model UserPlusAccess {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation("UserPlusAccessGrants", fields: [userId], references: [id], onDelete: Cascade)
  grantedBy String?
  reason    String?
  startDate DateTime
  endDate   DateTime
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
  @@index([endDate])
}

// ============================================================================
// CREDIT AND SUBSCRIPTION ENUMS
// ============================================================================

enum CreditTransactionType {
  GRANT_INITIAL
  GRANT_PLAN
  PURCHASE
  CONSUMPTION
  SYSTEM_REWARD
  REFUND
  ADJUSTMENT
  REFERRAL_BONUS
  PROMOTIONAL
}

enum PlanTier {
  FREE
  PLUS
  PREMIUM
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED    // British spelling to match code
  EXPIRED
  PAYMENT_FAILED
}
